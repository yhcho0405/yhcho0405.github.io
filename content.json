{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"알고리즘 공부 시작","text":"목표 알고리즘 공부 시험 기간이라도 백준 하루 한 문제 이상은 꼭 풀도록 노력 (실패) ​ 공부할 알고리즘 그리디 알고리즘 다이나믹 프로그래밍 bfs, dfs 다익스트라 알고리즘 브루트 포스 플로이드 와샬 알고리즘 ​ 2019년 10월 24일 기준 solved.ac기준 20191013에 그리디 알고리즘 시작함. 13일 - 8문제 14일 - 3문제 15일 - 1문제 16일 - 2문제 17일 - 2문제 18일 - 1문제 19일 - 1문제 20일 - 1문제(교양 중간 전날) 21일부터 전공시험 전날이라 못함. 22일 - 전날 밤새서 잤음 23일 - 1문제 24일 - 2문제 앞으로 푼 문제들은 전부 블로그에 정리해서 적을 예정. 이전까지의 문제들은 기억 되짚어서 천천히 게시 예정. 마무리 목표 구체화가 필요하다 느낌. 예전 코드 보니까 뭔 생각으로 저리 짰는지 기억이 안 나서 적을 공간이 필요했음. 13일 시작일 기준 알고리즘에 대해 무지한 생태. c++ 기본 문법 정도만 알고 있었음.","link":"/2019/10/24/20191024-A_BOJstart/"},{"title":"[C++]BOJ 10610 - 30","text":"어떤 수가 3의 배수인지 확인하는 방법은 각 자릿수를 모두 더한 값이 3의 배수여야 한다. 이는 간단한 방법으로 증명할 수 있다. 10^n자릿수가 9일 때 3을 더하면 10^n의 자리에서 7만큼을 손해 보고 10^n+1의 자리에서 1의 이득을 본다. -7+1(역시나 3의 배수) 결국엔 계속 3의 배수가 되는데 생각해보니 정렬된 거나 안된 거나 같이 위의 조건을 만족한다면 그냥 모듈러 연산으로 해도 된다는 생각이 들었다. 어쨌든 30의 배수가 되려면 위의 조건에서 0이 문자열에 포함되어 있는지 확인해 봐야 한다. 조건을 모두 만족한 후 내림차순 정렬하면 풀린다. 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(char a, char b){ return a &gt; b;}int main(){ string n; cin &gt;&gt; n; long long s = 0; bool z = false; for(int i = 0; i &lt; n.size(); i++) { s += (n[i] - '0'); if(!(n[i] - '0')) z = true; } if(!z || s % 3) cout &lt;&lt; -1 &lt;&lt; endl; else { sort(n.begin(), n.end(), cmp); cout &lt;&lt; n &lt;&lt; endl; }}","link":"/2019/10/24/20191024-boj10610/"},{"title":"[C++]BOJ 11047 - 동전0","text":"동전금액이 큰 단위부터 나눠가면 된다. 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;int main(){ int n, k; cin &gt;&gt; n &gt;&gt; k; int v[11]; for(int i = 0; i &lt; n; i++) { cin &gt;&gt; v[i]; } int g = 0; int j = n - 1; while(1) { if(k == 0) { break; } if(v[j] &lt;= k) { g += k / v[j]; k = k % v[j]; } j--; } cout &lt;&lt; g;}","link":"/2019/10/24/20191024-boj11047/"},{"title":"[C++]BOJ 1120 - 문자열","text":"단순 그리디. B 안에서의 차이가 가장 적은 A를 구하면 그게 답이다. 추가하는 연산은 무조건 차이가 가장 적게 할 테니까 신경 쓰지 않는다. 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int main(){ char a[50], b[50]; cin &gt;&gt; a &gt;&gt; b; int al = sprintf(a, \"%s\", a); int bl = sprintf(b, \"%s\", b); int c = 51; for(int i = 0; i &lt; bl - al + 1; i++) { int co = 0; for(int j = 0; j &lt; al; j++) { if(b[j+i] != a[j]) co++; } if(co &lt; c) c = co; } cout &lt;&lt; c;} 지금보면 좀 한심한 코드다. 배열 길이 구하겠다고 sprintf를 썼다. 시간나면 수정해서 다시 올리자. 불편해서 바로 해버렸다. 12345678910111213141516#include &lt;iostream&gt;using namespace std;int main(){ string a, b; cin &gt;&gt; a &gt;&gt; b; int c = 51; for(int i = 0; i &lt; b.size() - a.size() + 1; i++) { int co = 0; for(int j = 0; j &lt; a.size(); j++) if(b[j+i] != a[j]) co++; if(co &lt; c) c = co; } cout &lt;&lt; c;}","link":"/2019/10/24/20191024-boj1120/"},{"title":"[C++]BOJ 11399 - ATM","text":"앞사람의 인출 시간이 적을 때 전체 인출 시간이 적어진다. 1234567891011121314151617#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int time[1001]; int a; cin &gt;&gt; a; for(int i = 0; i &lt; a; i++) cin &gt;&gt; time[i]; sort(time, time + a); long long b = 0; for(int i = 0; i &lt; a; i++) for(int j = 0; j &lt; i + 1; j++) b += time[j]; cout &lt;&lt; b;}","link":"/2019/10/24/20191024-boj11399/"},{"title":"[C++]BOJ 1931 - 회의실배정","text":"회의가 끝나는 시간이 빠른 회의 순으로 정렬 후 이전 회의의 끝나는 시간과 현재 회의가 시작하는 시간의 조건을 만족시키면 회의 수를 +1 한다. 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; p;int main(){ int a; cin &gt;&gt; a; p b[100001]; for(int i = 0; i &lt; a; i++) { cin &gt;&gt; b[i].second &gt;&gt; b[i].first; } sort(b, b+a); int c = 1; int l = b[0].first; for(int i = 1; i &lt; a; i++) { if(b[i].second &gt;= l) { l = b[i].first; c++; } } cout &lt;&lt; c;} 이 문제 풀다가 pair를 발견했다. 쓸모가 많을 듯 하다.pair를 sort시키면 first기준으로 정렬한다는 점.","link":"/2019/10/24/20191024-boj1931/"},{"title":"[C++]BOJ 2217 - 로프","text":"다음 로프의 길이가 현재 로프의 길이보다 항상 크거나 같다고 가정했을 때, {앞으로 남은 로프의 수 + 1(자기 자신)} * 자신의 길이가 다음 로프에서 같은 연산을 수행했을 때 보다 작다면 다음 로프의 길이 * (앞으로 남은 로프의 수 + 1)가 최대로 견딜 수 있는 하중이 된다. 이를 반복문 돌리면 풀린다. +정렬까지 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int n; cin &gt;&gt; n; short a[100001]; for(int i = 0; i &lt; n ; i++) { cin &gt;&gt; a[i]; } sort(a, a+n); int k = 0; for(int i = 0; i &lt; n; i++) { if(k &lt; a[i] * (n - i)) { k = a[i] * (n - i); } } cout &lt;&lt; k;}","link":"/2019/10/24/20191024-boj2217/"},{"title":"[C++]BOJ 2875 - 대회 or 인턴","text":"엄청 간단한 문제였는데 방심했다가 틀렸다. 여자 수 / 2 남자 수 여자 수 + 남자 수 - 인턴 수 3개 중에 가장 작은 값이 답이다. 가장 작은 값을 제외하곤 서로의 반례가 되기 때문. 12345678#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; cout &lt;&lt; min(min(n/2, m), (n+m-k)/3) &lt;&lt; endl;}","link":"/2019/10/24/20191024-boj2875/"},{"title":"[C++]BOJ 5585 - 거스름돈","text":"동전 내는 문제에서 거스름돈으로 바뀐 문제. 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int main(){ short a; cin &gt;&gt; a; a = 1000 - a; int b = 0; b += a / 500; a = a % 500; b += a / 100; a = a % 100; b += a / 50; a = a % 50; b += a / 10; a = a % 10; b += a / 5; a = a % 5; b += a / 1; a = a % 1; cout &lt;&lt; b;}","link":"/2019/10/24/20191024-boj5585/"},{"title":"[C++]BOJ 1046 - 기타줄","text":"딴 거 다 필요 없고 가장 싼 패키지와 낱개 가격만 있으면 된다. 그걸 구하기 위해 나는 정렬을 사용한 모양이다. 굳이 그랬어야 할까. 아무튼 경우의 수는 3가지다. 패키지로 살 수 있을 만큼 산 후 나머지 부족한 것을 낱개로 구입. 전부 낱개로 구입. 기타줄 몇 개 남더라도 싹 다 패키지로 구입. 3개 중 가장 작은 게 답이다. 123456789101112131415161718include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int n, m; short pa[50], na[50]; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; m; i++) cin &gt;&gt; pa[i] &gt;&gt; na[i]; sort(pa, pa+m); sort(na, na+m); int d1 = pa[0] * (n / 6) + na[0] * (n % 6); int d2 = na[0] * n; int d3 = pa[0] * ((n / 6) + 1); int v = min(min(d1, d2), d3); cout &lt;&lt; v; } 정렬은 아무리 봐도 불편하다.나중에 수정하자.","link":"/2019/10/25/20191025-boj1046/"},{"title":"[C++]BOJ 1541 - 잃어버린 괄호","text":"가장 작은 답이 나오려면 +끼리 괄호로 묶고 계산하면 된다. 라고 생각했지만 계속 반례가 생각나서 이건 아닐 거라고 판단했고 그냥 첫 번째 -가 나온 순간부터 다 빼버리면 처음 생각했던 것보다 단순하게 끝난다. +아스키코드 10은 line feed (다음 줄) 1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main(){ bool ch = false; int a, b; char c; scanf(\"%d\", &amp;a); for(;scanf(\"%c\", &amp;c), c != 10;) { if(c == '-') ch = true; scanf(\"%d\", &amp;b); if(ch) a -= b; else a += b; } cout &lt;&lt; a;} cin으로 받아보려 했으나 작동이 안 돼서 scanf로 받았다. 자료형을 정확히 명시해줘야 하는 것 같다. 추가로 for 문에 대해 새로 알게 된 점. for(시작할 때 한 번만 실행; 조건문 말고도 scanf 같은 거 사용 가능, 한번 돌 때마다 조건문 확인해서 매번 실행되는 듯; 증감식, 여기도 매번 실행) 더 찾아봐야 알겠지만 이런 느낌인 듯. ​ 이렇게도 될까? 12345678910111213141516#include &lt;iostream&gt;using namespace std;int main(){ bool ch = false; int a, b; char c; for(scanf(\"%d\", &amp;a); scanf(\"%c\", &amp;c), c != 10;) { if(c == '-') ch = true; scanf(\"%d\", &amp;b); if(ch) a -= b; else a += b; } cout &lt;&lt; a;} 된다. 2바이트 줄였다.","link":"/2019/10/25/20191025-boj1541/"},{"title":"[C++]BOJ 1946 - 신입 사원","text":"문제에 헷갈리는 문장이 있었다. “다른 모든 지원자와 비교했을 때 서류심사 성적과 면접시험 성적 중 적어도 하나가 다른 지원자보다 떨어지지 않는 자만 선발한다는 원칙을 세웠다.” ??????????? 한참을 보다가 다음 줄 보고 이해했다. “즉, 어떤 지원자 A의 성적이 다른 어떤 지원자 B의 성적에 비해 서류 심사 결과와 면접 성적이 모두 떨어진다면 A는 결코 선발되지 않는다.” ㅇㅎ 이전에 회의실 배정인가 거기서 썼던 pair를 쓰면 편하겠단 생각이 들었다. first는 어차피 오름차순으로 정렬되니 다음 사람의 점수보다 무조건 낮을 것이고 그 와중에 second까지 작으면 조건에 의해 걔는 탈락이다. 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; p;int tk[21];int main(){ p v[100001]; short t; int n; cin &gt;&gt; t; for(int i = 0; i &lt; t; i++) { cin &gt;&gt; n; for(int j = 0; j &lt; n; j++) { cin &gt;&gt; v[j].first &gt;&gt; v[j].second; } sort(v, v+n); int po = v[0].second; int p = n; for(int j = 0; j &lt; n; j++) { if(po &lt; v[j].second) p--; else po = v[j].second; } tk[i] = p; } for(int i = 0; i &lt; t; i++) cout &lt;&lt; tk[i] &lt;&lt; endl;} 왜 배열명을 tk로 썼는지 기억이 가물가물한데 아마 테스트 케이스를 줄여서 tk라 한듯하다. 근데 놀랍게도 test case를 굳이 줄인다면 tc이다. 졸았나보다.","link":"/2019/10/25/20191025-boj1946/"},{"title":"[C++]BOJ 1080 - 행렬","text":"짝수 번 선택시 원래대로가 되기 때문에 같은 칸을 두 번 이상 선택할 필요가 없다. 1번 조건을 다르게 생각해보면 선택 순서또한 중요치 않다는 뜻도 된다. 왼쪽 위부터 한자리씩 비교하며 다르면 그 칸을 포함해 오른쪽으로 3, 아래로 3 칸을 바꿔준다. 전체가 같아지면 멈추고 모든 칸을 다 바꿨는데 다르면 -1출력. 1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt;using namespace std;int n, m;char a[51][51], b[51][51];void swap(int i, int j) { for (int ii = i-1; ii &lt;= i+1; ii++) for (int jj = j-1; jj &lt;= j+1; jj++) a[ii][jj] = '0' + '1' - a[ii][jj];}bool com(void) { for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) if (a[i][j] != b[i][j]) return false; return true;}int main(void) { scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) scanf(\"%s\", a[i]); for (int i = 0; i &lt; n; i++) scanf(\"%s\", b[i]); int cnt = 0; for (int i = 1; i &lt; n-1; i++) for (int j = 1; j &lt; m-1; j++) if (a[i-1][j-1] != b[i-1][j-1]) { swap(i, j); cnt++; } printf(\"%d\", com()? cnt : -1); return 0;} scanf(“%s”, )를 사용하면 행렬 형태로 담아야 할 char 자료형을 for문 하나로 받아올 수 있다.","link":"/2019/10/28/20191028-boj1080/"},{"title":"[C++]BOJ 2529 - 부등호","text":"가장 큰 수를 구할 때 앞자리에 9를 넣고 시작한다. 다음 부등호가 “&lt;” 라면 부등호 다음 수를 9로 만들고 그전의 자리에는 -1을 해준다. “&gt;” 라면 사용 안 했던 수 중에 가장 큰 수를 넣는다.이런 방식으로 부등호 개수만큼 반복한다. 가장 작은 수를 구할 때 앞자리에 0을 넣고 시작한다. 다음 부등호가 “&gt;” 라면 부등호 다음 수를 0으로 만들고 그전의 자리에는 +1을 해준다. “&lt;” 라면 사용 한했던 수 중에 가장 작은 수를 넣는다. 이런 방식으로 부등호 개수만큼 반복한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;using namespace std;int main(){ short a[10]; short p[10] = {0, }; short k; cin &gt;&gt; k; char b[10]; for(int i = 0; i &lt; k; i++) cin &gt;&gt; b[i]; short po = 0; a[0] = 9; p[9] = 1; for(int i = 0; i &lt; k; i++) { if(b[i] == '&lt;') { a[i+1] = a[i]; for(int j = po; j &lt; i+1; j++) p[--a[j]] = 1; } if(b[i] == '&gt;') { po = i + 1; for(int j = 9; j &gt; -1; j--) if(p[j] == 0) { a[i + 1] = j; p[j] = 1; break; } } } for(int i = 0; i &lt;= k; i++) cout &lt;&lt; a[i]; cout &lt;&lt; endl; short l[10] = {0, }; po = 0; a[0] = 0; l[0] = 1; for(int i = 0; i &lt; k; i++) { if(b[i] == '&gt;') { a[i+1] = a[i]; for(int j = po; j &lt; i+1; j++) l[++a[j]] = 1; } if(b[i] == '&lt;') { po = i + 1; for(int j = 0; j &lt; 10; j++) if(l[j] == 0) { a[i + 1] = j; l[j] = 1; break; } } } for(int i = 0; i &lt;= k; i++) cout &lt;&lt; a[i];} for 문 굳이 2번 돌릴 필요 없이 함수로 짜면 깔끔할 듯하다.","link":"/2019/10/28/20191028-boj2529/"},{"title":"[C++]BOJ 2352 - 반도체 설계","text":"뭔가 했는데 알고리즘 분류를 보니 LIS라고 한다. lower_bound로 최장증가수열을 구현하는 방식을 봤는데 실제로 유효한 수열을 구하진 않았다. 그런데 이 문제는 수열을 구하는 게 아니라 수열의 길이만 구하면 되므로 최대한 생략하고 수열의 길이만 구하도록 바꿨다. 123456789101112131415#include &lt;iostream&gt;using namespace std;int n, g, t, L[40001];int main(){ cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; t; auto p = lower_bound(L+1, L+g+1, t); *p = t; if(p == L+g+1) g++; } cout &lt;&lt; g;} 나중에 더 찾아봐야 겠다.","link":"/2019/11/03/20191103-boj2352/"},{"title":"[C++]BOJ 11053 - 가장 긴 증가하는 부분 수열","text":"이전의 반도체 설계 문제와 동일하게 최장 증가 수열을 구하는 문제다. 2020년 4원 7일 포스트 수정 저 문제 풀 때는 dp가 뭔지도 몰랐다.이번엔 동적 계획법으로 풀어봤다.dp[i]에 arr[i]이전의 값들을 비교하며 arr[i]보다 작은 값이 있다면 그 때의 dp[]에 담겨있는 값 + 1을 dp[i]에 넣는다. arr[i]이전의 모든 수에 위 과정을 반복했을 때 가장 큰 수가 dp[i]가 된다.마지막으로 dp[]에 담겨있는 값 중 가장 큰 값이 최장증가수열의 길이가 된다. 123456789101112131415#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, arr[1001], dp[1001];int main() { cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; arr[i]; dp[i] = 1; for(int j = i; j != 0; j--) if(arr[j] &lt; arr[i]) dp[i] = max(dp[i], dp[j] + 1); } sort(dp, dp + n + 1); cout &lt;&lt; dp[n];}","link":"/2019/11/04/20191104-boj11053/"},{"title":"크롬 확장프로그램 개발 일지","text":"크롬 확장 프로그램에 갑자기 꽂혀서 방학 때 낭비되는 시간도 아깝고 공부도 할겸 시작했다.웹과 자바스크립트에 대해 무지한 상태에서 시작한 터라 시행착오를 많이 겪었다. 2019년 12월 23일 노베이스 개발 시작 크롬 익스텐션으로 주제 설정. 구글링해가며 구동방식 이해. 개발할 기능 구상. 유튜브 동영상 시청 시, 시청중인 위치를 영상 제목과 함께 북마크해 모아주는 기능 구상.(onetab에서 아이디어 얻음) 현재 시청중인 분, 초를 가져올 방법을 생각해야 함. html body태그에서 모든 단어들을 가져오기 =&gt; 띄어쓰기로 스플릿 해서 구분 =&gt; 줄바꿈으로 스플릿해서 분, 초 가 담긴 인덱스로 화면에 출력까지 성공.(아마 더 쉽게하는 방법이 있을 것) 문제점 html로 현재 재생중인 부분을 가져오다 보니 영상 시청 중 아래 타임라인이 사라지면 사라지기 직전의 시간을 가져온다는 점. 추가 할 기능 여러개의 북마크를 어떻게 보여줄지. 북마크된 링크로 넘어가는 방식은 어떻게 할지(링크누르기?, 버튼누르기?) 아이디어 유튜브 링크 뒤에 시간을 붙이면 그 시간대로 영상이 재생된다. 2019년 12월 24일 유튜브 게시자의 프로필사진을 불러와 보여주는 기능 구상. 추출해야할 jpg파일의 src값 img태그의 class이름까지는 구했는데 자바스크립트에서 이를 받아올 방법을 찾아야 함. jquery를 이용해 보려 했으나 실패. 북마킹 버튼 디자인(오픈소스 활용) 문제점 위에서 말했던 대로 jquery를 못 쓰고 js로만 해보려 했으나 안됨. 아직도 23일 문제점 1을 해결하지 못함. 추가 할 기능 북마크된 정보에 프로필사진과 채널 명, 제목 일부를 보여줄 레이아웃 구상. 크롬 내부저장소에 북마크 된 정보를 저장. 아이디어 채널 프로필 사진을 함께 보여주어 정보확인 부분에서의 명확성을 높힘. 2019년 12월 25일 새로운 확장프로그램 아이디어 생겨서 병행하느라 별로 못함. 2019년 12월 26일 게시자의 프로필 사진을 가져오는 것 보단 썸네일을 가져오는게 가시성이 더 높을 것이라 판단. 썸네일을 html iframe으로 불러오는데 성공. 링크와 합쳐 화면에 띄우는 데 성공. 삭제버튼 추가. 문제점 썸네일 위 아래로 검은색 여백이 생간다. 크기를 강제로 줄이면 아래쪽 썸네일이 잘리기 때문에 해결하지 못한다. 2019년 12월 27일 전체적인 레이아웃 수정. 제목 가져와서 화면에 표시하기 성공. 제목 string으로 형변환 후 “ - YouTube” 삭제. 뒤늦은 오류 발견.(해결) 타이틀을 가져올 때 알람의 수 만큼 제목 앞에 붙어서 출력되는 문제 수정. 현재 시간을 가져올 때 가끔 인덱스 참조 예외가 생기는 문제 수정. (추후 유튜브 UI가 업데이트 되면 다시 발생할 가능성이 있기 때문에 오류코드와 이메일 삽입) 문제점 디자인 수정 필요. 크롬 저장소 활용해야 함. youtube에서만 작동하도록 예외처리가 안됨. 버튼이 사라지게 하는 방법 찾기. 추가할 점 버튼의 활용 및 레이아웃 구상. 2019년 12월 28일 유튜브에서만 동작할 수 있도록 예외처리 함. 제목 자르기 부분의 오류 확인 및 수정.(알람에 9+가 떴을 경우 외 여러가지 상황에 유동적으로 반응하게끔) 유튜브 안에는 있지만 동영상을 시청하지 않는 상황에 대한 예외처리 완료. 문제점 동영상이 끝났을 때 에러코드 출력함. 예외처리 필요. 크롬 익스텐션에선 html의 인라인 함수를 보안상의 이유로 막아놈.(인라인 onclick 사용 불가) 2번의 이유로 js파일 내부에서 버튼 클릭 이벤트를 만들었으나, html 파일의 형식으로 insertBefore메서드를 사용할 방법을 찾아야 함. 아이디어 북마크가 쌓이면서 스크롤이 내려간다면 북마크 버튼의 위치를 유동적으로 바꾸는 방법이 있으면 좋겠다. 2019년 12월 29일 insertBefore 메소드를 사용하지 않고 append로 처리해 클릭하면 현재의 창이 스크랩 되도록 함. 크롬 스토리지 기능을 사용해 북마크를 자동으로 저장하고 가져오는 기능 추가. delete all 버튼도 기능 부여. 스토리지 기능 사용하며 코드 구조 수정. 예외처리 때문에 유튜브 밖에서 기록 삭제가 안되는 오류 수정. 썸네일 가져오는 방식을 iframe에서 img로 바꿈. 썸네일 상하 여백 크롭. 문제점 익스텐션에서 a태그를 사용할 수 없다. 추가할 점 썸네일과 제목 클릭 시 하이퍼링크. 레이아웃 수정. 알수 없는 크롬저장소 오류 원인 찾기. 발견 된 오류 정상 작동 하나, 가끔 삭제 후 다시 들어가보면 다시 생겨있거나 이전의 기록과 합쳐짐. 2019년 12월 30일 디자인 레이아웃 수정. 하이퍼링크 기능 활성화. 썸네일 테두리 둥글게 처리. 제목 2줄이상 오버플로우는 hidden처리. 실시간 영상의 경우 인덱스 오류 발생. 인덱스 참조에러가 알림의 유, 무와 관련있다는 사실 파악. 29일 발생한 오류 1번을 해결함. 시간 가져오는 방식 갈아엎음.(27일 발생한 인덱스 참조 오류의 원인 자체를 없앰.) 문제점 16개 밖에 저장하지 못함.(string이 담을 수 있는 최대용량을 넘은것은 터무니없고 크롬 스토리지도 5mb까지 지원하기 때문에 충분하다. 아마 구조체 형식으로 처리해야 할 듯 하다.) chrome.storage.sync는 용량제한 100kb가 걸려있다는 사실 알게됨.(local은 제한 없어서 그거 썼다) 2019년 12월 31일 개별 삭제 버튼 추가. 2020년 1월 1일 id값은 고유해야 함. 개별삭제기능 구현. 아직 오류있음. 오류해결 초반에 기획했던 기능은 모두 구현 완료. 2020년 1월 2일 처음 사용자에게 발생하는 undefined 오류에 안내말 삽입. 1차 디버깅, 오류는 위 사항 말고 발견되지 않음. 2020년 1월 31일 처음 사용자에게 발생하는 저장소 오류에 대한 예외처리 코드 추가. 크롬 웹 스토어에 등록 거부됨. 재등록 후 등록 심사중. 최종적으론 크롬 웹 스토어에 등록을 성공했으며 블로그 좌측 배너에 링크되어 있다. 혹은 여기초반에 구상한 기능은 모두 구현해 놨지만 아쉬운점이 많다.삽질도 많이 했지만 그래서 더 의미있는 경험이었다.","link":"/2020/01/31/20200131-js-chrome-extension/"},{"title":"밴드 동아리 스케줄러 만들기","text":"내가 만들고 싶은건 아니고 부탁받았다.내용은 아래와 같다. 팀은 월 화 수 목 금 세션은 보컬 신디 베이스 기타 드럼 각 팀마다 세션에 들어가는 인원이 최소 한 명 이상은 있어야 함 팀의 특정 세션의 최소, 최대 인원수를 정하고 돌릴 수 있으면 좋겠음 ex) 월요일팀 보컬 1~2 기타 1~3 베이스 2 신디 2~3 드럼 2 이름, 가능한 세션(복수선택 가능), 가능한요일(복수선택 가능), 희망하는 최대 팀 개수를 입력 팀을 짤 때 둘 이상의 세션에 한 사람만 들어가면 안됨 ex) 보컬 A, 기타 A, 신디 B, 베이스 C, 드럼 D 희망하는 최대 팀 개수가 2 이상인 사람을 팀에 그보다 적게 넣어도 팀이 짜진다면 굳이 더 넣을 필요 없음 꼭 한 팀에 붙어야 되는 사람을 정할 수 있으면 좋겠음 (희망사항ㅎㅎ) ex) E랑 F는 꼭 같은 팀이어야 한다. c++ 기반으로 작성할 예정이고 파일 입출력을 통해 동아리원들 정보를 받고 시간표를 출력한다.자고 일어나서 만들자. 일어났다. 동아리원이 30명 정도이기 때문에 최소의 경우로 인당 단 하루 한개의 세션을 선택해도 경우의 수는 아래와 같다. $$25^{30}$$ 계산기피셜 자릿수만 42자리다. 모든 경우의 수를 다 대입해보는 것은 무리라고 생각했고 최적의 시간표를 만드는 방법을 찾아야 했다. 우선 개인별로 아래와 같은 하나의 시간표를 가진다.예를 들어 A라는 사람은 화, 수, 목요일에 출석이 가능하고 기타와 베이스를 다룰줄 안다고 가정하자. 보컬:V 기타:G 베이스:B 신디:S 드럼:D A의 시간표 월 화 수 목 금 V G O O O B O O O S D 개인별로 저런 형태의 시간표를 가지고 이를 3차원 배열로 저장한다. 다음으로 모든 시간표들로부터 각 칸의 빈도수를 저장할 2차원 배열을 만든다. 빈도수 월 화 수 목 금 V 3 2 3 1 1 G 1 1 1 1 1 B 3 2 3 1 1 S 1 1 1 1 2 D 1 1 1 1 2 숫자가 클 수록 상대적으로 널널한 시간대라고 볼 수 있다. 여기서 각 시간대별로 사용자가 미리 저장해둔 최소인원을 빼면 그 시간대에 움직임이 자유로운 가용인원 즉, 후에 가중치로 사용될 표가 생성된다. 시간대가 비어있어서 시간표 생성이 불가능하거나 최소인원보다 적게 인원이 집계된 경우와 같은 예외처리를 해준다. 모든 준비를 마치면 모든 사람의 시간표들을 체크하며 세로선당 가중치가 가장 작은 부분의 스케줄을 제외하고 모두 삭제한다.이후 희망하는 최대 요일 수 만큼 남을 때 까지 가중치가 큰 순서대로 제외한다. 문제점을 발견했다. 쓰기 귀찮아서 사진으로 대체한다.","link":"/2020/03/03/20200303-cpp-project-bandscheduler/"},{"title":"선택 정렬(Selection Sort)","text":"주어진 배열에서 가장 작은 숫자를 앞으로 옮겨가며 정렬하는 방법이다. #include &lt;climits&gt; 는 자료형의 최대, 최소값이 정의된 헤더파일이다. 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;climits&gt;using namespace std;int main() { int min, idx, tmp, arr[10] = {10,5,4,6,2,3,7,9,1,8}; for(int i = 0; i &lt; 10; i++) { min = INT_MAX; for(int j = i; j &lt; 10; j++) { if(min &gt; arr[j]) { min = arr[j]; idx = j; } } tmp = arr[i]; arr[i] = arr[idx]; arr[idx] = tmp; } for(int i = 0; i &lt; 10; i ++) cout &lt;&lt; arr[i] &lt;&lt; \" \";} 흔히 ‘정렬’이라는 주제를 떠올렸을 때 가장 직관적으로 떠올릴 수 있는 방법 중 하나인 만큼 비 효율적이다. 알고리즘의 성능을 분석할 때 시간복잡도라는 척도를 사용한다고 한다. n개의 수를 정렬한다면위 식을 빅 오 표기법으로 나타내면 O(n^2) 가 된다. algorithm average worst best space select O(N^2) O(N^2) O(N^2) O(1)","link":"/2020/03/09/20200309-algorithm-theory1/"},{"title":"버블 정렬(Bubble Sort)","text":"인접한 두 원소를 비교하며 정렬하는 방법이다.학기 초에 자주 접해서 익숙하다. 위 움짤은 마약같다. 1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main() { int tmp, arr[10] = {10,5,4,6,2,3,7,9,1,8}; for(int i = 0; i &lt; 10; i++) { for(int j = 0; j &lt; 9 - i; j++) { if(arr[j] &gt; arr[j + 1]) { tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; } } } for(int i = 0; i &lt; 10; i++) cout &lt;&lt; arr[i] &lt;&lt; \" \";} 시간 복잡도는 선택정렬과 동일하다.O(n^2) 가 된다.하지만 선택 정렬보다 느리게 작동한다.버블정렬은 매번 인접한 원소의 자리를 바꿔줘야 하지만 선택정렬은 배열에서 가장 작은 원소의 자리만 바꿔주면 되기 때문에 연산하는 양에서 차이가 발생한다. 위 코드에 실행 중 스왑이 안 발생할 시 break 해주면 성능을 높일 수 있다. algorithm average worst best space bubble O(N^2) O(N^2) O(N^2) O(1)","link":"/2020/03/09/20200309-algorithm-theory2/"},{"title":"삽입 정렬(Insertion Sort)","text":"배열의 모든 요소를 앞에서부터 이미 정렬된 배열과 비교하여 적절한 위치를 찾는 정렬 방법이다. 1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main() { int tmp, arr[10] = {10,5,4,6,2,3,7,9,1,8}; for(int i = 0; i &lt; 9; i++) { int j = i; while(arr[j] &gt; arr[j + 1]) { tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; j--; } } for(int i = 0; i &lt; 10; i++) cout &lt;&lt; arr[i] &lt;&lt; \" \";} 최악의 경우번의 비교를 하게 되므로, O(n^2) 가 된다.역시나 선택정렬이나 버블정렬과 같은 시간복잡도를 가지지만 실제론 삽입정렬이 가장 빠르다.필요할 때만 위치를 바꾸기 때문에 거의 정렬이 된 상태일 때 가장 빠르고, 자원을 덜 사용하여 효율적으로 작동한다.때문에 다른 정렬 알고리즘의 일부로 사용되는 경우가 있다. algorithm average worst best space insert O(N^2) O(N^2) O(N) O(1)","link":"/2020/03/09/20200309-algorithm-theory3/"},{"title":"퀵 정렬(Quick Sort)","text":"분할 정복 알고리즘의 대표적인 예시이며 피봇을 기준으로 정렬해 나가는 정렬 방법이다. 분할과정과 정복과정으로 나누어져 있으며, 피봇을 정한 뒤 피봇을 기준으로 작거나 큰것으로 나눠간다.퀵소트의 피봇 선정 방식은 여러가지가 존재한다. 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;int arr[10] = {10,5,4,6,2,3,7,9,1,8};int num = 10;void quickSort(int *arr, int start, int end) { if(start &gt;= end) { return; } int key = start; int i = start + 1; int j = end; int tmp; while(i &lt;= j) { while(arr[i] &lt;= arr[key]) { i++; } while(arr[j] &gt;= arr[key] &amp;&amp; j &gt; start) { j--; } if(i &gt; j) { tmp = arr[j]; arr[j] = arr[key]; arr[key] = tmp; } else { tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp; } } quickSort(arr, start, j - 1); quickSort(arr, j + 1, end);}int main() { quickSort(arr, 0, num - 1); for(int i = 0; i &lt; 10; i++) cout &lt;&lt; arr[i] &lt;&lt; \" \";} 위의 코드는 피봇을 왼쪽의 요소로 잡는 알고리즘이다.퀵소트는 이름에서 알 수 있드시 매우 빠른 정렬 알고리즘에 속한다.하지만 최악의 경우 n^2으로 작동할 여지가 있다.아이러니하게도 최악의 경우는 배열이 이미 정렬 되어있을 때 발생한다.이 문제를 해결하기 위해 피봇을 랜덤으로 선정하거나 중위법을 이용하는 방법, 작은 분할 범위의 정렬은 삽입정렬을 이용하는 방법등이 있다. 여담으로 C++ STL #include &lt;algorithm&gt; 라이브러리의 sort() 함수는 퀵소트를 기반으로 작성되었다.(모든 경우에서 O(n log n)을 보장한다.) algorithm average worst best space quick O(NlogN) O(N^2) O(NlogN) O(logN)","link":"/2020/03/14/20200314-algorithm-theory4/"},{"title":"병합 정렬(Merge Sort)","text":"퀵소트와 마찬가지로 분할정복 알고리즘이다.재귀함수를 이용해 배열을 절반으로 잘라가며 분할하고 정복한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;using namespace std;int arr[10];void merge(int a[], int m, int mid, int n) { int i = m; int j = mid + 1; int k = m; while(i &lt;= mid &amp;&amp; j &lt;= n) { if(a[i] &lt;= a[j]) { arr[k] = a[i]; i++; } else { arr[k] = a[j]; j++; } k++; } if(i &gt; mid) { for(int t = j; t &lt;= n; t++) { arr[k] = a[t]; k++; } } else { for(int t = i; t &lt;= mid; t++) { arr[k] = a[t]; k++; } } for(int t = m; t &lt;= n; t++) { a[t] = arr[t]; }}void mergeSort(int a[], int m, int n) { if(m &lt; n) { int mid = (m + n) / 2; mergeSort(a, m, mid); mergeSort(a, mid + 1, n); merge(a, m, mid, n); }}int main() { int array[10] = {10,5,4,6,2,3,7,9,1,8}; mergeSort(array, 0, 9); for(int i = 0; i &lt; 10; i++) cout &lt;&lt; array[i] &lt;&lt; \" \";} 위 코드에서 mergeSort()함수는 재귀함수로써 배열을 절반으로 나눠가며 merge()함수를 호출하고, merge()함수에서는 요소들을 비교하며 정렬하는 정복 과정을 수행한다. mergeSort()는 분할, merge()는 정복의 역할을 한다. 피봇에 따라 성능이 다른 퀵소트와 다르게 무조건 절반으로 분할하기 때문에 모든 경우에서 O(NlogN)의 시간복잡도를 보장받는다.다만 데이터를 담을 추가적인 공간이 필요하기 때문에 메모리 측면에서 비효율적이다. algorithm average worst best space merge O(NlogN) O(NlogN) O(NlogN) O(n)","link":"/2020/03/15/20200315-algorithm-theory5/"},{"title":"힙 정렬(Heap Sort)","text":"최대 힙 트리나 최소 힙 트리를 구현해 정렬하는 방법이다. 트리 구조로 보여주는 움짤을 찾아보려 했으나 귀찮았다. n개의 노드에 대해 완전 이진 트리를 구성한다.heapify과정을 통해 부모노드의 요소가 자식노드의 요소보다 크도록 만든다.가장 첫번째 요소와 가장 마지막 요소를 swap후 다시 heapify한다. 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;int heap[10] = {10,5,4,6,2,3,7,9,1,8};int main() { for(int i = 1; i &lt; 10; i++) { int c = i; do { int root = (c - 1) / 2; if(heap[root] &lt; heap[c]) { int temp = heap[root]; heap[root] = heap[c]; heap[c] = temp; } c = root; } while(c != 0); } for(int i = 9; i &gt;= 0; i--) { int temp = heap[0]; heap[0] = heap[i]; heap[i] = temp; int root = 0; int c = 1; do { c = 2 * root + 1; if(heap[c] &lt; heap[c + 1] &amp;&amp; c &lt; i - 1) { c++; } if(heap[root] &lt; heap[c] &amp;&amp; c &lt; i) { int temp = heap[root]; heap[root] = heap[c]; heap[c] = temp; } root = c; } while(c &lt; i); } for(int i = 0; i &lt; 10; i++) cout &lt;&lt; heap[i] &lt;&lt; \" \";} 위 코드는 최대 힙 트리를 통해 정렬한다. 최대 힙 트리는 부모노드의 요소가 자식노드의 요소보다 크다. 추가적인 메모리를 필요로 하지 않으면서 모든 경우에 대해 O(NlogN)의 시간복잡도를 보장받는다.만능처럼 보이지만 실제로는 퀵소트가 더 빠르고 데이터의 상태에 따른 편차가 발생한다. 또 stable을 보장받지 못한다. heapify과정은 트리의 깊이 만큼 진행되므로 logN 만큼 수행하고 swap하는 과정을 n번 하면 정렬되므로 O(NlogN)의 시간복잡도가 나온다. algorithm average worst best space heap O(NlogN) O(NlogN) O(NlogN) O(1)","link":"/2020/03/16/20200316-algorithm-theory6/"},{"title":"[C++]스택(Stack)과 큐(Queue)","text":"스택과 큐는 선형구조로 분류되는 자료구조 중 대표적인 예시이다. 스택(Stack) push(element) : top에 원소를 추가 pop() : top에 있는 원소를 삭제 top() : top에 있는 원소를 반환 empty() : 스택이 비어있으면 true 아니면 false를 반환 size() : 스택 사이즈를 반환 큐(Queue) push(element) : 큐 뒤에 원소를 추가 pop() : 큐 앞에 있는 원소를 삭제 front() : 큐 제일 앞에 있는 원소를 반환 back() : 큐 제일 뒤에 있는 원소를 반환 empty() : 큐가 비어있으면 true 아니면 false를 반환 size() : 큐 사이즈를 반환 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;int main () { stack&lt;int&gt; s; queue&lt;int&gt; q; s.push(1); s.push(2); s.push(3); s.pop(); cout &lt;&lt; s.top() &lt;&lt; endl; cout &lt;&lt; s.size() &lt;&lt; endl; cout &lt;&lt; (s.empty() ? \"empty\" : \"!empty\") &lt;&lt; endl &lt;&lt; endl; q.push(1); q.push(2); q.push(3); q.pop(); cout &lt;&lt; q.front() &lt;&lt; endl; cout &lt;&lt; q.back() &lt;&lt; endl; cout &lt;&lt; q.size() &lt;&lt; endl; cout &lt;&lt; (q.empty() ? \"empty\" : \"!empty\") &lt;&lt; endl &lt;&lt; endl;}","link":"/2020/03/17/20200317-algorithm-theory7/"},{"title":"[C++]BOJ 1202 - 보석 도둑","text":"처음엔 무식하게 2중 for문으로 돌려보았다.맞겠지 싶었는데 시간초과가 떴다. 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; p;p b[300001];int c[300001];bool com(const pair&lt;int, int&gt;&amp; a, const pair&lt;int, int&gt;&amp; b){ if(a.first == b.first) return a.second &gt; b.second; return a.first &gt; b.first;}int main() { int n, k; cin &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt; n; i++) { cin &gt;&gt; b[i].second &gt;&gt; b[i].first; } for(int i = 0; i &lt; k; i++) { cin &gt;&gt; c[i]; } sort(b, b + n, com); sort(c, c + k); int total = 0; for(int i = 0; i &lt; k; i++) { for(int j = 0; j &lt; n; j++) { if(c[i] &gt;= b[j].second) { total += b[j].first; b[j].second = INT_MAX; break; } } } cout &lt;&lt; total;} 시간초과가 떴기 때문에 논리가 맞고 틀리고는 모르지만 맞다고 생각하기로 했다.생각해보니 n과 k가 300,000이라 가정했을 때 최악의 경우 2중 for문에서 300,000^2 번 연산하므로 제한시간 1초는 터무니없었다.구글링해보니 우선순위 큐를 사용하더라우선순위 큐를 얕게 핥아봤다.우선순위 큐는 비선형자료구조로써 넣은 순서와 상관없이 우선순위대로 나간다.max heap의 형태로 원소들이 저장되어 있다고 한다.굉장한 우연으로 이거 풀기 전에 힙 정렬을 공부하고 왔다. 위 코드를 변형해서 우선순위 큐가지고 짜봤다. 보석과 가방을 무게기준으로 오름차순 정렬한다. 가방 무게가 작은 것부터 for문을 돌며 그 가방에 들어갈 수 있는 보석을 우선순위 큐에 넣는다. 가장 큰 요소를 큐어서 빼서 total에 더한다. 반복한다. 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; p;priority_queue&lt;int&gt; pq;p b[300001];int c[300001];int main() { int n, k; cin &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt; n; i++) cin &gt;&gt; b[i].first &gt;&gt; b[i].second; for(int i = 0; i &lt; k; i++) cin &gt;&gt; c[i]; sort(b, b + n); sort(c, c + k); long long total = 0; int j = 0; for(int i = 0; i &lt; k; i++) { while(j &lt; n &amp;&amp; b[j].first &lt;= c[i]) pq.push(b[j++].second); if(!pq.empty()) { total += pq.top(); pq.pop(); } } cout &lt;&lt; total;} 맞았다.","link":"/2020/03/16/20200316-boj1202/"},{"title":"크루스칼 알고리즘(Kruskal Algorithm) (feat. Union-Find)","text":"크루스칼 알고리즘은 가장 적은 비용으로 모든 노드를 연결하여 최소비용신장트리를 만들 때 사용하는 알고리즘이다. 가장 가중치가 작은 간선부터 골라가는 그리디한 방법이며 작동과정 중 사이클이 생기지 않도록 유니온파인드를 사용해 해결한다. 사용할 그래프 가중치가 가장 작은 간선을 선택한다. 마찬가지로 가중치가 가장 작은 간선을 선택한다. 그 다음으로 작은 간선을 선택한다. 간선 AB를 선택하고 사이클이 발생하는 BD는 제외한다. 다음으로 작은 간선을 고르고 사이클이 발생하면 제외한다. 반복하면 최소 비용 신장 부분 그래프가 완성된다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int getParent(int set[], int x) { if(set[x] == x) return x; return set[x] = getParent(set, set[x]);}void unionParent(int set[], int a, int b) { a = getParent(set, a); b = getParent(set, b); if(a &lt; b) set[b] = a; else set[a] = b;}int find(int set[], int a, int b) { a = getParent(set, a); b = getParent(set, b); if(a == b) return 1; else return 0;}class Edge {public: int node[2]; int distance; Edge(int a, int b, int distance) { this-&gt;node[0] = a; this-&gt;node[1] = b; this-&gt;distance = distance; } bool operator &lt;(Edge &amp;edge) { return this-&gt;distance &lt; edge.distance; }};int main() { int n = 7; int m = 11; vector&lt;Edge&gt; v; v.push_back(Edge(1, 2, 7)); v.push_back(Edge(1, 4, 5)); v.push_back(Edge(2, 3, 8)); v.push_back(Edge(2, 4, 9)); v.push_back(Edge(2, 5, 7)); v.push_back(Edge(3, 5, 5)); v.push_back(Edge(4, 5, 15)); v.push_back(Edge(4, 6, 6)); v.push_back(Edge(5, 6, 8)); v.push_back(Edge(5, 7, 9)); v.push_back(Edge(6, 7, 11)); sort(v.begin(), v.end()); int set[n]; for(int i = 0; i &lt; n; i++) set[i] = i; int sum = 0; for(int i = 0; i &lt; v.size(); i++) { if(!find(set, v[i].node[0] - 1, v[i].node[1] - 1)) { sum += v[i].distance; unionParent(set, v[i].node[0] - 1, v[i].node[1] - 1); } } cout &lt;&lt; sum;} 위 코드에서 정점 A, B, C, D, E, F, E는 각 1, 2, 3, 4, 5, 6으로 표현했다.최소 비용 신장 트리에서 간선들의 가중치 합을 출력하는 코드다.","link":"/2020/03/23/20200323-algorithm-theory9/"},{"title":"DFS(Depth First Search)와 BFS(Breath First Search)","text":"깊이 우선 탐색(Depth First Search) 루트 노드에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법 재귀함수를 기반으로 순환 알고리즘의 형태를 지님. 너비 우선 탐색(Breath First Search) 루트 노드에서 시작해서 인접한 노드를 먼저 탐색하는 방법 재귀함수로 동작하지 않는다. 큐를 사용하여 효율적으로 구현 가능하다. 미로찾기에서도 사용된다.https://codepen.io/Owlree/details/PPomzo 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int n, m;int ans[1001][1001];int v[1001];queue&lt;int&gt; q;void dfs(int s) { cout &lt;&lt; s &lt;&lt; \" \"; v[s] = 1; for(int i = 1; i &lt;= n; i++) { if(v[i] == 1 || ans[s][i] == 0) continue; dfs(i); }}void bfs(int s) { q.push(s); v[s] = 0; while(!q.empty()) { s = q.front(); cout &lt;&lt; s &lt;&lt; \" \"; q.pop(); for(int i = 1; i &lt;= n; i++) { if(ans[s][i] == 0 || v[i] == 0) continue; q.push(i); v[i] = 0; } }}int main() { int a, b, s; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; for(int i = 0; i &lt; m; i++) { cin &gt;&gt; a &gt;&gt; b; ans[a][b] = ans[b][a] = 1; } dfs(s); cout &lt;&lt; endl; bfs(s);} 위 코드는 1260번 내 채점 소스코드를 복붙해왔다.https://www.acmicpc.net/problem/1260","link":"/2020/03/18/20200318-algorithm-theory8/"},{"title":"에라토스테네스의 체 (+ 골드바흐의 추측)","text":"자연수의 집합에서 소수를 찾아내는 방법으로 모든 수를 나눠보며 나머지를 확인하는 방법보다 빠르기 때문에 유용하게 사용된다. 소수를 구하고자 하는 구간의 모든 수를 나열한다. 2의 배수, 3의 배수, 5의 배수… 로 계속 지워나간다.위의 움짤에선 숫자가 120까지 있으니 7의 배수 까지만 지워나가면 된다.(7의 다음 소수인 11의 제곱은 121이기 때문) 1234567891011121314#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;bool p[1000001] = {1, 1};vector&lt;int&gt; prime;int main() { for(int i = 2; i * i &lt;= 1000001; i++) { if(p[i]) continue; for(int j = i * i; j &lt; 1000001; j += i) p[j] = 1; } for(int i = 0; i &lt;= 1000001; i++) if(!p[i]) prime.push_back(i);} 골드바흐의 추측은 정수론의 미해결 문제로, 2보다 큰 모든 짝수는 두개의 소수의 합으로 나타낼 수 있다는 추측이다.1742년 부터 아직까지도 증명은 안 됐지만 작은 범위의 숫자 내에선 부분적으로 증명해볼 수 있다. 1234567891011121314int ll, rr, l, r, sum, tmp;cin &gt;&gt; tmp;while(l &lt;= r) { sum = prime[l] + prime[r]; if(sum == tmp) { ll = prime[l], rr = prime[r]; l++; r--; } else if(sum &lt; tmp) { l++; } else { r--; } } 두개의 위치 인덱스를 조건이 맞을 때 까지 좁혀오며 답을 구하는 투 포인터 알고리즘을 사용하면 쉽다.","link":"/2020/03/24/20200324-algorithm-theory11/"},{"title":"[C++]BOJ 1110 - 더하기 사이클","text":"읽히는 대로 짜면 된다.신기한 점은 이 문제의 정답은 1, 3, 4, 12, 20, 60으로 6가지 밖에 없다.0부터 99까지의 숫자 중에 정답이 1인 숫자가 1개, 3인 숫자가 3개 4인 숫자가 4개, 5인 숫자가 5개, 12인 숫자가 12개, 20인 숫자가 20개, 60인 숫자가 60개다.각 정답이 같은 숫자끼리 돌아가며 등장한다. 1234567891011121314#include &lt;iostream&gt;using namespace std;int main(){ int n, i = 0 ,a, b, c; cin &gt;&gt; n; c = n; do { a = c / 10; b = c % 10; c = (b * 10) + (a + b) % 10; i++; } while(n != c); cout &lt;&lt; i;} 1 + 3 + 4 + 12 + 20 + 60 = 100","link":"/2020/03/24/20200324-boj1110/"},{"title":"유클리드 호제법(Euclidean algorithm)","text":"유클리드 호제법은 2개의 자연수 사이의 최대공약수를 구할 때 사용하는 알고리즘이다.2개의 자연수 a, b(a &gt; b)가 있고 a % b = r 이라고 한다면 a, b의 최대공약수는 a, r의 최대공약수와 같다. 이 성질을 이용해 b를 r로 나눈 나머지 r’을 구하고 다시 r을 r’으로 나눈 나머지를 구하는 과정을 반복해서 나머지가 0이 되었을 때 나누는 수가 a와 b의 최대공약수라고 한다. 최대 공약수를 구하기 위해 a, b(a &gt; b)에 대하여 2부터 b까지 모든 수를 나누는 방법이 있겠으나 수가 커지면 시간이 오래걸린다.하지만 유클리드 호제법은 mod연산을 통해 빠르게 수를 줄여나감으로 기존의 방법보다 효율적이다. wikipedia의 예시를 보자. 79696과 19332의 최대공약수를 구하는 예시다. 78696 ＝ 19332×4 ＋ 136819332 ＝ 1368×14 ＋ 180 1368 ＝ 180×7 ＋ 108 180 ＝ 108×1 ＋ 72 108 ＝ 72×1 ＋ 36 72 ＝ 36×2 ＋ 0따라서, 최대공약수는 36이다. 매우 간결하다. 123int gcd(int a, int b){ return b ? gcd(b, a % b) : a;} 재귀함수는 쓸모가 많다.","link":"/2020/03/24/20200324-etc-math1/"},{"title":"[C++]BOJ 1041 - 주사위","text":"우선 한 면이 바닥에 가려져 있으므로 총 5n^2만큼의 면을 볼 수 있다.그 중 3면이 보이는 주사위는 윗쪽 꼭지점 4개, 2면이 보이는 주사위는 눈에 보이는 모서리 8개와 아랫쪽 꼭지점 4개, 1면이 보이는 주사위는 5n^2 - (3 * 3면이 보이는 주사위의 수) - (2 * 2면이 보이는 주사위의 수) 이다.이를 식으로 나타내면, 3 면 == 4 개2 면 == 8n - 12 개1 면 == 5n^2 - 16n + 12 개 로 정리할 수 있다. 그리고 3면과 2면을 고를 때 단순히 주사위 면 중 숫자가 작은 면을 골라내면 문제가 발생하기 때문에 서로 이어진 면들을 선택해야 한다. 3면이 보이는 경우 == 마주보는 3쌍의 면들 중 각 쌍에서 작은 면을 고른다.2면이 보이는 경우 == 마주보는 면을 제외하고 모든 경우의 합(12개)을 저장하고 가장 작은 값을 이용한다. 마지막으로 주사위가 하나일 경우 예외처리를 해준다. 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;long long n, d[6], v3, v[12], v2, cnt;int main() { cin &gt;&gt; n; for(int i = 0; i &lt; 6; i++) cin &gt;&gt; d[i]; v3 = min(d[0], d[5]) + min(d[2], d[3]) + min(d[1], d[4]); for(int i = 0; i &lt; 6; i++) for(int j = i + 1; j &lt; 6; j++) { if((i==0&amp;&amp;j==5)||(i==2&amp;&amp;j==3)||(i==1&amp;&amp;j==4)) continue; v[cnt++] = d[i] + d[j]; } sort(v, v + 12); sort(d, d + 6); v2 = v[0]; if(n == 1) { cout &lt;&lt; d[0] + d[1] + d[2] + d[3] + d[4]; return 0; } cout &lt;&lt; v3 * 4 + v2 * (8 * n - 12) + d[0] * (5 * (n * n) - 16 * n + 12);}","link":"/2020/03/25/20200325-boj1041/"},{"title":"[C++]BOJ 1969 - DNA","text":"사전순이기 때문에 A, C, G, T 순으로 세로줄에 등장하는 갯수가 제일 많은 뉴클레오타이드로 배치한다.Hamming Distance는 세로줄에서 선택된 뉴클레오타이드를 제외하고 나머지 뉴클레오타이드의 등장횟수를 세면 된다. 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;int n, m, h;int main() { char c[1000][50]; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) cin &gt;&gt; c[i][j]; char ans[50]; for(int i = 0; i &lt; m; i++) { int cnt[20] = {0, }; for(int j = 0; j &lt; n; j++) cnt[c[j][i] - 'A']++; int tmp = 0, idx = 0; for(int j = 0; j &lt; 20; j++) if(tmp &lt; cnt[j]) { tmp = cnt[j]; idx = j; } h += cnt[0] + cnt[2] + cnt[6] + cnt[19]; h -= cnt[idx]; ans[i] = idx + 'A'; } for(int i = 0; i &lt; m; i++) cout &lt;&lt; ans[i]; cout &lt;&lt; endl &lt;&lt; h;}","link":"/2020/03/25/20200325-boj1969/"},{"title":"[C++]BOJ 1343 - 폴리오미노","text":"보자마자 스택이 떠올랐다.물론 스택을 사용하지는 않았다.한 글자씩 받아와서 ‘X’ 4개가 쌓일 때, ‘.’을 만날 때, 모두 읽어서 종료됐을 때의 경우에서 최종 str에 추가해주는 방식으로 풀었다.‘.’을 만났을 때와 종료됐을 때 종료조건과 2개가 쌓였을 때 “BB”를 str에 추가한다. 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int c;string str;int main() { char a; for(; scanf(\"%c\", &amp;a), a != 10;) { if(a == 'X'){ c++; } else if(a == '.') { if(c % 2) { cout &lt;&lt; \"-1\"; return 0; } else if(c == 2) { str += \"BB\"; c = 0; } str += '.'; } if(c == 4) { str += \"AAAA\"; c = 0; } } if(c % 2) { cout &lt;&lt; \"-1\"; return 0; } else if(c == 2) { str += \"BB\"; } cout &lt;&lt; str;} 다른 사람들의 풀이를 봤는데 find, replace로 쉽게 풀고 있었다.통수맞은 기분이다.","link":"/2020/03/25/20200325-boj1343/"},{"title":"[C++]BOJ 1003 - 피보나치 함수","text":"시간 제한이 0.25초로 걸려있는 것이 정직하게 피보나치 돌리면 시간 초과가 뜬다는 것을 암시한 것인가. n번째 피보나치를 구한다 생각하고 트리를 그려보면 매우 쉬워진다.예를 들어 n번째 피보나치 수열을 구하는 트리에서 n + 1번째 피보나치 수열을 구하는 트리를 그린다 가정하면, 기존의 n이 부모인 트리에서 n + 1을 부모 노드로 추가하고 n - 1의 부분 트리가 하나 더 생긴다.이것을 n + 1을 n으로 치환해서 읽어보면 n의 부모 노드에 n - 1과 n - 2의 자식 노드가 연결된 형태이다.이 생각을 중심으로 0과 1 각각 갯수를 세어주면 된다. 123456789101112#include &lt;iostream&gt;using namespace std;int f1[41] = {0, 1}, f0[41] = {1, 0}, t, n;int main() { for(int i = 2; i &lt; 41; i++) { f1[i] = f1[i - 1] + f1[i - 2]; f0[i] = f0[i - 1] + f0[i - 2]; } cin &gt;&gt; t; for(int i = 0; i &lt; t &amp;&amp; cin &gt;&gt; n; i++) cout &lt;&lt; f0[n] &lt;&lt; \" \" &lt;&lt; f1[n] &lt;&lt; endl;}","link":"/2020/03/26/20200326-boj1003/"},{"title":"[C++]BOJ 10844 - 쉬운 계단 수","text":"숫자 i 다음 으로 나올 수 있는 수는 i-1과 i+1이다.하지만 0과 9는 다음으로 나올 수 있는 수가 각각 1과 8이다.이 부분에 대해 예외처리를 하려 했으나 dp가 전역으로 정의돼있기 때문에 필요가 없었다. i번째 자릿수에 나올 수 있는 숫자 j를 2차원 배열 dp에 저장한다. 12345678910111213141516#include &lt;iostream&gt;using namespace std;const long long mod = 1e9;int n, dp[101][11];long long ans;int main() { for(int i = 1; i &lt; 10; i++) dp[1][i] = 1; cin &gt;&gt; n; for(int i = 2; i &lt;= n; i++) for(int j = 0; j &lt; 10; j++) dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j + 1]) % mod; for(int i = 0; i &lt; 10; i++) ans += dp[n][i]; cout &lt;&lt; ans % mod;}","link":"/2020/03/27/20200327-boj10844/"},{"title":"[C++]BOJ 9095 - 1, 2, 3 더하기","text":"dp[i]에는 정수 i를 1, 2, 3의 합으로 나타내는 방법의 수가 담겨있다.그래서 정수 5를 1, 2, 3의 합으로 나타내는 방법의 수가 궁금하다면, dp[2] + dp[3] + dp[4]가 될 것이다. 12345678910111213#include &lt;iostream&gt;using namespace std;int dp[12] = {0, 1, 2, 4};int main() { int n, m; cin &gt;&gt; n; for(int i = 4; i &lt; 12; i++) dp[i] = dp[i - 3] + dp[i - 2] + dp[i - 1]; for(int i = 0; i &lt; n; i++) { cin &gt;&gt; m; cout &lt;&lt; dp[m] &lt;&lt; endl; }}","link":"/2020/03/26/20200326-boj9095/"},{"title":"[C++]BOJ 1463 - 1로 만들기","text":"크게 두 가지 경우의 수가 있다. 3로 나누어 떨어질 경우 3으로 나누어 떨어질 경우 3번 조건은 언제나 적용할 수 있기 때문에 처음부터 계산하고 시작한다.2와 3의 공배수 같은 경우는 2와 3 둘 다 나누어 떨어지기 때문에 다른 조건을 만들어야 하나 싶었지만 어차피 dp[]에 저장된 값을 같은 i를 돌고 있을 때 다시 확인하므로 상관이 없다. 12345678910111213141516#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int dp[1000001];int main(){ int n; cin &gt;&gt; n; for(int i = 2; i &lt;= n; i++) { dp[i] = dp[i-1]+1; if(i % 2 == 0) dp[i] = min(dp[i/2]+1, dp[i]); if(i % 3 == 0) dp[i] = min(dp[i/3]+1, dp[i]); } cout &lt;&lt; dp[n];}","link":"/2020/03/26/20200326-boj1463/"},{"title":"[C++]BOJ 11726 - 2×n 타일링","text":"2n 크기의 직사각형은 2(n-1)크기의 직사각형에서 세로로 길쭉한 블럭 하나를 추가한 것과 같고 2(n-2)크기의 직사각형에서 가로로 길쭉한 블럭 두개를 쌓아서 추가하는 경우와 같다.2(n-2)크기의 직사각형 역시 세로로 길쭉한 블럭을 두개 추가하면 2n크기인 직사각형이 되지만, 2(n-1)와 겹치는 경우가 발생하기에 제외한다. 어째 피보나치와 같은 형태가 되었다. 1234567891011#include &lt;iostream&gt;using namespace std;int n, dp[1001] = {0, 1, 2};int main() { cin &gt;&gt; n; for(int i = 3; i &lt;= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; dp[i] %= 10007; } cout &lt;&lt; dp[n];}","link":"/2020/03/27/20200327-boj11726/"},{"title":"[C++]BOJ 1149 - RGB거리","text":"규칙이 헷갈리는데 요약하면 같은 색인 집이 연속되면 안 된다고 정리할 수 있다.따라서 색(r, g, b)별로 n번째 집까지 색을 칠하는 비용의 최소값은 n - 1번째 집까지의 비용에서 현재 집의 색을 제외한 나머지 색 중 최소값이 될 것이다. 1234567891011121314#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, r, g, b, dp[1001][3];int main() { cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; r &gt;&gt; g &gt;&gt; b; dp[i][0] = min(dp[i - 1][1], dp[i - 1][2]) + r; dp[i][1] = min(dp[i - 1][0], dp[i - 1][2]) + g; dp[i][2] = min(dp[i - 1][0], dp[i - 1][1]) + b; } cout &lt;&lt; min(min(dp[n][0], dp[n][1]), dp[n][2]);}","link":"/2020/03/27/20200327-boj1149/"},{"title":"[C++]BOJ 1912 - 연속합","text":"합이 가장 큰 연속된 부분집합을 찾는 문제로 dp[i - 1] + i번째 수와 i번째 수 중 큰 것을 dp[i]에 저장한다. dp[i - 1] + i번째 수 i번째 수 1번이 더 크다면 dp[i - 1]가 양수고, 2번이 더 크다면 dp[i - 1]가 음수다. 가장 큰 부분합이 마지막 원소를 포함하지 않는다면 마지막 위치에 저장되지 않을 수 있으므로 dp[]를 정렬해서 부분합 중 가장 큰 것을 고른다. 1234567891011#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, m, dp[100001] = {-1001, };int main() { cin &gt;&gt; n; for(int i = 1; i &lt;= n &amp;&amp; cin &gt;&gt; m; i++) dp[i] = max(dp[i - 1] + m, m); sort(dp, dp + n + 1); cout &lt;&lt; dp[n];}","link":"/2020/03/27/20200327-boj1912/"},{"title":"[C++]BOJ 1932 - 정수 삼각형","text":"삼각형 내부의 모든 지점에 dp를 수행하던 방향에 따라 그 전 층의 자신과 인접한 지점의 값 중 큰 값을 추가한다. dp를 위에서 아래로 수행하는 방법과 아래에서 위로 수행하는 경우 두 가지를 가져와봤다.결론은 아래에서 위가 더 효율적이다. 위에서 아래로 123456789101112131415161718#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, m, dp[501][501];int main() { cin &gt;&gt; n &gt;&gt; m; dp[1][1] = m; for(int i = 2; i &lt;= n; i++) { for(int j = 1; j &lt;= i; j++) { cin &gt;&gt; m; if(j == 1) dp[i][j] = dp[i - 1][j] + m; else if(j == i) dp[i][j] = dp[i - 1][j - 1] + m; else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]) + m; } } sort(dp[n] + 1, dp[n] + n + 1); cout &lt;&lt; dp[n][n];} 위에서 아래로 수행할 시 좌우 모서리 부분에 대한 예외처리가 필요하고, 또 마지막 바닥 줄에서 가장 큰 수를 찾아야 하므로 정렬이 필요했다.하지만 아래에서 위로 수행하면 위의 두가지 단점을 해결해서 코드가 더 간결하다. 아래에서 위로 12345678910111213141516#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int dp[501][501]; int n; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= i; j++) cin &gt;&gt; dp[i][j]; for(int i = n; i &gt;= 1; i--) for(int j = 1; j &lt;= i; j++) dp[i-1][j] += max(dp[i][j], dp[i][j+1]); cout &lt;&lt; dp[1][1];} 사실 처음에 생각해낸 방법이 위에서 아래로 방법이다.","link":"/2020/03/27/20200327-boj1932/"},{"title":"[C++]BOJ 2156 - 포도주 시식","text":"보자 마자 계단 오르기문제와 똑같다고 생각했지만 계단 오르기는 무조건 마지막 계단을 밟아야 하는 반면, 포도주는 꼭 마지막을 안 마셔도 된다. 그래서 계단 오르기 방법에서는 마지막을 포함하도록 한정 지었던 반면에 포도주에선 단순히 dp[i - 1]이 값도 비교하게 하므로써 전에 있던 값이 더 크다면 그 값을 뒤로 밀도록 변경했다. 그것 말곤 다른것이 없다. (사실 n의 범위가 다르다) 1234567891011121314#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, m, d[10001], dp[10001];int main() { cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; d[i]; dp[1] = d[1]; dp[2] = d[1] + d[2]; for(int i = 3; i &lt;= n; i++) dp[i] = max(max(d[i - 1] + dp[i - 3] + d[i], dp[i - 1]), dp[i - 2] + d[i]); cout &lt;&lt; dp[n];}","link":"/2020/03/27/20200327-boj2156/"},{"title":"[C++]BOJ 2579 - 계단 오르기","text":"n번째 계단 까지 얻을 수 있는 최대 점수를 구하기 위해 두 가지 경우를 살펴보겠다. n-1번째 계단을 밟고 왔을 경우 이 경우는 주어진 조건에 의해 n-2계단을 밟으면 안되므로 무조건 n-3계단을 밟고 와야 한다.따라서 n-3번째 계단 까지 얻을 수 있는 최대 점수 + n-1번 계단의 점수 + n번 계단의 점수가 n번째 계단까지 얻을 수 있는 최대 점수가 된다. n-2번째 계단을 밟고 왔을 경우 위의 상황보단 간단하다.n-2계단 전에 n-3계단을 밟고 와도 문제가 없고 n-4계단을 밟고 왔어도 조건에 어긋나지 않는다.따라서 n-2번째 계단 까지 얻을 수 있는 최대 점수 + n번 계단의 점수가 n번째 계단까지 얻을 수 있는 최대 점수가 된다. 위 두 경우 중 더 큰 값이 정답이다. 1234567891011121314#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, m, d[301], dp[301];int main() { cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; d[i]; dp[1] = d[1]; dp[2] = d[1] + d[2]; for(int i = 3; i &lt;= n; i++) dp[i] = max(d[i - 1] + dp[i - 3], dp[i - 2]) + d[i]; cout &lt;&lt; dp[n];}","link":"/2020/03/27/20200327-boj2579/"},{"title":"[C++]BOJ 2193 - 이친수","text":"가능한 경우를 부모노드가 1인 트리로 그려보면 규칙을 파악하기 쉽다. 이 문제도 어째 피보나치와 같은 형태가 되었다. 123456789#include &lt;iostream&gt;using namespace std;long long n, dp[91] = {0, 1};int main() { cin &gt;&gt; n; for(int i = 2; i &lt;= n; i++) dp[i] = dp[i - 1] + dp[i - 2]; cout &lt;&lt; dp[n];}","link":"/2020/03/27/20200327-boj2193/"},{"title":"[C++]BOJ 11052 - 카드 구매하기","text":"좀 생각 많이 한 문제다.카드 n개를 구매할 때 최대 금액은 카드 n - j개를 구매할 때의 최대 금액 + 카드 j개가 담겨있는 카드팩의 가격일 것이다.카드팩의 가격은 arr[]에 저장하고 카드 n개를 가장 비싸게 구매할 때 금액을 dp[n]에 저장한다면, 카드 n개를 가장 비싸게 구매할 때 금액은 dp[n], dp[n - 1] + arr[1], dp[n - 2] + arr[2], dp[n - 3] + arr[3]…dp[n - n] + arr[n] 중 가장 큰 값이 된다. 12345678910111213#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, arr[1001], dp[1001];int main() { cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; arr[i]; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= i; j++) dp[i] = max(dp[i], dp[i - j] + arr[j]); cout &lt;&lt; dp[n];}","link":"/2020/03/28/20200328-boj11052/"},{"title":"[C++]BOJ 9461 - 파도반 수열","text":"문제에서 주어진 그림을 보면 점화식을 세울 수 있다.i번째 삼각형의 변의 길이는 i-1번째 삼각형의 변의 길이 + i - 5번째 삼각형의 변의 길이와 같다. 12345678910#include &lt;iostream&gt;using namespace std;long long n, m, dp[101] = {0, 1, 1, 1, 2};int main() { cin &gt;&gt; n; for(int i = 5; i &lt; 101; i++) dp[i] = dp[i - 1] + dp[i - 5]; for(int i = 0; i &lt; n &amp;&amp; cin &gt;&gt; m; i++) cout &lt;&lt; dp[m] &lt;&lt; endl;}","link":"/2020/03/28/20200328-boj9461/"},{"title":"[C++]BOJ 14501 - 퇴사","text":"n이 최대 15이기 때문에 최악의 경우에도 2^15가지의 경우의 수를 가진다.따라서 완전탐색을 해도 문제가 없다.하지만 동적 계획법으로도 해결할 수 있기 때문에 두가지 방법을 다뤄보겠다. 먼저 깊이우선탐색을 이용한 방법이다. (이전 금액을 가져와 최종적으로 비교해야 하기 때문에 dfs를 사용한다.)현재 day에서 선택 할지 안 할지를 재귀적으로 호출한다.결과적으로 최종 money를 비교해 ans에 저장한다. 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int n, ans, t[16], p[16];void dfs(int day, int money) { if(day &gt; n + 1) return; if(day == n + 1) { if(ans &lt; money) ans = money; return; } dfs(day + t[day], money + p[day]); dfs(day + 1, money);}int main() { cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; t[i] &gt;&gt; p[i]; dfs(1, 0); cout &lt;&lt; ans;} 동적 계획법을 이용한 방법이다.dp[i + t]값 보다 dp[i] + p값이 크다면 dp[i + t]에 dp[i] + p를 넣는다.내일까지 벌 수 있는 최대 금액보다 오늘 벌 수 있는 최대 금액이 더 크다면 내일도 오늘만큼 벌 수 있으므로 dp[i + 1] = dp[i] 한다. 12345678910111213#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, t, p, dp[16];int main() { cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) { cin &gt;&gt; t &gt;&gt; p; dp[i + t] = max(dp[i + t], dp[i] + p); dp[i + 1] = max(dp[i + 1], dp[i]); } cout &lt;&lt; dp[n];}","link":"/2020/04/03/20200403-boj14501/"},{"title":"[C++]BOJ 9465 - 스티커","text":"동적 계획법으로 해결할 수 있다. 따라서 두 번째 사진 처럼 짧은 대각선에 있거나 세 번째 사진처럼 긴 대각선에 있는 경우만 생각해주면 된다. 위 내용을 코드로 옮기면 아래와 같다. 1234567891011121314151617#include &lt;iostream&gt;using namespace std;int t, n, dp[2][100001];int main() { cin &gt;&gt; t; while(t--) { cin &gt;&gt; n; for(int i = 0; i &lt; 2; i++) for(int j = 1; j &lt;= n; j++) cin &gt;&gt; dp[i][j]; for(int i = 2; i &lt;= n; i++) { dp[0][i] += max(dp[1][i - 1], dp[1][i - 2]); dp[1][i] += max(dp[0][i - 1], dp[0][i - 2]); } cout &lt;&lt; max(dp[0][n], max(dp[0][n - 1], max(dp[1][n], dp[1][n - 1]))) &lt;&lt; endl; }} 다른 사람 풀이를 보니 마지막에 dp[0][n]과 dp[1][n]만 비교해도 AC를 받았다.나는 위 설명에서 3번째 사진과 같은 경우 때문에 마지막 4개를 비교했으나 안해도 되는 이유를 생각해봐야겠다.","link":"/2020/04/03/20200403-boj9465/"},{"title":"[C++]BOJ 1010 - 다리 놓기","text":"보자마자 떠오른것은 조합이다.mCn을 계산하면 정답이 나오지만 m이 최대 29까지 등장하기 때문에 계산 과정에서 29!을 계산할 여지가 있다.29!은 long long에도 못들어가는 아무튼 엄청 크다.이를 해결하는 방법은 여러가지가 있다. 먼저 조합의 성질을 보자.nCr이라면 n! / {(n - r)! * r!} 이다.이 때문에 r을 n - r로 바꾸어 계산해도 정답은 일치한다.그렇다면 주어진 범위에서 계산 과정 중 분자의 크기가 가장 커지게 만드는 경우는 n이 29일 때와 r이 14또는 15일 때 이다.수식을 약분하면 계산 과정 중 등장할 가장 큰 수인 29!/15!은6,761,440,164,390,912,000이고 long long의 양수 최대범위는9,223,372,036,854,775,807이다.아슬아슬하게 걸친다.가장 큰 수가 오버플로우가 발생하지 않는다면 주어진 범위 내의 모든 수도 계산하는데 문제가 없을 것이다. 위 내용을 코드로 나타내면 아래와 같다. 12345678910111213141516#include &lt;iostream&gt;using namespace std;long long t, n, m, ans;int main() { cin &gt;&gt; t; while(t--) { ans = 1; cin &gt;&gt; n &gt;&gt; m; n = n &gt; m - n ? m - n : n; // m - n과 n중 더 작은것을 사용한다. for(int i = 0; i &lt; n; i++) ans *= m - i; for(int i = 2; i &lt;= n; i++) ans /= i; cout &lt;&lt; ans; }} 또 다른 방법은 조합 계산을 동적 계획법을 이용해 재귀함수로 구현하는 것이다.그 전에 조합 nCr = n-1Cr-1 + n-1Cr로 나타낼 수 있다는 것을 알아야 한다.(파스칼의 삼각형으로 부터 유래되었다.)로또로 예를 들어 보면 45개 중 6개를 뽑을 때의 경우의 수는 1번 공을 미리 뽑고 5개를 랜덤으로 뽑는 경우와 1번 공을 제외하고 6개를 랜덤으로 뽑는 경우를 더한 것과 같다.저 공식을 사용해 계속 쪼개나가서 n과 r이 같아지거나 r이 0이 될 때 1을 반환하면 된다. 123456789101112131415#include &lt;iostream&gt;using namespace std;int t, a, b, dp[31][31];int cbn(int n, int r) { if(n == r || r == 0) return 1; if(dp[n][r]) return dp[n][r]; return dp[n][r] = cbn(n - 1, r - 1) + cbn(n - 1, r);}int main() { cin &gt;&gt; t; while(t--) { cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; cbn(b, a) &lt;&lt; endl; }}","link":"/2020/04/04/20200404-boj1010/"},{"title":"[C++]BOJ 2293 - 동전 1","text":"dp로 접근해서 풀어야 한다.처음에 생각했던 방법은 dp[i]에 i원을 만들 수 있는 경우의 수를 저장하고, 각 dp[i]에 가지고 있는 동전의 종류(arr[j])원을 뺀 dp[i - arr[j]]를 더해주는 방법으로 풀면 되겠다고 생각했다. &lt;예제 1 입력&gt;3 10125 &lt;예제 1 출력&gt;10 막상 실행시켜보니 예제 1의 정답은 10이 나와야 하지만 내 코드는 128을 출력했다. 코드의 동작 과정을 생각해보면 오류가 보인다.1원을 만들 때의 경우의 수 = 1개 (1)2원을 만들 때의 경우의 수 = 2개 (1, 1 / 2)여기서 내 코드의 논리로는 3원을 만들 때 1원(2원짜리 동전을 가지고 있으므로 3 - 2 = 1원)과 2원(1원짜리 동전을 가지고 있으므로 3 - 1 = 2원)의 경우의 수의 합과 같아야 한다.따라서3원을 만들 때의 경우의 수 = 3개 (1, 2 / 1, 1, 1 / 2, 1)하지만 문제의 조건에서 순서만 다른 것은 같은 경우로 취급하라 했으므로 3원을 만들 때의 경우의 수에 동전의 조합이 중복되는 경우가 발생한다.그래서 실제로 3원을 만들 때의 경우의 수는 2개이다. (1, 2 / 1, 1, 1)아래 코드는 동전의 조합까지 모두 계산하는 결과를 출력한다. 123456789101112131415161718#include &lt;iostream&gt;using namespace std;int n, k, arr[101], dp[10001];int main() { cin &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt; n; i++) { cin &gt;&gt; arr[i]; dp[arr[i]] = 1; } for(int i = 1; i &lt;= k; i++) { for(int j = 1; j &lt; i; j++) { for(int a = 0; a &lt; n; a++) { if(i - j == arr[a]) dp[i] += dp[j]; } } } cout &lt;&lt; dp[k];} 물론 위의 코드는 오답처리를 받는다. 정답 처리를 받기 위해선 동전의 순서는 고려하지 않고 동전의 조합의 갯수만 출력하도록 작성해야한다. 그러기 위해 위의 예제의 경우 첫번째 동전만으로 경우의 수를 구하고, 두번째 동전까지 사용해 경우의 수를 구하고, 세번째 동전까지 사용해 경우의 수를 구하는 방법을 사용한다.이 경우는 각각 동전들이 독립적인 결과를 가지므로 중복이 발생하지 않는다.위의 코드와 대체로 유사하지만 dp[i]를 저장할 때 2중 for문에서 i와 j가 바뀐 형태다. 12345678910111213141516#include &lt;iostream&gt;using namespace std;int n, k, arr[101], dp[10001];int main() { cin &gt;&gt; n &gt;&gt; k; for(int i = 1; i &lt;= n; i++) cin &gt;&gt; arr[i]; dp[0] = 1; for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= k; j++) { if(arr[i] &gt; j) continue; dp[j] += dp[j - arr[i]]; } } cout &lt;&lt; dp[k];} 이 코드가 정답이다.","link":"/2020/04/06/20200406-boj2293/"},{"title":"[C++]BOJ 11048 - 이동하기","text":"단순한 dp문제다. 문제의 이동 조건에서 (r+1, c), (r, c+1), (r+1, c+1) 이렇게 3가지를 제시했지만, 사실 상 마지막 (r+1, c+1)은 신경쓰지 않아도 된다.왜냐하면 사탕의 갯수는 0이거나 양수이기 때문에 더 많은 사탕을 가져와야 될 판에 굳이 대각선으로 가로질러 올 필요가 없기 때문이다. dp[i][j]에 현재 칸 까지 가장 많이 가져올 수 있는 사탕의 갯수를 넣는다.마지막에 dp[n][m]을 출력한다. 123456789101112#include &lt;iostream&gt;using namespace std;int n, m, dp[1001][1001];int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) { cin &gt;&gt; dp[i][j]; dp[i][j] += max(dp[i - 1][j], dp[i][j - 1]); } cout &lt;&lt; dp[n][m];}","link":"/2020/04/07/20200407-boj11048/"},{"title":"[C++]BOJ 11055 - 가장 큰 증가 부분 수열","text":"가장 긴 증가하는 부분 수열 문제에서 dp[]에 길이를 넣었다면 지금 이 문제는 최대값을 넣으면 된다. 123456789101112131415#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, arr[1001], dp[1001];int main() { cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; arr[i]; dp[i] = arr[i]; for(int j = 1; j &lt; i; j++) if(arr[j] &lt; arr[i]) dp[i] = max(dp[j] + arr[i], dp[i]); } sort(dp, dp + n + 1); cout &lt;&lt; dp[n];}","link":"/2020/04/07/20200407-boj11055/"},{"title":"[C++]BOJ 11057 - 오르막 수","text":"각 자리수 별로 0 ~ 9까지 숫자들의 등장 가능한 빈도를 세면 된다.dp로 풀 수 있고 바로 전 자리수에 자신보다 작거나 같은 수가 얼마나 있는지를 dp[i][j]에 저장해나가면 된다. 1234567891011121314151617#include &lt;iostream&gt;using namespace std;int n, ans, dp[1001][11];int main() { cin &gt;&gt; n; for(int i = 0; i &lt; 10; i++) dp[1][i] = 1; for(int i = 2; i &lt;= n; i++) for(int j = 0; j &lt; 10; j++) for(int k = j; k &lt; 10; k++) { dp[i][j] += dp[i - 1][k]; dp[i][j] %= 10007; } for(int i = 0; i &lt; 10; i++) ans += dp[n][i]; cout &lt;&lt; ans % 10007;}","link":"/2020/04/07/20200407-boj11057/"},{"title":"[C++]BOJ 2167 - 2차원 배열의 합","text":"그리디로 풀었을 때 최악의 경우 n * m * k번, 300 * 300 * 10,000 = 900,000,000번 계산하므로 시간초과가 난다.그래서 dp로 풀어야 한다. 할 줄 알았는데 그리디하게 풀어도 맞는다고 한다. 어쨌든 dp[i][j]에는 (0, 0)부터 (i, j)까지의 숫자 합을 저장한다. dp[][]를 채워나가는 방법 주어진 영역의 합을 구하는 방법 위 과정을 코드로 작성하면 아래와 같다. 1234567891011121314151617#include &lt;iostream&gt;using namespace std;int n, m, ans, i, j, x, y, dp[301][301];int main() { cin &gt;&gt; n &gt;&gt; m; for(i = 1; i &lt;= n; i++) for(j = 1; j &lt;= m; j++) { cin &gt;&gt; dp[i][j]; dp[i][j] += dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]; } cin &gt;&gt; n; for(int k = 0; k &lt; n; k++) { cin &gt;&gt; i &gt;&gt; j &gt;&gt; x &gt;&gt; y; ans = dp[x][y] - dp[x][j - 1] - dp[i - 1][y] + dp[i - 1][j - 1]; cout &lt;&lt; ans &lt;&lt; endl; }}","link":"/2020/04/07/20200407-boj2167/"},{"title":"[C++]BOJ 1699 - 제곱수의 합","text":"만약 i라는 숫자보다 j * j만큼 작은 수 인 i - j * j는 숫자 i의 제곱수의 최소항 갯수 - 1을 가질 것이다.만약 j * j가 i와 같다면 j * j = i이므로 제곱수의 최소항 갯수가 한개가 된다.이 과정을 j * j가 i보다 작거나 같을 때까지 반복해 가장 작은 값을 dp[i]에 넣고 i가 n만큼 돌면 dp[n]이 답이 된다. 12345678910111213#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, dp[100001];int main() { cin &gt;&gt; n; for(int i = 0; i &lt;= n; i++) dp[i] = i; for(int i = 2; i &lt;= n; i++) for(int j = 2; j * j &lt;= i; j++) dp[i] = min(dp[i - j * j] + 1, dp[i]); cout &lt;&lt; dp[n];} 구글링 하다가 동적 계획법 말고 다른 방법을 사용한 다른 풀이를 발견해서 첨부한다.라그랑주의 네 제곱수 정리에 의하여 모든 양의 정수는 최대 4개의 제곱수의 합으로 나타낼 수 있기 때문에 3개의 제곱수의 합으로 못찾아내면 4개라는 점을 이용한 반쪽짜리 완전탐색 코드다.3중 for문이라 되게 오래 걸릴 것 같지만 제곱근 n에 대하여 매우 빠르게 수가 불어나서 생각보다 빠르다.오히려 dp보다 빠를 수도 있다. 123456789101112131415#include &lt;iostream&gt;using namespace std;int n, ans = 4;int main() { cin &gt;&gt; n; for(int a = 1; a * a &lt;= n; a++) { if(a * a == n) ans = min(ans, 1); for(int b = 1; a * a + b * b &lt;= n; b++) { if(a * a + b * b == n) ans = min(ans, 2); for(int c = 1; a * a + b * b + c * c &lt;= n; c++) if(a * a + b * b + c * c == n) ans = min(ans, 3); } } cout &lt;&lt; ans;} 채첨 안해봐서 정답 처리 받을 수 있는지 모른다.근데 잘 나온다.","link":"/2020/04/07/20200407-boj1699/"},{"title":"[C++]BOJ 2294 - 동전 2","text":"처음 생각했던 방법은 dp[i]에 i원을 만들기 위한 동전의 최소 갯수를 저장하는 방식으로 현재 i보다 작은 j원을 순차로 돌며 i - j원 짜리 동전이 있나 확인한 후, dp[i]에는 그 중 가장 작은 값을 넣도록 작성했다. 실제로 돌려보니 시간초과를 받았다.최악의 경우에서 i * j * n == 10,000 * 10,000 * 100 == 백 억 번을 반복하기 때문이다. 12345678910111213141516#include &lt;iostream&gt;using namespace std;int n, k, arr[101], dp[10001], ans;int main() { cin &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt; n; i++) cin &gt;&gt; arr[i]; for(int i = 1; i &lt;= k; i++) { dp[i] = 99999; for(int j = 0; j &lt; i; j++) for(int l = n - 1; l &gt;= 0; l--) if(i - j == arr[l]) dp[i] = min(dp[i], dp[j] + 1); } ans = (dp[k] == 99999) ? -1 : dp[k]; cout &lt;&lt; ans;} 위의 코드는 시간초과가 발생한다. 이 문제를 해결하기 위해 동전 1 문제 처럼 첫 번째 동전만 사용 했을 때의 최소값과 두 번째 동전까지 사용 했을 때의 최소값과 … 이런식으로 마지막 동전까지 모두 사용했을 때의 최소값을 구하면 dp[k]에 k원을 만들 때 필요한 동전의 최소 갯수가 들어간다. 123456789101112131415#include &lt;iostream&gt;using namespace std;int n, k, arr[101], dp[10001], ans;int main() { cin &gt;&gt; n &gt;&gt; k; for(int i = 1; i &lt;= k; i++) dp[i] = 99999; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; arr[i]; for(int j = arr[i]; j &lt;= k; j++) dp[j] = min(dp[j], dp[j - arr[i]] + 1); } ans = (dp[k] == 99999) ? -1 : dp[k]; cout &lt;&lt; ans;} 99999는 10000보다 크기 때문에 절대 나올 수 없다.","link":"/2020/04/08/20200408-boj2294/"},{"title":"파이썬 문법 사전 - if, for, 함수","text":"if문 if 후에 여러개의 elif가 있을 수 있고 else는 선택적으로 사용할 수 있다. 12345678910111213&gt;&gt;&gt; x = int(input(\"Please enter an integer: \"))Please enter an integer: 42&gt;&gt;&gt; if x &lt; 0:... x = 0... print('Negative changed to zero')... elif x == 0:... print('Zero')... elif x == 1:... print('Single')... else:... print('More')...More for문 파이썬에서 for문은 임의의 시퀀스(리스트나 문자열)의 항목들을 순서대로 이터레이션 할 수 있다. 12345678&gt;&gt;&gt; # Measure some strings:... words = ['cat', 'window', 'defenestrate']&gt;&gt;&gt; for w in words:... print(w, len(w))...cat 3window 6defenestrate 12 시퀀스를 이터레이트 하는 동안 시퀀스를 수정하는 것은 원래의 의도대로 동작하지 않을 수도 있다.이 경우 보통 복사본을 만드는 방법을 사용한다. 12345678910# Strategy: Iterate over a copyfor user, status in users.copy().items(): if status == 'inactive': del users[user]# Strategy: Create a new collectionactive_users = {}for user, status in users.items(): if status == 'active': active_users[user] = status range() 함수 숫자들의 시퀀스로 이터레이트 해야 할 때 range()를 사용하면 편리하다. range()는 수열을 만든다. 123456789&gt;&gt;&gt; a = ['Mary', 'had', 'a', 'little', 'lamb']&gt;&gt;&gt; for i in range(len(a)):... print(i, a[i])...0 Mary1 had2 a3 little4 lamb 주의해야 할 점은 range()는 리스트 처럼 동작하지만 리스트가 아니라는 점이다. 12&gt;&gt;&gt; print(range(10))range(0, 10) 이처럼 리스트를 출력하지 않는다.이터레이트할 때 원하는 시퀀스 항목들을 순서대로 돌려주는 객체이지만, 실제로 리스트를 만들지 않아서 공간을 절약한다. 1234&gt;&gt;&gt; sum(range(4)) # 0 + 1 + 2 + 36&gt;&gt;&gt; list(range(4))[0, 1, 2, 3] 이런것도 가능하다. break, continue, for-else문 break문은 가장 가까이 둘러싸는 반복문을 빠져나가게 만든다. 특이하게 파이썬에서 루프문은 else를 가질 수 있다.루프가 이터러블 소진이나 조건이 거짓이 돼서 종료할 때 실행된다. 단, 루프가 break문으로 종료될 때는 실행되지 않는다. 1234567891011121314151617&gt;&gt;&gt; for n in range(2, 10):... for x in range(2, n):... if n % x == 0:... print(n, 'equals', x, '*', n//x)... break... else:... # loop fell through without finding a factor... print(n, 'is a prime number')...2 is a prime number3 is a prime number4 equals 2 * 25 is a prime number6 equals 2 * 37 is a prime number8 equals 2 * 49 equals 3 * 3 continue는 루프의 다음 이터레이션에서 계속 실행하도록 만든다. 12345678910111213&gt;&gt;&gt; for num in range(2, 10):... if num % 2 == 0:... print(\"Found an even number\", num)... continue... print(\"Found a number\", num)Found an even number 2Found a number 3Found an even number 4Found a number 5Found an even number 6Found a number 7Found an even number 8Found a number 9 pass문 아무것도 하지 않는다.문법적으로 문장이 필요하지만 특별히 할 일이 없을 때 사용한다.ex) 최소한의 클래스를 만들 때 함수 정의 def를 이용해서 함수를 정의한다.함수 이름과 괄호로 싸인 매개변수들의 목록이 뒤따른다.함수 내부 문장들은 반드시 들여쓰기 해야 한다.“””독스트링””” 은 함수 바디의 첫번째 문장으로 사용해 함수에 대한 설명으로 사용할 수 있다. 1234567891011&gt;&gt;&gt; def fib(n): # write Fibonacci series up to n... \"\"\"Print a Fibonacci series up to n.\"\"\"... a, b = 0, 1... while a &lt; n:... print(a, end=' ')... a, b = b, a+b... print()...&gt;&gt;&gt; # Now call the function we just defined:... fib(2000)0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 기본 인자 값하나 이상의 인자들에 기본값을 지정하여 정의된 것보다 더 적은 개수의 인자들로 호출될 수 있는 함수를 만든다. 1234567891011def ask_ok(prompt, retries=4, reminder='Please try again!'): while True: ok = input(prompt) if ok in ('y', 'ye', 'yes'): return True if ok in ('n', 'no', 'nop', 'nope'): return False retries = retries - 1 if retries &lt; 0: raise ValueError('invalid user response') print(reminder) Referencepython.org 이 게시물은 파이썬 문법을 까먹었을 때 검색하려고 작성됨.","link":"/2020/04/13/20200413-python2/"},{"title":"파이썬 문법 사전 - 숫자, 문자열, 리스트","text":"숫자 +, -, *, / 같이 사칙연산 연산자를 사용할 수 있다.괄호는 연산의 우선순위를 정할 때 사용한다. 12345678&gt;&gt;&gt; 2 + 24&gt;&gt;&gt; 50 - 5*620&gt;&gt;&gt; (50 - 5*6) / 45.0&gt;&gt;&gt; 8 / 5 # division always returns a floating point number1.6 나눗셈은 항상 float을 리턴한다.정수 나눗셈으로 정수 결과를 얻으려면 // 을 사용하면 된다.나머지 연산에서는 %을 사용한다. 123456789&gt;&gt;&gt; 17 / 3 # classic division returns a float5.666666666666667&gt;&gt;&gt;&gt;&gt;&gt; 17 // 3 # floor division discards the fractional part5&gt;&gt;&gt; 17 % 3 # the % operator returns the remainder of the division2&gt;&gt;&gt; 5 * 3 + 2 # result * divisor + remainder17 거듭제곱은 **을 사용한다. 1234&gt;&gt;&gt; 5 ** 2 # 5 squared25&gt;&gt;&gt; 2 ** 7 # 2 to the power of 7128 변수를 값에 대입할 때는 등호 =를 사용한다. 문자열 파이썬에서 문자열은 ‘작은따옴표’나 “큰따옴표”로 둘러쌀 수 있고 둘다 같은 결과를 가져온다.따옴표를 이스케이핑 하는 방법은 \\를 사용하면 된다. 123456789101112&gt;&gt;&gt; 'spam eggs' # single quotes'spam eggs'&gt;&gt;&gt; 'doesn\\'t' # use \\' to escape the single quote...\"doesn't\"&gt;&gt;&gt; \"doesn't\" # ...or use double quotes instead\"doesn't\"&gt;&gt;&gt; '\"Yes,\" they said.''\"Yes,\" they said.'&gt;&gt;&gt; \"\\\"Yes,\\\" they said.\"'\"Yes,\" they said.'&gt;&gt;&gt; '\"Isn\\'t,\" they said.''\"Isn\\'t,\" they said.' print()를 사용할 때 \\뒤의 문자가 특수문자로 취급되게 하고 싶지 않다면, 첫 따옴표 앞에 r을 붙여서 raw string을 만들 수 있다. 12345&gt;&gt;&gt; print('C:\\some\\name') # here \\n means newline!C:\\someame&gt;&gt;&gt; print(r'C:\\some\\name') # note the r before the quoteC:\\some\\name 삼중따옴표 “””, ‘’’를 통해 줄넘김 문자를 자동으로 문자열에 포함 할 수도 있다. 줄 끝에 \\를 붙여 이를 무시할 수도 있다.또 연산자를 이어 붙이기도 가능하다. 12345678910111213&gt;&gt;&gt; print(\"\"\"\\ Usage: thingy [OPTIONS] -h Display this usage message -H hostname Hostname to connect to \"\"\") Usage: thingy [OPTIONS] -h Display this usage message -H hostname &gt;&gt;&gt; # 3 times 'un', followed by 'ium'&gt;&gt;&gt; 3 * 'un' + 'ium''unununium'&gt;&gt;&gt; 'Py' 'thon''Python' 문자열은 인덱스 될 수 있다. 첫 번째 문자가 인덱스 0에 대응된다. 인덱스는 음수가 될 수도 있다. 123456789101112&gt;&gt;&gt; word = 'Python'&gt;&gt;&gt; word[0] # character in position 0'P'&gt;&gt;&gt; word[5] # character in position 5'n'&gt;&gt;&gt; word[-1] # last character'n'&gt;&gt;&gt; word[-2] # second-last character'o'&gt;&gt;&gt; word[-6]'P' 슬라이싱도 지원한다. 12345678910111213141516&gt;&gt;&gt; word[0:2] # characters from position 0 (included) to 2 (excluded)'Py'&gt;&gt;&gt; word[2:5] # characters from position 2 (included) to 5 (excluded)'tho'&gt;&gt;&gt; word[:2] + word[2:]'Python'&gt;&gt;&gt; word[:4] + word[4:]'Python'&gt;&gt;&gt; word[:2] # character from the beginning to position 2 (excluded)'Py'&gt;&gt;&gt; word[4:] # characters from position 4 (included) to the end'on'&gt;&gt;&gt; word[-2:] # characters from the second-last (included) to the end'on' 이렇게 보면 이해하기 쉽다. 12345+---+---+---+---+---+---+| P | y | t | h | o | n |+---+---+---+---+---+---+0 1 2 3 4 5 6-6 -5 -4 -3 -2 -1 범위 밖의 값을 인덱스로 사용하면 오류가 나지만 슬라이싱을 할 때는 부드럽게 처리된다. 파이썬의 문자열은 변경할 수 없다. 그래서 특정 인덱스의 값을 바꾸려 할 때는 에러가 난다. 만약 꼭 바꿔야한다면 새 문자열을 만들어야 한다. 내장함수 len()은 문자열의 길이를 반환한다. 123&gt;&gt;&gt; s = 'supercalifragilisticexpialidocious'&gt;&gt;&gt; len(s)34 리스트 대괄호 사이에 쉼표로 구분된 항목들의 목록으로 표현된다.리스트는 서로 다른 자료형의 항목을 포함할 수 있다. 123&gt;&gt;&gt; squares = [1, 4, 9, 16, 25]&gt;&gt;&gt; squares[1, 4, 9, 16, 25] 문자열과 마찬가지로 슬라이싱 가능하다. 123456&gt;&gt;&gt; squares[0] # indexing returns the item1&gt;&gt;&gt; squares[-1]25&gt;&gt;&gt; squares[-3:] # slicing returns a new list[9, 16, 25] 리스트는 이어붙이기 가능하다. 12&gt;&gt;&gt; squares + [36, 49, 64, 81, 100][1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 문자열과 다르게 리스트는 내용을 변경할 수 있다. 1234&gt;&gt;&gt; cubes = [1, 8, 27, 65, 125] # something's wrong here&gt;&gt;&gt; cubes[3] = 64 # replace the wrong value&gt;&gt;&gt; cubes[1, 8, 27, 64, 125] append() 메서드를 사용하면 리스트의 끝에 새 항목을 추가할 수 있다. 1234&gt;&gt;&gt; cubes.append(216) # add the cube of 6&gt;&gt;&gt; cubes.append(7 ** 3) # and the cube of 7&gt;&gt;&gt; cubes[1, 8, 27, 64, 125, 216, 343] 슬라이싱 후 대입이 가능하기 때문에 길이변경과 항목삭제도 가능하다. 123456789101112131415&gt;&gt;&gt; letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']&gt;&gt;&gt; letters['a', 'b', 'c', 'd', 'e', 'f', 'g']&gt;&gt;&gt; # replace some values&gt;&gt;&gt; letters[2:5] = ['C', 'D', 'E']&gt;&gt;&gt; letters['a', 'b', 'C', 'D', 'E', 'f', 'g']&gt;&gt;&gt; # now remove them&gt;&gt;&gt; letters[2:5] = []&gt;&gt;&gt; letters['a', 'b', 'f', 'g']&gt;&gt;&gt; # clear the list by replacing all the elements with an empty list&gt;&gt;&gt; letters[:] = []&gt;&gt;&gt; letters[] len()를 통해 길이를 가져올 수 있다. Referencepython.org 이 게시물은 파이썬 문법을 까먹었을 때 검색하려고 작성됨.","link":"/2020/04/12/20200412-python1/"},{"title":"파이썬 - 네이버 영화 크롤링","text":"네이버 영화 페이지에서 현재 상영중인 영화와 정보들을 가져오고 각 영화에 달린 댓글들도 가져오는 파이썬 크롤러를 만들어 봤다.모듈은 requests와 beautifulsoup4를 사용했다.requests로 HTTP요청을 보내고 beautifulsoup4는 html구문을 분석할 때 사용했다.마지막으로 크롤링이 끝난 후 csv형식으로 내보낸다. 내용 추가 예정 크롤링 결과 csv파일 이 링크를 통해 repl.it에서 가상으로 테스트 할 수 있다. 소스코드 ####2020년 4월 21일너무 허전해보여서 flask로 웹에서 돌아가게 만들어 보았다. 역시나 repl.it의 서버를 사용하기 때문에 크롤링 속도가 굉장히 느리다.page 값으로 0을 넣으면 빠른 결과를 얻을 수 있다.대신 댓글은 가져오지 못한다.","link":"/2020/04/15/20200415-python-movie-crawling/"}],"tags":[{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"theory","slug":"theory","link":"/tags/theory/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"LIS","slug":"LIS","link":"/tags/LIS/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"BOJ","slug":"BOJ","link":"/tags/BOJ/"},{"name":"greedy","slug":"greedy","link":"/tags/greedy/"},{"name":"브루트 포스","slug":"브루트-포스","link":"/tags/%EB%B8%8C%EB%A3%A8%ED%8A%B8-%ED%8F%AC%EC%8A%A4/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"jquery","slug":"jquery","link":"/tags/jquery/"},{"name":"chrome extension","slug":"chrome-extension","link":"/tags/chrome-extension/"},{"name":"study","slug":"study","link":"/tags/study/"},{"name":"project","slug":"project","link":"/tags/project/"},{"name":"sort","slug":"sort","link":"/tags/sort/"},{"name":"heap","slug":"heap","link":"/tags/heap/"},{"name":"Data Structure","slug":"Data-Structure","link":"/tags/Data-Structure/"},{"name":"크루스칼","slug":"크루스칼","link":"/tags/%ED%81%AC%EB%A3%A8%EC%8A%A4%EC%B9%BC/"},{"name":"bfs","slug":"bfs","link":"/tags/bfs/"},{"name":"dfs","slug":"dfs","link":"/tags/dfs/"},{"name":"search","slug":"search","link":"/tags/search/"},{"name":"소수","slug":"소수","link":"/tags/%EC%86%8C%EC%88%98/"},{"name":"gcd","slug":"gcd","link":"/tags/gcd/"},{"name":"math","slug":"math","link":"/tags/math/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"language","slug":"language","link":"/tags/language/"},{"name":"crawling","slug":"crawling","link":"/tags/crawling/"}],"categories":[{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","link":"/categories/algorithm/BOJ/"},{"name":"theory","slug":"algorithm/theory","link":"/categories/algorithm/theory/"},{"name":"etc","slug":"etc","link":"/categories/etc/"},{"name":"project","slug":"etc/project","link":"/categories/etc/project/"},{"name":"math","slug":"etc/math","link":"/categories/etc/math/"},{"name":"language","slug":"language","link":"/categories/language/"},{"name":"python","slug":"language/python","link":"/categories/language/python/"}]}
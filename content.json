{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"[C++]BOJ 11399 - ATM","text":"앞사람의 인출 시간이 적을 때 전체 인출 시간이 적어진다. 1234567891011121314151617#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int time[1001]; int a; cin &gt;&gt; a; for(int i = 0; i &lt; a; i++) cin &gt;&gt; time[i]; sort(time, time + a); long long b = 0; for(int i = 0; i &lt; a; i++) for(int j = 0; j &lt; i + 1; j++) b += time[j]; cout &lt;&lt; b;}","link":"/2019/10/24/20191024-boj11399/"},{"title":"[C++]BOJ 11047 - 동전0","text":"동전금액이 큰 단위부터 나눠가면 된다. 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;int main(){ int n, k; cin &gt;&gt; n &gt;&gt; k; int v[11]; for(int i = 0; i &lt; n; i++) { cin &gt;&gt; v[i]; } int g = 0; int j = n - 1; while(1) { if(k == 0) { break; } if(v[j] &lt;= k) { g += k / v[j]; k = k % v[j]; } j--; } cout &lt;&lt; g;}","link":"/2019/10/24/20191024-boj11047/"},{"title":"[C++]BOJ 1931 - 회의실배정","text":"회의가 끝나는 시간이 빠른 회의 순으로 정렬 후 이전 회의의 끝나는 시간과 현재 회의가 시작하는 시간의 조건을 만족시키면 회의 수를 +1 한다. 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; p;int main(){ int a; cin &gt;&gt; a; p b[100001]; for(int i = 0; i &lt; a; i++) { cin &gt;&gt; b[i].second &gt;&gt; b[i].first; } sort(b, b+a); int c = 1; int l = b[0].first; for(int i = 1; i &lt; a; i++) { if(b[i].second &gt;= l) { l = b[i].first; c++; } } cout &lt;&lt; c;} 이 문제 풀다가 pair를 발견했다. 쓸모가 많을 듯 하다.pair를 sort시키면 first기준으로 정렬한다는 점.","link":"/2019/10/24/20191024-boj1931/"},{"title":"[C++]BOJ 5585 - 거스름돈","text":"동전 내는 문제에서 거스름돈으로 바뀐 문제. 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int main(){ short a; cin &gt;&gt; a; a = 1000 - a; int b = 0; b += a / 500; a = a % 500; b += a / 100; a = a % 100; b += a / 50; a = a % 50; b += a / 10; a = a % 10; b += a / 5; a = a % 5; b += a / 1; a = a % 1; cout &lt;&lt; b;}","link":"/2019/10/24/20191024-boj5585/"},{"title":"[C++]BOJ 2217 - 로프","text":"다음 로프의 길이가 현재 로프의 길이보다 항상 크거나 같다고 가정했을 때, {앞으로 남은 로프의 수 + 1(자기 자신)} * 자신의 길이가 다음 로프에서 같은 연산을 수행했을 때 보다 작다면 다음 로프의 길이 * (앞으로 남은 로프의 수 + 1)가 최대로 견딜 수 있는 하중이 된다. 이를 반복문 돌리면 풀린다. +정렬까지 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int n; cin &gt;&gt; n; short a[100001]; for(int i = 0; i &lt; n ; i++) { cin &gt;&gt; a[i]; } sort(a, a+n); int k = 0; for(int i = 0; i &lt; n; i++) { if(k &lt; a[i] * (n - i)) { k = a[i] * (n - i); } } cout &lt;&lt; k; }","link":"/2019/10/24/20191024-boj2217/"},{"title":"[C++]BOJ 10610 - 30","text":"어떤 수가 3의 배수인지 확인하는 방법은 각 자릿수를 모두 더한 값이 3의 배수여야 한다. 이는 간단한 방법으로 증명할 수 있다. 10^n자릿수가 9일 때 3을 더하면 10^n의 자리에서 7만큼을 손해 보고 10^n+1의 자리에서 1의 이득을 본다. -7+1(역시나 3의 배수) 결국엔 계속 3의 배수가 되는데 생각해보니 정렬된 거나 안된 거나 같이 위의 조건을 만족한다면 그냥 모듈러 연산으로 해도 된다는 생각이 들었다. 어쨌든 30의 배수가 되려면 위의 조건에서 0이 문자열에 포함되어 있는지 확인해 봐야 한다. 조건을 모두 만족한 후 내림차순 정렬하면 풀린다. 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(char a, char b){ return a &gt; b;}int main(){ string n; cin &gt;&gt; n; long long s = 0; bool z = false; for(int i = 0; i &lt; n.size(); i++) { s += (n[i] - '0'); if(!(n[i] - '0')) z = true; } if(!z || s % 3) cout &lt;&lt; -1 &lt;&lt; endl; else { sort(n.begin(), n.end(), cmp); cout &lt;&lt; n &lt;&lt; endl; }}","link":"/2019/10/24/20191024-boj10610/"},{"title":"[C++]BOJ 2875 - 대회 or 인턴","text":"엄청 간단한 문제였는데 방심했다가 틀렸다. 여자 수 / 2 남자 수 여자 수 + 남자 수 - 인턴 수 3개 중에 가장 작은 값이 답이다. 가장 작은 값을 제외하곤 서로의 반례가 되기 때문. 12345678#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; cout &lt;&lt; min(min(n/2, m), (n+m-k)/3) &lt;&lt; endl;}","link":"/2019/10/24/20191024-boj2875/"},{"title":"[C++]BOJ 1120 - 문자열","text":"단순 그리디. B 안에서의 차이가 가장 적은 A를 구하면 그게 답이다. 추가하는 연산은 무조건 차이가 가장 적게 할 테니까 신경 쓰지 않는다. 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int main(){ char a[50], b[50]; cin &gt;&gt; a &gt;&gt; b; int al = sprintf(a, \"%s\", a); int bl = sprintf(b, \"%s\", b); int c = 51; for(int i = 0; i &lt; bl - al + 1; i++) { int co = 0; for(int j = 0; j &lt; al; j++) { if(b[j+i] != a[j]) co++; } if(co &lt; c) c = co; } cout &lt;&lt; c;} 지금보면 좀 한심한 코드다. 배열 길이 구하겠다고 sprintf를 썼다. 시간나면 수정해서 다시 올리자. 불편해서 바로 해버렸다. 12345678910111213141516#include &lt;iostream&gt;using namespace std;int main(){ string a, b; cin &gt;&gt; a &gt;&gt; b; int c = 51; for(int i = 0; i &lt; b.size() - a.size() + 1; i++) { int co = 0; for(int j = 0; j &lt; a.size(); j++) if(b[j+i] != a[j]) co++; if(co &lt; c) c = co; } cout &lt;&lt; c;}","link":"/2019/10/24/20191024-boj1120/"},{"title":"[C++]BOJ 1541 - 잃어버린 괄호","text":"가장 작은 답이 나오려면 +끼리 괄호로 묶고 계산하면 된다. 라고 생각했지만 계속 반례가 생각나서 이건 아닐 거라고 판단했고 그냥 첫 번째 -가 나온 순간부터 다 빼버리면 처음 생각했던 것보다 단순하게 끝난다. +아스키코드 10은 line feed (다음 줄) 1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main(){ bool ch = false; int a, b; char c; scanf(\"%d\", &amp;a); for(;scanf(\"%c\", &amp;c), c != 10;) { if(c == '-') ch = true; scanf(\"%d\", &amp;b); if(ch) a -= b; else a += b; } cout &lt;&lt; a;} cin으로 받아보려 했으나 작동이 안 돼서 scanf로 받았다. 자료형을 정확히 명시해줘야 하는 것 같다. 추가로 for 문에 대해 새로 알게 된 점. for(시작할 때 한 번만 실행; 조건문 말고도 scanf 같은 거 사용 가능, 한번 돌 때마다 조건문 확인해서 매번 실행되는 듯; 증감식, 여기도 매번 실행) 더 찾아봐야 알겠지만 이런 느낌인 듯. ​ 이렇게도 될까? 12345678910111213141516#include &lt;iostream&gt;using namespace std;int main(){ bool ch = false; int a, b; char c; for(scanf(\"%d\", &amp;a); scanf(\"%c\", &amp;c), c != 10;) { if(c == '-') ch = true; scanf(\"%d\", &amp;b); if(ch) a -= b; else a += b; } cout &lt;&lt; a;} 된다. 2바이트 줄였다.","link":"/2019/10/25/20191025-boj1541/"},{"title":"알고리즘 공부 시작","text":"목표 알고리즘 공부 시험 기간이라도 백준 하루 한 문제 이상은 꼭 풀도록 노력 ​ 공부할 알고리즘 그리디 알고리즘 다이나믹 프로그래밍 bfs, dfs 다익스트라 알고리즘 브루트 포스 플로이드 와샬 알고리즘 ​ 10월 24일 현재 solved.ac기준 20191013에 그리디 알고리즘 시작함. 13일 - 8문제 14일 - 3문제 15일 - 1문제 16일 - 2문제 17일 - 2문제 18일 - 1문제 19일 - 1문제 20일 - 1문제(교양 중간 전날) 21일부터 전공시험 전날이라 못함. 22일 - 전날 밤새서 잤음 23일 - 1문제 24일 - 2문제 앞으로 푼 문제들은 전부 블로그에 정리해서 적을 예정. 이전까지의 문제들은 기억 되짚어서 천천히 게시 예정. 마무리 목표 구체화가 필요하다 느낌. 예전 코드 보니까 뭔 생각으로 저리 짰는지 기억이 안 나서 적을 공간이 필요했음. 13일 시작일 기준 알고리즘에 대해 무지한 생태. c++ 기본 문법 정도만 알고 있었음.","link":"/2019/10/24/20191024-A_BOJstart/"},{"title":"[C++]BOJ 1946 - 신입 사원","text":"문제에 헷갈리는 문장이 있었다. “다른 모든 지원자와 비교했을 때 서류심사 성적과 면접시험 성적 중 적어도 하나가 다른 지원자보다 떨어지지 않는 자만 선발한다는 원칙을 세웠다.” ??????????? 한참을 보다가 다음 줄 보고 이해했다. “즉, 어떤 지원자 A의 성적이 다른 어떤 지원자 B의 성적에 비해 서류 심사 결과와 면접 성적이 모두 떨어진다면 A는 결코 선발되지 않는다.” ㅇㅎ 이전에 회의실 배정인가 거기서 썼던 pair를 쓰면 편하겠단 생각이 들었다. first는 어차피 오름차순으로 정렬되니 다음 사람의 점수보다 무조건 낮을 것이고 그 와중에 second까지 작으면 조건에 의해 걔는 탈락이다. 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; p;int tk[21];int main(){ p v[100001]; short t; int n; cin &gt;&gt; t; for(int i = 0; i &lt; t; i++) { cin &gt;&gt; n; for(int j = 0; j &lt; n; j++) { cin &gt;&gt; v[j].first &gt;&gt; v[j].second; } sort(v, v+n); int po = v[0].second; int p = n; for(int j = 0; j &lt; n; j++) { if(po &lt; v[j].second) p--; else po = v[j].second; } tk[i] = p; } for(int i = 0; i &lt; t; i++) cout &lt;&lt; tk[i] &lt;&lt; endl;} 왜 배열명을 tk로 썼는지 기억이 가물가물한데 아마 테스트 케이스를 줄여서 tk라 한듯하다. 근데 놀랍게도 test case를 굳이 줄인다면 tc이다. 졸았나보다.","link":"/2019/10/25/20191025-boj1946/"},{"title":"[C++]BOJ 1046 - 기타줄","text":"딴 거 다 필요 없고 가장 싼 패키지와 낱개 가격만 있으면 된다. 그걸 구하기 위해 나는 정렬을 사용한 모양이다. 굳이 그랬어야 할까. 아무튼 경우의 수는 3가지다. 패키지로 살 수 있을 만큼 산 후 나머지 부족한 것을 낱개로 구입. 전부 낱개로 구입. 기타줄 몇 개 남더라도 싹 다 패키지로 구입. 3개 중 가장 작은 게 답이다. 123456789101112131415161718include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int n, m; short pa[50], na[50]; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; m; i++) cin &gt;&gt; pa[i] &gt;&gt; na[i]; sort(pa, pa+m); sort(na, na+m); int d1 = pa[0] * (n / 6) + na[0] * (n % 6); int d2 = na[0] * n; int d3 = pa[0] * ((n / 6) + 1); int v = min(min(d1, d2), d3); cout &lt;&lt; v; } 정렬은 아무리 봐도 불편하다.나중에 수정하자.","link":"/2019/10/25/20191025-boj1046/"},{"title":"[C++]BOJ 2529 - 부등호","text":"가장 큰 수를 구할 때 앞자리에 9를 넣고 시작한다. 다음 부등호가 “&lt;” 라면 부등호 다음 수를 9로 만들고 그전의 자리에는 -1을 해준다. “&gt;” 라면 사용 안 했던 수 중에 가장 큰 수를 넣는다.이런 방식으로 부등호 개수만큼 반복한다. 가장 작은 수를 구할 때 앞자리에 0을 넣고 시작한다. 다음 부등호가 “&gt;” 라면 부등호 다음 수를 0으로 만들고 그전의 자리에는 +1을 해준다. “&lt;” 라면 사용 한했던 수 중에 가장 작은 수를 넣는다. 이런 방식으로 부등호 개수만큼 반복한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;using namespace std;int main(){ short a[10]; short p[10] = {0, }; short k; cin &gt;&gt; k; char b[10]; for(int i = 0; i &lt; k; i++) cin &gt;&gt; b[i]; short po = 0; a[0] = 9; p[9] = 1; for(int i = 0; i &lt; k; i++) { if(b[i] == '&lt;') { a[i+1] = a[i]; for(int j = po; j &lt; i+1; j++) p[--a[j]] = 1; } if(b[i] == '&gt;') { po = i + 1; for(int j = 9; j &gt; -1; j--) if(p[j] == 0) { a[i + 1] = j; p[j] = 1; break; } } } for(int i = 0; i &lt;= k; i++) cout &lt;&lt; a[i]; cout &lt;&lt; endl; short l[10] = {0, }; po = 0; a[0] = 0; l[0] = 1; for(int i = 0; i &lt; k; i++) { if(b[i] == '&gt;') { a[i+1] = a[i]; for(int j = po; j &lt; i+1; j++) l[++a[j]] = 1; } if(b[i] == '&lt;') { po = i + 1; for(int j = 0; j &lt; 10; j++) if(l[j] == 0) { a[i + 1] = j; l[j] = 1; break; } } } for(int i = 0; i &lt;= k; i++) cout &lt;&lt; a[i];} for 문 굳이 2번 돌릴 필요 없이 함수로 짜면 깔끔할 듯하다.","link":"/2019/10/28/20191028-boj2529/"},{"title":"[C++]BOJ 1080 - 행렬","text":"어렵게 생각하면 절대 안 풀리더라. 왼쪽 위부터 한자리씩 비교하며 다르면 그 칸을 포함해 오른쪽으로 3, 아래로 3 칸을 바꿔준다. 전체가 같아지면 멈추고 모든 칸을 다 바꿨는데 다르면 -1출력. 1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt;using namespace std;int n, m;char a[51][51], b[51][51];void swap(int i, int j) { for (int ii = i-1; ii &lt;= i+1; ii++) for (int jj = j-1; jj &lt;= j+1; jj++) a[ii][jj] = '0' + '1' - a[ii][jj];}bool com(void) { for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) if (a[i][j] != b[i][j]) return false; return true;}int main(void) { scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) scanf(\"%s\", a[i]); for (int i = 0; i &lt; n; i++) scanf(\"%s\", b[i]); int cnt = 0; for (int i = 1; i &lt; n-1; i++) for (int j = 1; j &lt; m-1; j++) if (a[i-1][j-1] != b[i-1][j-1]) { swap(i, j); cnt++; } printf(\"%d\", com()? cnt : -1); return 0;} a[i], b[i]로 받아도 개행이 인식되면 알아서 2차원 배열로 저장하는 듯","link":"/2019/10/28/20191028-boj1080/"},{"title":"[C++]BOJ 2352 - 반도체 설계","text":"뭔가 했는데 알고리즘 분류를 보니 LIS라고 한다. 최장증가수열을 공부하고 풀었다. lower_bound로 최장증가수열을 구현하는 방식을 봤는데 실제로 유효한 수열을 구하진 않았다. 그런데 이 문제는 수열을 구하는 게 아니라 수열의 길이만 구하면 되므로 최대한 생략하고 수열의 길이만 구하도록 바꿨다. 123456789101112131415#include &lt;iostream&gt;using namespace std;int n, g, t, L[40001];int main(){ cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; t; auto p = lower_bound(L+1, L+g+1, t); *p = t; if(p == L+g+1) g++; } cout &lt;&lt; g;}","link":"/2019/11/03/20191103-boj2352/"},{"title":"[C++]BOJ 11053 - 가장 긴 증가하는 부분 수열","text":"이전의 반도체 설계 문제와 동일하다.다른 점은 최대 길이 정도? 123456789101112131415#include &lt;iostream&gt;using namespace std;int n, g, t, L[1001];int main(){ cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; t; auto p = lower_bound(L+1, L+g+1, t); *p = t; if(p == L+g+1) g++; } cout &lt;&lt; g;} 마찬가지로 실제 최장증가수열을 구하진 못한다. 그저 길이만 출력한다.","link":"/2019/11/04/20191104-boj11053/"},{"title":"[C++]BOJ 14501 - 퇴사","text":"왜 이리 어렵게 풀어놨을까 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;int main(){ int n; int a[11]; int b[11]; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; b[i] = i + 1; } int v; for(int i = n - 1; i &gt; -1; i--) { v = b[i]; for(int j = 0; j &lt; a[i] + 1; j++) { b[i+j] = b[i+j+1]; } b[i+a[i]] = v; } for(int i = 0; i &lt; n; i++) cout &lt;&lt; b[i] &lt;&lt; \" \";}","link":"/2019/11/10/20191110-boj14501/"},{"title":"밴드 동아리 스케줄러 만들기","text":"내가 만들고 싶은건 아니고 부탁받았다.내용은 아래와 같다. 팀은 월 화 수 목 금 세션은 보컬 신디 베이스 기타 드럼 각 팀마다 세션에 들어가는 인원이 최소 한 명 이상은 있어야 함 팀의 특정 세션의 최소, 최대 인원수를 정하고 돌릴 수 있으면 좋겠음 ex) 월요일팀 보컬 1~2 기타 1~3 베이스 2 신디 2~3 드럼 2 이름, 가능한 세션(복수선택 가능), 가능한요일(복수선택 가능), 희망하는 최대 팀 개수를 입력 팀을 짤 때 둘 이상의 세션에 한 사람만 들어가면 안됨 ex) 보컬 A, 기타 A, 신디 B, 베이스 C, 드럼 D 희망하는 최대 팀 개수가 2 이상인 사람을 팀에 그보다 적게 넣어도 팀이 짜진다면 굳이 더 넣을 필요 없음 꼭 한 팀에 붙어야 되는 사람을 정할 수 있으면 좋겠음 (희망사항ㅎㅎ) ex) E랑 F는 꼭 같은 팀이어야 한다. c++ 기반으로 작성할 예정이고 파일 입출력을 통해 동아리원들 정보를 받고 시간표를 출력한다. 자고 일어나서 만들자.","link":"/2020/03/03/20200303-cpp-project-bandscheduler/"}],"tags":[{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"BOJ","slug":"BOJ","link":"/tags/BOJ/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"greedy","slug":"greedy","link":"/tags/greedy/"},{"name":"브루트 포스","slug":"브루트-포스","link":"/tags/%EB%B8%8C%EB%A3%A8%ED%8A%B8-%ED%8F%AC%EC%8A%A4/"},{"name":"다이나믹 프로그래밍","slug":"다이나믹-프로그래밍","link":"/tags/%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"name":"study","slug":"study","link":"/tags/study/"},{"name":"project","slug":"project","link":"/tags/project/"}],"categories":[{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","link":"/categories/algorithm/BOJ/"},{"name":"etc","slug":"etc","link":"/categories/etc/"}]}
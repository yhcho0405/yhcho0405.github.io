{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"[C++]BOJ 11399 - ATM","text":"앞사람의 인출 시간이 적을 때 전체 인출 시간이 적어진다. 1234567891011121314151617#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int time[1001]; int a; cin &gt;&gt; a; for(int i = 0; i &lt; a; i++) cin &gt;&gt; time[i]; sort(time, time + a); long long b = 0; for(int i = 0; i &lt; a; i++) for(int j = 0; j &lt; i + 1; j++) b += time[j]; cout &lt;&lt; b;}","link":"/2019/10/24/20191024-boj11399/"},{"title":"[C++]BOJ 11047 - 동전0","text":"동전금액이 큰 단위부터 나눠가면 된다. 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;int main(){ int n, k; cin &gt;&gt; n &gt;&gt; k; int v[11]; for(int i = 0; i &lt; n; i++) { cin &gt;&gt; v[i]; } int g = 0; int j = n - 1; while(1) { if(k == 0) { break; } if(v[j] &lt;= k) { g += k / v[j]; k = k % v[j]; } j--; } cout &lt;&lt; g;}","link":"/2019/10/24/20191024-boj11047/"},{"title":"[C++]BOJ 1931 - 회의실배정","text":"회의가 끝나는 시간이 빠른 회의 순으로 정렬 후 이전 회의의 끝나는 시간과 현재 회의가 시작하는 시간의 조건을 만족시키면 회의 수를 +1 한다. 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; p;int main(){ int a; cin &gt;&gt; a; p b[100001]; for(int i = 0; i &lt; a; i++) { cin &gt;&gt; b[i].second &gt;&gt; b[i].first; } sort(b, b+a); int c = 1; int l = b[0].first; for(int i = 1; i &lt; a; i++) { if(b[i].second &gt;= l) { l = b[i].first; c++; } } cout &lt;&lt; c;} 이 문제 풀다가 pair를 발견했다. 쓸모가 많을 듯 하다.pair를 sort시키면 first기준으로 정렬한다는 점.","link":"/2019/10/24/20191024-boj1931/"},{"title":"[C++]BOJ 5585 - 거스름돈","text":"동전 내는 문제에서 거스름돈으로 바뀐 문제. 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;int main(){ short a; cin &gt;&gt; a; a = 1000 - a; int b = 0; b += a / 500; a = a % 500; b += a / 100; a = a % 100; b += a / 50; a = a % 50; b += a / 10; a = a % 10; b += a / 5; a = a % 5; b += a / 1; a = a % 1; cout &lt;&lt; b;}","link":"/2019/10/24/20191024-boj5585/"},{"title":"[C++]BOJ 2217 - 로프","text":"다음 로프의 길이가 현재 로프의 길이보다 항상 크거나 같다고 가정했을 때, {앞으로 남은 로프의 수 + 1(자기 자신)} * 자신의 길이가 다음 로프에서 같은 연산을 수행했을 때 보다 작다면 다음 로프의 길이 * (앞으로 남은 로프의 수 + 1)가 최대로 견딜 수 있는 하중이 된다. 이를 반복문 돌리면 풀린다. +정렬까지 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int n; cin &gt;&gt; n; short a[100001]; for(int i = 0; i &lt; n ; i++) { cin &gt;&gt; a[i]; } sort(a, a+n); int k = 0; for(int i = 0; i &lt; n; i++) { if(k &lt; a[i] * (n - i)) { k = a[i] * (n - i); } } cout &lt;&lt; k;}","link":"/2019/10/24/20191024-boj2217/"},{"title":"[C++]BOJ 10610 - 30","text":"어떤 수가 3의 배수인지 확인하는 방법은 각 자릿수를 모두 더한 값이 3의 배수여야 한다. 이는 간단한 방법으로 증명할 수 있다. 10^n자릿수가 9일 때 3을 더하면 10^n의 자리에서 7만큼을 손해 보고 10^n+1의 자리에서 1의 이득을 본다. -7+1(역시나 3의 배수) 결국엔 계속 3의 배수가 되는데 생각해보니 정렬된 거나 안된 거나 같이 위의 조건을 만족한다면 그냥 모듈러 연산으로 해도 된다는 생각이 들었다. 어쨌든 30의 배수가 되려면 위의 조건에서 0이 문자열에 포함되어 있는지 확인해 봐야 한다. 조건을 모두 만족한 후 내림차순 정렬하면 풀린다. 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(char a, char b){ return a &gt; b;}int main(){ string n; cin &gt;&gt; n; long long s = 0; bool z = false; for(int i = 0; i &lt; n.size(); i++) { s += (n[i] - '0'); if(!(n[i] - '0')) z = true; } if(!z || s % 3) cout &lt;&lt; -1 &lt;&lt; endl; else { sort(n.begin(), n.end(), cmp); cout &lt;&lt; n &lt;&lt; endl; }}","link":"/2019/10/24/20191024-boj10610/"},{"title":"[C++]BOJ 2875 - 대회 or 인턴","text":"엄청 간단한 문제였는데 방심했다가 틀렸다. 여자 수 / 2 남자 수 여자 수 + 남자 수 - 인턴 수 3개 중에 가장 작은 값이 답이다. 가장 작은 값을 제외하곤 서로의 반례가 되기 때문. 12345678#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; cout &lt;&lt; min(min(n/2, m), (n+m-k)/3) &lt;&lt; endl;}","link":"/2019/10/24/20191024-boj2875/"},{"title":"[C++]BOJ 1120 - 문자열","text":"단순 그리디. B 안에서의 차이가 가장 적은 A를 구하면 그게 답이다. 추가하는 연산은 무조건 차이가 가장 적게 할 테니까 신경 쓰지 않는다. 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int main(){ char a[50], b[50]; cin &gt;&gt; a &gt;&gt; b; int al = sprintf(a, \"%s\", a); int bl = sprintf(b, \"%s\", b); int c = 51; for(int i = 0; i &lt; bl - al + 1; i++) { int co = 0; for(int j = 0; j &lt; al; j++) { if(b[j+i] != a[j]) co++; } if(co &lt; c) c = co; } cout &lt;&lt; c;} 지금보면 좀 한심한 코드다. 배열 길이 구하겠다고 sprintf를 썼다. 시간나면 수정해서 다시 올리자. 불편해서 바로 해버렸다. 12345678910111213141516#include &lt;iostream&gt;using namespace std;int main(){ string a, b; cin &gt;&gt; a &gt;&gt; b; int c = 51; for(int i = 0; i &lt; b.size() - a.size() + 1; i++) { int co = 0; for(int j = 0; j &lt; a.size(); j++) if(b[j+i] != a[j]) co++; if(co &lt; c) c = co; } cout &lt;&lt; c;}","link":"/2019/10/24/20191024-boj1120/"},{"title":"[C++]BOJ 1541 - 잃어버린 괄호","text":"가장 작은 답이 나오려면 +끼리 괄호로 묶고 계산하면 된다. 라고 생각했지만 계속 반례가 생각나서 이건 아닐 거라고 판단했고 그냥 첫 번째 -가 나온 순간부터 다 빼버리면 처음 생각했던 것보다 단순하게 끝난다. +아스키코드 10은 line feed (다음 줄) 1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main(){ bool ch = false; int a, b; char c; scanf(\"%d\", &amp;a); for(;scanf(\"%c\", &amp;c), c != 10;) { if(c == '-') ch = true; scanf(\"%d\", &amp;b); if(ch) a -= b; else a += b; } cout &lt;&lt; a;} cin으로 받아보려 했으나 작동이 안 돼서 scanf로 받았다. 자료형을 정확히 명시해줘야 하는 것 같다. 추가로 for 문에 대해 새로 알게 된 점. for(시작할 때 한 번만 실행; 조건문 말고도 scanf 같은 거 사용 가능, 한번 돌 때마다 조건문 확인해서 매번 실행되는 듯; 증감식, 여기도 매번 실행) 더 찾아봐야 알겠지만 이런 느낌인 듯. ​ 이렇게도 될까? 12345678910111213141516#include &lt;iostream&gt;using namespace std;int main(){ bool ch = false; int a, b; char c; for(scanf(\"%d\", &amp;a); scanf(\"%c\", &amp;c), c != 10;) { if(c == '-') ch = true; scanf(\"%d\", &amp;b); if(ch) a -= b; else a += b; } cout &lt;&lt; a;} 된다. 2바이트 줄였다.","link":"/2019/10/25/20191025-boj1541/"},{"title":"알고리즘 공부 시작","text":"목표 알고리즘 공부 시험 기간이라도 백준 하루 한 문제 이상은 꼭 풀도록 노력 (실패) ​ 공부할 알고리즘 그리디 알고리즘 다이나믹 프로그래밍 bfs, dfs 다익스트라 알고리즘 브루트 포스 플로이드 와샬 알고리즘 ​ 2019년 10월 24일 기준 solved.ac기준 20191013에 그리디 알고리즘 시작함. 13일 - 8문제 14일 - 3문제 15일 - 1문제 16일 - 2문제 17일 - 2문제 18일 - 1문제 19일 - 1문제 20일 - 1문제(교양 중간 전날) 21일부터 전공시험 전날이라 못함. 22일 - 전날 밤새서 잤음 23일 - 1문제 24일 - 2문제 앞으로 푼 문제들은 전부 블로그에 정리해서 적을 예정. 이전까지의 문제들은 기억 되짚어서 천천히 게시 예정. 마무리 목표 구체화가 필요하다 느낌. 예전 코드 보니까 뭔 생각으로 저리 짰는지 기억이 안 나서 적을 공간이 필요했음. 13일 시작일 기준 알고리즘에 대해 무지한 생태. c++ 기본 문법 정도만 알고 있었음.","link":"/2019/10/24/20191024-A_BOJstart/"},{"title":"[C++]BOJ 1946 - 신입 사원","text":"문제에 헷갈리는 문장이 있었다. “다른 모든 지원자와 비교했을 때 서류심사 성적과 면접시험 성적 중 적어도 하나가 다른 지원자보다 떨어지지 않는 자만 선발한다는 원칙을 세웠다.” ??????????? 한참을 보다가 다음 줄 보고 이해했다. “즉, 어떤 지원자 A의 성적이 다른 어떤 지원자 B의 성적에 비해 서류 심사 결과와 면접 성적이 모두 떨어진다면 A는 결코 선발되지 않는다.” ㅇㅎ 이전에 회의실 배정인가 거기서 썼던 pair를 쓰면 편하겠단 생각이 들었다. first는 어차피 오름차순으로 정렬되니 다음 사람의 점수보다 무조건 낮을 것이고 그 와중에 second까지 작으면 조건에 의해 걔는 탈락이다. 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; p;int tk[21];int main(){ p v[100001]; short t; int n; cin &gt;&gt; t; for(int i = 0; i &lt; t; i++) { cin &gt;&gt; n; for(int j = 0; j &lt; n; j++) { cin &gt;&gt; v[j].first &gt;&gt; v[j].second; } sort(v, v+n); int po = v[0].second; int p = n; for(int j = 0; j &lt; n; j++) { if(po &lt; v[j].second) p--; else po = v[j].second; } tk[i] = p; } for(int i = 0; i &lt; t; i++) cout &lt;&lt; tk[i] &lt;&lt; endl;} 왜 배열명을 tk로 썼는지 기억이 가물가물한데 아마 테스트 케이스를 줄여서 tk라 한듯하다. 근데 놀랍게도 test case를 굳이 줄인다면 tc이다. 졸았나보다.","link":"/2019/10/25/20191025-boj1946/"},{"title":"[C++]BOJ 1046 - 기타줄","text":"딴 거 다 필요 없고 가장 싼 패키지와 낱개 가격만 있으면 된다. 그걸 구하기 위해 나는 정렬을 사용한 모양이다. 굳이 그랬어야 할까. 아무튼 경우의 수는 3가지다. 패키지로 살 수 있을 만큼 산 후 나머지 부족한 것을 낱개로 구입. 전부 낱개로 구입. 기타줄 몇 개 남더라도 싹 다 패키지로 구입. 3개 중 가장 작은 게 답이다. 123456789101112131415161718include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int n, m; short pa[50], na[50]; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; m; i++) cin &gt;&gt; pa[i] &gt;&gt; na[i]; sort(pa, pa+m); sort(na, na+m); int d1 = pa[0] * (n / 6) + na[0] * (n % 6); int d2 = na[0] * n; int d3 = pa[0] * ((n / 6) + 1); int v = min(min(d1, d2), d3); cout &lt;&lt; v; } 정렬은 아무리 봐도 불편하다.나중에 수정하자.","link":"/2019/10/25/20191025-boj1046/"},{"title":"[C++]BOJ 2529 - 부등호","text":"가장 큰 수를 구할 때 앞자리에 9를 넣고 시작한다. 다음 부등호가 “&lt;” 라면 부등호 다음 수를 9로 만들고 그전의 자리에는 -1을 해준다. “&gt;” 라면 사용 안 했던 수 중에 가장 큰 수를 넣는다.이런 방식으로 부등호 개수만큼 반복한다. 가장 작은 수를 구할 때 앞자리에 0을 넣고 시작한다. 다음 부등호가 “&gt;” 라면 부등호 다음 수를 0으로 만들고 그전의 자리에는 +1을 해준다. “&lt;” 라면 사용 한했던 수 중에 가장 작은 수를 넣는다. 이런 방식으로 부등호 개수만큼 반복한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;using namespace std;int main(){ short a[10]; short p[10] = {0, }; short k; cin &gt;&gt; k; char b[10]; for(int i = 0; i &lt; k; i++) cin &gt;&gt; b[i]; short po = 0; a[0] = 9; p[9] = 1; for(int i = 0; i &lt; k; i++) { if(b[i] == '&lt;') { a[i+1] = a[i]; for(int j = po; j &lt; i+1; j++) p[--a[j]] = 1; } if(b[i] == '&gt;') { po = i + 1; for(int j = 9; j &gt; -1; j--) if(p[j] == 0) { a[i + 1] = j; p[j] = 1; break; } } } for(int i = 0; i &lt;= k; i++) cout &lt;&lt; a[i]; cout &lt;&lt; endl; short l[10] = {0, }; po = 0; a[0] = 0; l[0] = 1; for(int i = 0; i &lt; k; i++) { if(b[i] == '&gt;') { a[i+1] = a[i]; for(int j = po; j &lt; i+1; j++) l[++a[j]] = 1; } if(b[i] == '&lt;') { po = i + 1; for(int j = 0; j &lt; 10; j++) if(l[j] == 0) { a[i + 1] = j; l[j] = 1; break; } } } for(int i = 0; i &lt;= k; i++) cout &lt;&lt; a[i];} for 문 굳이 2번 돌릴 필요 없이 함수로 짜면 깔끔할 듯하다.","link":"/2019/10/28/20191028-boj2529/"},{"title":"[C++]BOJ 1080 - 행렬","text":"어렵게 생각하면 절대 안 풀리더라. 왼쪽 위부터 한자리씩 비교하며 다르면 그 칸을 포함해 오른쪽으로 3, 아래로 3 칸을 바꿔준다. 전체가 같아지면 멈추고 모든 칸을 다 바꿨는데 다르면 -1출력. 1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt;using namespace std;int n, m;char a[51][51], b[51][51];void swap(int i, int j) { for (int ii = i-1; ii &lt;= i+1; ii++) for (int jj = j-1; jj &lt;= j+1; jj++) a[ii][jj] = '0' + '1' - a[ii][jj];}bool com(void) { for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) if (a[i][j] != b[i][j]) return false; return true;}int main(void) { scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) scanf(\"%s\", a[i]); for (int i = 0; i &lt; n; i++) scanf(\"%s\", b[i]); int cnt = 0; for (int i = 1; i &lt; n-1; i++) for (int j = 1; j &lt; m-1; j++) if (a[i-1][j-1] != b[i-1][j-1]) { swap(i, j); cnt++; } printf(\"%d\", com()? cnt : -1); return 0;} a[i], b[i]로 받아도 개행이 인식되면 알아서 2차원 배열로 저장하는 듯","link":"/2019/10/28/20191028-boj1080/"},{"title":"[C++]BOJ 2352 - 반도체 설계","text":"뭔가 했는데 알고리즘 분류를 보니 LIS라고 한다. 최장증가수열을 공부하고 풀었다. lower_bound로 최장증가수열을 구현하는 방식을 봤는데 실제로 유효한 수열을 구하진 않았다. 그런데 이 문제는 수열을 구하는 게 아니라 수열의 길이만 구하면 되므로 최대한 생략하고 수열의 길이만 구하도록 바꿨다. 123456789101112131415#include &lt;iostream&gt;using namespace std;int n, g, t, L[40001];int main(){ cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; t; auto p = lower_bound(L+1, L+g+1, t); *p = t; if(p == L+g+1) g++; } cout &lt;&lt; g;}","link":"/2019/11/03/20191103-boj2352/"},{"title":"[C++]BOJ 11053 - 가장 긴 증가하는 부분 수열","text":"이전의 반도체 설계 문제와 동일하다.다른 점은 최대 길이 정도? 123456789101112131415#include &lt;iostream&gt;using namespace std;int n, g, t, L[1001];int main(){ cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; t; auto p = lower_bound(L+1, L+g+1, t); *p = t; if(p == L+g+1) g++; } cout &lt;&lt; g;} 마찬가지로 실제 최장증가수열을 구하진 못한다. 그저 길이만 출력한다.","link":"/2019/11/04/20191104-boj11053/"},{"title":"[C++]BOJ 14501 - 퇴사","text":"왜 이리 어렵게 풀어놨을까 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;int main(){ int n; int a[11]; int b[11]; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) { cin &gt;&gt; a[i]; b[i] = i + 1; } int v; for(int i = n - 1; i &gt; -1; i--) { v = b[i]; for(int j = 0; j &lt; a[i] + 1; j++) { b[i+j] = b[i+j+1]; } b[i+a[i]] = v; } for(int i = 0; i &lt; n; i++) cout &lt;&lt; b[i] &lt;&lt; \" \";}","link":"/2019/11/10/20191110-boj14501/"},{"title":"크롬 확장프로그램 개발 일지","text":"크롬 확장 프로그램에 갑자기 꽂혀서 방학 때 낭비되는 시간도 아깝고 공부도 할겸 시작했다.웹과 자바스크립트에 대해 무지한 상태에서 시작한 터라 시행착오를 많이 겪었다. 2019년 12월 23일 노베이스 개발 시작 크롬 익스텐션으로 주제 설정. 구글링해가며 구동방식 이해. 개발할 기능 구상. 유튜브 동영상 시청 시, 시청중인 위치를 영상 제목과 함께 북마크해 모아주는 기능 구상.(onetab에서 아이디어 얻음) 현재 시청중인 분, 초를 가져올 방법을 생각해야 함. html body태그에서 모든 단어들을 가져오기 =&gt; 띄어쓰기로 스플릿 해서 구분 =&gt; 줄바꿈으로 스플릿해서 분, 초 가 담긴 인덱스로 화면에 출력까지 성공.(아마 더 쉽게하는 방법이 있을 것) 문제점 html로 현재 재생중인 부분을 가져오다 보니 영상 시청 중 아래 타임라인이 사라지면 사라지기 직전의 시간을 가져온다는 점. 추가 할 기능 여러개의 북마크를 어떻게 보여줄지. 북마크된 링크로 넘어가는 방식은 어떻게 할지(링크누르기?, 버튼누르기?) 아이디어 유튜브 링크 뒤에 시간을 붙이면 그 시간대로 영상이 재생된다. 2019년 12월 24일 유튜브 게시자의 프로필사진을 불러와 보여주는 기능 구상. 추출해야할 jpg파일의 src값 img태그의 class이름까지는 구했는데 자바스크립트에서 이를 받아올 방법을 찾아야 함. jquery를 이용해 보려 했으나 실패. 북마킹 버튼 디자인(오픈소스 활용) 문제점 위에서 말했던 대로 jquery를 못 쓰고 js로만 해보려 했으나 안됨. 아직도 23일 문제점 1을 해결하지 못함. 추가 할 기능 북마크된 정보에 프로필사진과 채널 명, 제목 일부를 보여줄 레이아웃 구상. 크롬 내부저장소에 북마크 된 정보를 저장. 아이디어 채널 프로필 사진을 함께 보여주어 정보확인 부분에서의 명확성을 높힘. 2019년 12월 25일 새로운 확장프로그램 아이디어 생겨서 병행하느라 별로 못함. 2019년 12월 26일 게시자의 프로필 사진을 가져오는 것 보단 썸네일을 가져오는게 가시성이 더 높을 것이라 판단. 썸네일을 html iframe으로 불러오는데 성공. 링크와 합쳐 화면에 띄우는 데 성공. 삭제버튼 추가. 문제점 썸네일 위 아래로 검은색 여백이 생간다. 크기를 강제로 줄이면 아래쪽 썸네일이 잘리기 때문에 해결하지 못한다. 2019년 12월 27일 전체적인 레이아웃 수정. 제목 가져와서 화면에 표시하기 성공. 제목 string으로 형변환 후 “ - YouTube” 삭제. 뒤늦은 오류 발견.(해결) 타이틀을 가져올 때 알람의 수 만큼 제목 앞에 붙어서 출력되는 문제 수정. 현재 시간을 가져올 때 가끔 인덱스 참조 예외가 생기는 문제 수정. (추후 유튜브 UI가 업데이트 되면 다시 발생할 가능성이 있기 때문에 오류코드와 이메일 삽입) 문제점 디자인 수정 필요. 크롬 저장소 활용해야 함. youtube에서만 작동하도록 예외처리가 안됨. 버튼이 사라지게 하는 방법 찾기. 추가할 점 버튼의 활용 및 레이아웃 구상. 2019년 12월 28일 유튜브에서만 동작할 수 있도록 예외처리 함. 제목 자르기 부분의 오류 확인 및 수정.(알람에 9+가 떴을 경우 외 여러가지 상황에 유동적으로 반응하게끔) 유튜브 안에는 있지만 동영상을 시청하지 않는 상황에 대한 예외처리 완료. 문제점 동영상이 끝났을 때 에러코드 출력함. 예외처리 필요. 크롬 익스텐션에선 html의 인라인 함수를 보안상의 이유로 막아놈.(인라인 onclick 사용 불가) 2번의 이유로 js파일 내부에서 버튼 클릭 이벤트를 만들었으나, html 파일의 형식으로 insertBefore메서드를 사용할 방법을 찾아야 함. 아이디어 북마크가 쌓이면서 스크롤이 내려간다면 북마크 버튼의 위치를 유동적으로 바꾸는 방법이 있으면 좋겠다. 2019년 12월 29일 insertBefore 메소드를 사용하지 않고 append로 처리해 클릭하면 현재의 창이 스크랩 되도록 함. 크롬 스토리지 기능을 사용해 북마크를 자동으로 저장하고 가져오는 기능 추가. delete all 버튼도 기능 부여. 스토리지 기능 사용하며 코드 구조 수정. 예외처리 때문에 유튜브 밖에서 기록 삭제가 안되는 오류 수정. 썸네일 가져오는 방식을 iframe에서 img로 바꿈. 썸네일 상하 여백 크롭. 문제점 익스텐션에서 a태그를 사용할 수 없다. 추가할 점 썸네일과 제목 클릭 시 하이퍼링크. 레이아웃 수정. 알수 없는 크롬저장소 오류 원인 찾기. 발견 된 오류 정상 작동 하나, 가끔 삭제 후 다시 들어가보면 다시 생겨있거나 이전의 기록과 합쳐짐. 2019년 12월 30일 디자인 레이아웃 수정. 하이퍼링크 기능 활성화. 썸네일 테두리 둥글게 처리. 제목 2줄이상 오버플로우는 hidden처리. 실시간 영상의 경우 인덱스 오류 발생. 인덱스 참조에러가 알림의 유, 무와 관련있다는 사실 파악. 29일 발생한 오류 1번을 해결함. 시간 가져오는 방식 갈아엎음.(27일 발생한 인덱스 참조 오류의 원인 자체를 없앰.) 문제점 16개 밖에 저장하지 못함.(string이 담을 수 있는 최대용량을 넘은것은 터무니없고 크롬 스토리지도 5mb까지 지원하기 때문에 충분하다. 아마 구조체 형식으로 처리해야 할 듯 하다.) chrome.storage.sync는 용량제한 100kb가 걸려있다는 사실 알게됨.(local은 제한 없어서 그거 썼다) 2019년 12월 31일 개별 삭제 버튼 추가. 2020년 1월 1일 id값은 고유해야 함. 개별삭제기능 구현. 아직 오류있음. 오류해결 초반에 기획했던 기능은 모두 구현 완료. 2020년 1월 2일 처음 사용자에게 발생하는 undefined 오류에 안내말 삽입. 1차 디버깅, 오류는 위 사항 말고 발견되지 않음. 2020년 1월 31일 처음 사용자에게 발생하는 저장소 오류에 대한 예외처리 코드 추가. 크롬 웹 스토어에 등록 거부됨. 재등록 후 등록 심사중. 최종적으론 크롬 웹 스토어에 등록을 성공했으며 블로그 좌측 배너에 링크되어 있다. 혹은 여기초반에 구상한 기능은 모두 구현해 놨지만 아쉬운점이 많다.삽질도 많이 했지만 그래서 더 의미있는 경험이었다.","link":"/2020/01/31/20200131-js-chrome-extension/"},{"title":"밴드 동아리 스케줄러 만들기","text":"내가 만들고 싶은건 아니고 부탁받았다.내용은 아래와 같다. 팀은 월 화 수 목 금 세션은 보컬 신디 베이스 기타 드럼 각 팀마다 세션에 들어가는 인원이 최소 한 명 이상은 있어야 함 팀의 특정 세션의 최소, 최대 인원수를 정하고 돌릴 수 있으면 좋겠음 ex) 월요일팀 보컬 1~2 기타 1~3 베이스 2 신디 2~3 드럼 2 이름, 가능한 세션(복수선택 가능), 가능한요일(복수선택 가능), 희망하는 최대 팀 개수를 입력 팀을 짤 때 둘 이상의 세션에 한 사람만 들어가면 안됨 ex) 보컬 A, 기타 A, 신디 B, 베이스 C, 드럼 D 희망하는 최대 팀 개수가 2 이상인 사람을 팀에 그보다 적게 넣어도 팀이 짜진다면 굳이 더 넣을 필요 없음 꼭 한 팀에 붙어야 되는 사람을 정할 수 있으면 좋겠음 (희망사항ㅎㅎ) ex) E랑 F는 꼭 같은 팀이어야 한다. c++ 기반으로 작성할 예정이고 파일 입출력을 통해 동아리원들 정보를 받고 시간표를 출력한다.자고 일어나서 만들자. 일어났다. 동아리원이 30명 정도이기 때문에 최소의 경우로 인당 단 하루 한개의 세션을 선택해도 경우의 수는 아래와 같다. $$25^{30}$$ 계산기피셜 자릿수만 42자리다. 모든 경우의 수를 다 대입해보는 것은 무리라고 생각했고 최적의 시간표를 만드는 방법을 찾아야 했다. 우선 개인별로 아래와 같은 하나의 시간표를 가진다.예를 들어 A라는 사람은 화, 수, 목요일에 출석이 가능하고 기타와 베이스를 다룰줄 안다고 가정하자. 보컬:V 기타:G 베이스:B 신디:S 드럼:D A의 시간표 월 화 수 목 금 V G O O O B O O O S D 개인별로 저런 형태의 시간표를 가지고 이를 3차원 배열로 저장한다. 다음으로 모든 시간표들로부터 각 칸의 빈도수를 저장할 2차원 배열을 만든다. 빈도수 월 화 수 목 금 V 3 2 3 1 1 G 1 1 1 1 1 B 3 2 3 1 1 S 1 1 1 1 2 D 1 1 1 1 2 숫자가 클 수록 상대적으로 널널한 시간대라고 볼 수 있다. 여기서 각 시간대별로 사용자가 미리 저장해둔 최소인원을 빼면 그 시간대에 움직임이 자유로운 가용인원 즉, 후에 가중치로 사용될 표가 생성된다. 시간대가 비어있어서 시간표 생성이 불가능하거나 최소인원보다 적게 인원이 집계된 경우와 같은 예외처리를 해준다. 모든 준비를 마치면 모든 사람의 시간표들을 체크하며 세로선당 가중치가 가장 작은 부분의 스케줄을 제외하고 모두 삭제한다.이후 희망하는 최대 요일 수 만큼 남을 때 까지 가중치가 큰 순서대로 제외한다. 문제점을 발견했다. 쓰기 귀찮아서 사진으로 대체한다.","link":"/2020/03/03/20200303-cpp-project-bandscheduler/"},{"title":"선택 정렬(Selection Sort)","text":"주어진 배열에서 가장 작은 숫자를 앞으로 옮겨가며 정렬하는 방법이다. #include &lt;climits&gt; 는 자료형의 최대, 최소값이 정의된 헤더파일이다. 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;climits&gt;using namespace std;int main() { int min, idx, tmp, arr[10] = {10,5,4,6,2,3,7,9,1,8}; for(int i = 0; i &lt; 10; i++) { min = INT_MAX; for(int j = i; j &lt; 10; j++) { if(min &gt; arr[j]) { min = arr[j]; idx = j; } } tmp = arr[i]; arr[i] = arr[idx]; arr[idx] = tmp; } for(int i = 0; i &lt; 10; i ++) cout &lt;&lt; arr[i] &lt;&lt; \" \";} 흔히 ‘정렬’이라는 주제를 떠올렸을 때 가장 직관적으로 떠올릴 수 있는 방법 중 하나인 만큼 비 효율적이다. 알고리즘의 성능을 분석할 때 시간복잡도라는 척도를 사용한다고 한다. n개의 수를 정렬한다면위 식을 빅 오 표기법으로 나타내면 O(n^2) 가 된다. algorithm average worst best space select O(N^2) O(N^2) O(N^2) O(1)","link":"/2020/03/09/20200309-algorithm-theory1/"},{"title":"버블 정렬(Bubble Sort)","text":"인접한 두 원소를 비교하며 정렬하는 방법이다.학기 초에 자주 접해서 익숙하다. 위 움짤은 마약같다. 1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main() { int tmp, arr[10] = {10,5,4,6,2,3,7,9,1,8}; for(int i = 0; i &lt; 10; i++) { for(int j = 0; j &lt; 9 - i; j++) { if(arr[j] &gt; arr[j + 1]) { tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; } } } for(int i = 0; i &lt; 10; i++) cout &lt;&lt; arr[i] &lt;&lt; \" \";} 시간 복잡도는 선택정렬과 동일하다.O(n^2) 가 된다.하지만 선택 정렬보다 느리게 작동한다.버블정렬은 매번 인접한 원소의 자리를 바꿔줘야 하지만 선택정렬은 배열에서 가장 작은 원소의 자리만 바꿔주면 되기 때문에 연산하는 양에서 차이가 발생한다. 위 코드에 실행 중 스왑이 안 발생할 시 break 해주면 성능을 높일 수 있다. algorithm average worst best space bubble O(N^2) O(N^2) O(N^2) O(1)","link":"/2020/03/09/20200309-algorithm-theory2/"},{"title":"삽입 정렬(Insertion Sort)","text":"배열의 모든 요소를 앞에서부터 이미 정렬된 배열과 비교하여 적절한 위치를 찾는 정렬 방법이다. 1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main() { int tmp, arr[10] = {10,5,4,6,2,3,7,9,1,8}; for(int i = 0; i &lt; 9; i++) { int j = i; while(arr[j] &gt; arr[j + 1]) { tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; j--; } } for(int i = 0; i &lt; 10; i++) cout &lt;&lt; arr[i] &lt;&lt; \" \";} 최악의 경우번의 비교를 하게 되므로, O(n^2) 가 된다.역시나 선택정렬이나 버블정렬과 같은 시간복잡도를 가지지만 실제론 삽입정렬이 가장 빠르다.필요할 때만 위치를 바꾸기 때문에 거의 정렬이 된 상태일 때 가장 빠르고, 자원을 덜 사용하여 효율적으로 작동한다.때문에 다른 정렬 알고리즘의 일부로 사용되는 경우가 있다. algorithm average worst best space insert O(N^2) O(N^2) O(N) O(1)","link":"/2020/03/09/20200309-algorithm-theory3/"},{"title":"퀵 정렬(Quick Sort)","text":"분할 정복 알고리즘의 대표적인 예시이며 피봇을 기준으로 정렬해 나가는 정렬 방법이다. 분할과정과 정복과정으로 나누어져 있으며, 피봇을 정한 뒤 피봇을 기준으로 작거나 큰것으로 나눠간다.퀵소트의 피봇 선정 방식은 여러가지가 존재한다. 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;int arr[10] = {10,5,4,6,2,3,7,9,1,8};int num = 10;void quickSort(int *arr, int start, int end) { if(start &gt;= end) { return; } int key = start; int i = start + 1; int j = end; int tmp; while(i &lt;= j) { while(arr[i] &lt;= arr[key]) { i++; } while(arr[j] &gt;= arr[key] &amp;&amp; j &gt; start) { j--; } if(i &gt; j) { tmp = arr[j]; arr[j] = arr[key]; arr[key] = tmp; } else { tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp; } } quickSort(arr, start, j - 1); quickSort(arr, j + 1, end);}int main() { quickSort(arr, 0, num - 1); for(int i = 0; i &lt; 10; i++) cout &lt;&lt; arr[i] &lt;&lt; \" \";} 위의 코드는 피봇을 왼쪽의 요소로 잡는 알고리즘이다.퀵소트는 이름에서 알 수 있드시 매우 빠른 정렬 알고리즘에 속한다.하지만 최악의 경우 n^2으로 작동할 여지가 있다.아이러니하게도 최악의 경우는 배열이 이미 정렬 되어있을 때 발생한다.이 문제를 해결하기 위해 피봇을 랜덤으로 선정하거나 중위법을 이용하는 방법, 작은 분할 범위의 정렬은 삽입정렬을 이용하는 방법등이 있다. 여담으로 C++ STL #include &lt;algorithm&gt; 라이브러리의 sort() 함수는 퀵소트를 기반으로 작성되었다.(모든 경우에서 O(n log n)을 보장한다.) algorithm average worst best space quick O(NlogN) O(N^2) O(NlogN) O(logN)","link":"/2020/03/14/20200314-algorithm-theory4/"},{"title":"병합 정렬(Merge Sort)","text":"퀵소트와 마찬가지로 분할정복 알고리즘이다.재귀함수를 이용해 배열을 절반으로 잘라가며 분할하고 정복한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;using namespace std;int arr[10];void merge(int a[], int m, int mid, int n) { int i = m; int j = mid + 1; int k = m; while(i &lt;= mid &amp;&amp; j &lt;= n) { if(a[i] &lt;= a[j]) { arr[k] = a[i]; i++; } else { arr[k] = a[j]; j++; } k++; } if(i &gt; mid) { for(int t = j; t &lt;= n; t++) { arr[k] = a[t]; k++; } } else { for(int t = i; t &lt;= mid; t++) { arr[k] = a[t]; k++; } } for(int t = m; t &lt;= n; t++) { a[t] = arr[t]; }}void mergeSort(int a[], int m, int n) { if(m &lt; n) { int mid = (m + n) / 2; mergeSort(a, m, mid); mergeSort(a, mid + 1, n); merge(a, m, mid, n); }}int main() { int array[10] = {10,5,4,6,2,3,7,9,1,8}; mergeSort(array, 0, 9); for(int i = 0; i &lt; 10; i++) cout &lt;&lt; array[i] &lt;&lt; \" \";} 위 코드에서 mergeSort()함수는 재귀함수로써 배열을 절반으로 나눠가며 merge()함수를 호출하고, merge()함수에서는 요소들을 비교하며 정렬하는 정복 과정을 수행한다. mergeSort()는 분할, merge()는 정복의 역할을 한다. 피봇에 따라 성능이 다른 퀵소트와 다르게 무조건 절반으로 분할하기 때문에 모든 경우에서 O(NlogN)의 시간복잡도를 보장받는다.다만 데이터를 담을 추가적인 공간이 필요하기 때문에 메모리 측면에서 비효율적이다. algorithm average worst best space merge O(NlogN) O(NlogN) O(NlogN) O(n)","link":"/2020/03/15/20200315-algorithm-theory5/"},{"title":"힙 정렬(Heap Sort)","text":"최대 힙 트리나 최소 힙 트리를 구현해 정렬하는 방법이다. 트리 구조로 보여주는 움짤을 찾아보려 했으나 귀찮았다. n개의 노드에 대해 완전 이진 트리를 구성한다.heapify과정을 통해 부모노드의 요소가 자식노드의 요소보다 크도록 만든다.가장 첫번째 요소와 가장 마지막 요소를 swap후 다시 heapify한다. 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;int heap[10] = {10,5,4,6,2,3,7,9,1,8};int main() { for(int i = 1; i &lt; 10; i++) { int c = i; do { int root = (c - 1) / 2; if(heap[root] &lt; heap[c]) { int temp = heap[root]; heap[root] = heap[c]; heap[c] = temp; } c = root; } while(c != 0); } for(int i = 9; i &gt;= 0; i--) { int temp = heap[0]; heap[0] = heap[i]; heap[i] = temp; int root = 0; int c = 1; do { c = 2 * root + 1; if(heap[c] &lt; heap[c + 1] &amp;&amp; c &lt; i - 1) { c++; } if(heap[root] &lt; heap[c] &amp;&amp; c &lt; i) { int temp = heap[root]; heap[root] = heap[c]; heap[c] = temp; } root = c; } while(c &lt; i); } for(int i = 0; i &lt; 10; i++) cout &lt;&lt; heap[i] &lt;&lt; \" \";} 위 코드는 최대 힙 트리를 통해 정렬한다. 최대 힙 트리는 부모노드의 요소가 자식노드의 요소보다 크다. 추가적인 메모리를 필요로 하지 않으면서 모든 경우에 대해 O(NlogN)의 시간복잡도를 보장받는다.만능처럼 보이지만 실제로는 퀵소트가 더 빠르고 데이터의 상태에 따른 편차가 발생한다. 또 stable을 보장받지 못한다. heapify과정은 트리의 깊이 만큼 진행되므로 logN 만큼 수행하고 swap하는 과정을 n번 하면 정렬되므로 O(NlogN)의 시간복잡도가 나온다. algorithm average worst best space heap O(NlogN) O(NlogN) O(NlogN) O(1)","link":"/2020/03/16/20200316-algorithm-theory6/"},{"title":"[C++]BOJ 1202 - 보석 도둑","text":"처음엔 무식하게 2중 for문으로 돌려보았다.맞겠지 싶었는데 시간초과가 떴다. 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; p;p b[300001];int c[300001];bool com(const pair&lt;int, int&gt;&amp; a, const pair&lt;int, int&gt;&amp; b){ if(a.first == b.first) return a.second &gt; b.second; return a.first &gt; b.first;}int main() { int n, k; cin &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt; n; i++) { cin &gt;&gt; b[i].second &gt;&gt; b[i].first; } for(int i = 0; i &lt; k; i++) { cin &gt;&gt; c[i]; } sort(b, b + n, com); sort(c, c + k); int total = 0; for(int i = 0; i &lt; k; i++) { for(int j = 0; j &lt; n; j++) { if(c[i] &gt;= b[j].second) { total += b[j].first; b[j].second = INT_MAX; break; } } } cout &lt;&lt; total;} 시간초과가 떴기 때문에 논리가 맞고 틀리고는 모르지만 맞다고 생각하기로 했다.생각해보니 n과 k가 300,000이라 가정했을 때 최악의 경우 2중 for문에서 300,000^2 번 연산하므로 제한시간 1초는 터무니없었다.구글링해보니 우선순위 큐를 사용하더라우선순위 큐를 얕게 핥아봤다.우선순위 큐는 비선형자료구조로써 넣은 순서와 상관없이 우선순위대로 나간다.max heap의 형태로 원소들이 저장되어 있다고 한다.굉장한 우연으로 이거 풀기 전에 힙 정렬을 공부하고 왔다. 위 코드를 변형해서 우선순위 큐가지고 짜봤다. 보석과 가방을 무게기준으로 오름차순 정렬한다. 가방 무게가 작은 것부터 for문을 돌며 그 가방에 들어갈 수 있는 보석을 우선순위 큐에 넣는다. 가장 큰 요소를 큐어서 빼서 total에 더한다. 반복한다. 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; p;priority_queue&lt;int&gt; pq;p b[300001];int c[300001];int main() { int n, k; cin &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt; n; i++) cin &gt;&gt; b[i].first &gt;&gt; b[i].second; for(int i = 0; i &lt; k; i++) cin &gt;&gt; c[i]; sort(b, b + n); sort(c, c + k); long long total = 0; int j = 0; for(int i = 0; i &lt; k; i++) { while(j &lt; n &amp;&amp; b[j].first &lt;= c[i]) pq.push(b[j++].second); if(!pq.empty()) { total += pq.top(); pq.pop(); } } cout &lt;&lt; total;} 맞았다.","link":"/2020/03/16/20200316-boj1202/"},{"title":"[C++]스택(Stack)과 큐(Queue)","text":"스택과 큐는 선형구조로 분류되는 자료구조 중 대표적인 예시이다. 스택(Stack) push(element) : top에 원소를 추가 pop() : top에 있는 원소를 삭제 top() : top에 있는 원소를 반환 empty() : 스택이 비어있으면 true 아니면 false를 반환 size() : 스택 사이즈를 반환 큐(Queue) push(element) : 큐 뒤에 원소를 추가 pop() : 큐 앞에 있는 원소를 삭제 front() : 큐 제일 앞에 있는 원소를 반환 back() : 큐 제일 뒤에 있는 원소를 반환 empty() : 큐가 비어있으면 true 아니면 false를 반환 size() : 큐 사이즈를 반환 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;int main () { stack&lt;int&gt; s; queue&lt;int&gt; q; s.push(1); s.push(2); s.push(3); s.pop(); cout &lt;&lt; s.top() &lt;&lt; endl; cout &lt;&lt; s.size() &lt;&lt; endl; cout &lt;&lt; (s.empty() ? \"empty\" : \"!empty\") &lt;&lt; endl &lt;&lt; endl; q.push(1); q.push(2); q.push(3); q.pop(); cout &lt;&lt; q.front() &lt;&lt; endl; cout &lt;&lt; q.back() &lt;&lt; endl; cout &lt;&lt; q.size() &lt;&lt; endl; cout &lt;&lt; (q.empty() ? \"empty\" : \"!empty\") &lt;&lt; endl &lt;&lt; endl;}","link":"/2020/03/17/20200317-algorithm-theory7/"},{"title":"DFS(Depth First Search)와 BFS(Breath First Search)","text":"깊이 우선 탐색(Depth First Search) 루트 노드에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법 재귀함수를 기반으로 순환 알고리즘의 형태를 지님. 너비 우선 탐색(Breath First Search) 루트 노드에서 시작해서 인접한 노드를 먼저 탐색하는 방법 재귀함수로 동작하지 않는다. 큐를 사용하여 효율적으로 구현 가능하다. 미로찾기에서도 사용된다.https://codepen.io/Owlree/details/PPomzo 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int n, m;int ans[1001][1001];int v[1001];queue&lt;int&gt; q;void dfs(int s) { cout &lt;&lt; s &lt;&lt; \" \"; v[s] = 1; for(int i = 1; i &lt;= n; i++) { if(v[i] == 1 || ans[s][i] == 0) continue; dfs(i); }}void bfs(int s) { q.push(s); v[s] = 0; while(!q.empty()) { s = q.front(); cout &lt;&lt; s &lt;&lt; \" \"; q.pop(); for(int i = 1; i &lt;= n; i++) { if(ans[s][i] == 0 || v[i] == 0) continue; q.push(i); v[i] = 0; } }}int main() { int a, b, s; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; for(int i = 0; i &lt; m; i++) { cin &gt;&gt; a &gt;&gt; b; ans[a][b] = ans[b][a] = 1; } dfs(s); cout &lt;&lt; endl; bfs(s);} 위 코드는 1260번 내 채점 소스코드를 복붙해왔다.https://www.acmicpc.net/problem/1260","link":"/2020/03/18/20200318-algorithm-theory8/"},{"title":"다익스트라 알고리즘(Dijkstra Algorithm)","text":"다익스트라 알고리즘은 출발점으로부터 모든 정점까지의 최단 거리를 구하기 위해 사용한다.길찾기에도 쓰인다. 모든 정점을 미방문 상태로 표시하고 시작점에 방문한다. 시작 정점을 제외하고 모든 정점까지의 거리를 무한대로 둔다. 현재 위치에서 갈 수 있는 모든 정점을 확인하고 해당 정점이 현재까지 기록한 거리보다 더 짧게 이동할 수 있다면 갱신한다. 아직 선택하지 않았던 정점 중 가장 짧은 거리의 정점을 현재 정점으로 선택한다. 3 ~ 4번 반복. 코드는 직접 짜보고 나중에 추가","link":"/2020/03/23/20200323-algorithm-theory10/"},{"title":"크루스칼 알고리즘(Kruskal Algorithm) (feat. Union-Find)","text":"크루스칼 알고리즘은 가장 적은 비용으로 모든 노드를 연결하여 최소비용신장트리를 만들 때 사용하는 알고리즘이다. 가장 가중치가 작은 간선부터 골라가는 그리디한 방법이며 작동과정 중 사이클이 생기지 않도록 유니온파인드를 사용해 해결한다. 사용할 그래프 가중치가 가장 작은 간선을 선택한다. 마찬가지로 가중치가 가장 작은 간선을 선택한다. 그 다음으로 작은 간선을 선택한다. 간선 AB를 선택하고 사이클이 발생하는 BD는 제외한다. 다음으로 작은 간선을 고르고 사이클이 발생하면 제외한다. 반복하면 최소 비용 신장 부분 그래프가 완성된다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int getParent(int set[], int x) { if(set[x] == x) return x; return set[x] = getParent(set, set[x]);}void unionParent(int set[], int a, int b) { a = getParent(set, a); b = getParent(set, b); if(a &lt; b) set[b] = a; else set[a] = b;}int find(int set[], int a, int b) { a = getParent(set, a); b = getParent(set, b); if(a == b) return 1; else return 0;}class Edge {public: int node[2]; int distance; Edge(int a, int b, int distance) { this-&gt;node[0] = a; this-&gt;node[1] = b; this-&gt;distance = distance; } bool operator &lt;(Edge &amp;edge) { return this-&gt;distance &lt; edge.distance; }};int main() { int n = 7; int m = 11; vector&lt;Edge&gt; v; v.push_back(Edge(1, 2, 7)); v.push_back(Edge(1, 4, 5)); v.push_back(Edge(2, 3, 8)); v.push_back(Edge(2, 4, 9)); v.push_back(Edge(2, 5, 7)); v.push_back(Edge(3, 5, 5)); v.push_back(Edge(4, 5, 15)); v.push_back(Edge(4, 6, 6)); v.push_back(Edge(5, 6, 8)); v.push_back(Edge(5, 7, 9)); v.push_back(Edge(6, 7, 11)); sort(v.begin(), v.end()); int set[n]; for(int i = 0; i &lt; n; i++) set[i] = i; int sum = 0; for(int i = 0; i &lt; v.size(); i++) { if(!find(set, v[i].node[0] - 1, v[i].node[1] - 1)) { sum += v[i].distance; unionParent(set, v[i].node[0] - 1, v[i].node[1] - 1); } } cout &lt;&lt; sum;} 위 코드에서 정점 A, B, C, D, E, F, E는 각 1, 2, 3, 4, 5, 6으로 표현했다.최소 비용 신장 트리에서 간선들의 가중치 합을 출력하는 코드다.","link":"/2020/03/23/20200323-algorithm-theory9/"},{"title":"에라토스테네스의 체 (+ 골드바흐의 추측)","text":"자연수의 집합에서 소수를 찾아내는 방법으로 모든 수를 나눠보며 나머지를 확인하는 방법보다 빠르기 때문에 유용하게 사용된다. 소수를 구하고자 하는 구간의 모든 수를 나열한다. 2의 배수, 3의 배수, 5의 배수… 로 계속 지워나간다.위의 움짤에선 숫자가 120까지 있으니 7의 배수 까지만 지워나가면 된다.(7의 다음 소수인 11의 제곱은 121이기 때문) 1234567891011121314#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;bool p[1000001] = {1, 1};vector&lt;int&gt; prime;int main() { for(int i = 2; i * i &lt;= 1000001; i++) { if(p[i]) continue; for(int j = i * i; j &lt; 1000001; j += i) p[j] = 1; } for(int i = 0; i &lt;= 1000001; i++) if(!p[i]) prime.push_back(i);} 골드바흐의 추측은 정수론의 미해결 문제로, 2보다 큰 모든 짝수는 두개의 소수의 합으로 나타낼 수 있다는 추측이다.1742년 부터 아직까지도 증명은 안 됐지만 작은 범위의 숫자 내에선 부분적으로 증명해볼 수 있다. 1234567891011121314int ll, rr, l, r, sum, tmp;cin &gt;&gt; tmpwhile(l &lt;= r) { sum = prime[l] + prime[r]; if(sum == tmp) { ll = prime[l], rr = prime[r]; l++; r--; } else if(sum &lt; tmp) { l++; } else { r--; } } 두개의 위치 인덱스를 조건이 맞을 때 까지 좁혀오며 답을 구하는 투 포인터 알고리즘을 사용하면 쉽다.","link":"/2020/03/24/20200324-algorithm-theory11/"},{"title":"[C++]BOJ 1110 - 더하기 사이클","text":"읽히는 대로 짜면 된다.신기한 점은 이 문제의 정답은 1, 3, 4, 12, 20, 60으로 6가지 밖에 없다.0부터 99까지의 숫자 중에 정답이 1인 숫자가 1개, 3인 숫자가 3개 4인 숫자가 4개, 5인 숫자가 5개, 12인 숫자가 12개, 20인 숫자가 20개, 60인 숫자가 60개다.각 정답이 같은 숫자끼리 돌아가며 등장한다. 1234567891011121314#include &lt;iostream&gt;using namespace std;int main(){ int n, i = 0 ,a, b, c; cin &gt;&gt; n; c = n; do { a = c / 10; b = c % 10; c = (b * 10) + (a + b) % 10; i++; } while(n != c); cout &lt;&lt; i;} 1 + 3 + 4 + 12 + 20 + 60 = 100","link":"/2020/03/24/20200324-boj1110/"},{"title":"유클리드 호제법(Euclidean algorithm)","text":"유클리드 호제법은 2개의 자연수 사이의 최대공약수를 구할 때 사용하는 알고리즘이다.2개의 자연수 a, b(a &gt; b)가 있고 a % b = r 이라고 한다면 a, b의 최대공약수는 a, r의 최대공약수와 같다. 이 성질을 이용해 b를 r로 나눈 나머지 r’을 구하고 다시 r을 r’으로 나눈 나머지를 구하는 과정을 반복해서 나머지가 0이 되었을 때 나누는 수가 a와 b의 최대공약수라고 한다. 최대 공약수를 구하기 위해 a, b(a &gt; b)에 대하여 2부터 b까지 모든 수를 나누는 방법이 있겠으나 수가 커지면 시간이 오래걸린다.하지만 유클리드 호제법은 mod연산을 통해 빠르게 수를 줄여나감으로 기존의 방법보다 효율적이다. wikipedia의 예시를 보자. 79696과 19332의 최대공약수를 구하는 예시다. 78696 ＝ 19332×4 ＋ 136819332 ＝ 1368×14 ＋ 180 1368 ＝ 180×7 ＋ 108 180 ＝ 108×1 ＋ 72 108 ＝ 72×1 ＋ 36 72 ＝ 36×2 ＋ 0따라서, 최대공약수는 36이다. 매우 간결하다. 123int gcd(int a, int b){ return b ? gcd(b, a % b) : a;} 재귀함수는 쓸모가 많다.","link":"/2020/03/24/20200324-etc-math1/"},{"title":"[C++]BOJ 1343 - 폴리오미노","text":"보자마자 스택이 떠올랐다.물론 스택을 사용하지는 않았다.한 글자씩 받아와서 ‘X’ 4개가 쌓일 때, ‘.’을 만날 때, 모두 읽어서 종료됐을 때의 경우에서 최종 str에 추가해주는 방식으로 풀었다.‘.’을 만났을 때와 종료됐을 때 종료조건과 2개가 쌓였을 때 “BB”를 str에 추가한다. 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int c;string str;int main() { char a; for(; scanf(\"%c\", &amp;a), a != 10;) { if(a == 'X'){ c++; } else if(a == '.') { if(c % 2) { cout &lt;&lt; \"-1\"; return 0; } else if(c == 2) { str += \"BB\"; c = 0; } str += '.'; } if(c == 4) { str += \"AAAA\"; c = 0; } } if(c % 2) { cout &lt;&lt; \"-1\"; return 0; } else if(c == 2) { str += \"BB\"; } cout &lt;&lt; str;} 다른 사람들의 풀이를 봤는데 find, replace로 쉽게 풀고 있었다.통수맞은 기분이다.","link":"/2020/03/25/20200325-boj1343/"},{"title":"[C++]BOJ 1969 - DNA","text":"사전순이기 때문에 A, C, G, T 순으로 세로줄에 등장하는 갯수가 제일 많은 뉴클레오타이드로 배치한다.Hamming Distance는 세로줄에서 선택된 뉴클레오타이드를 제외하고 나머지 뉴클레오타이드의 등장횟수를 세면 된다. 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;int n, m, h;int main() { char c[1000][50]; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) cin &gt;&gt; c[i][j]; char ans[50]; for(int i = 0; i &lt; m; i++) { int cnt[20] = {0, }; for(int j = 0; j &lt; n; j++) cnt[c[j][i] - 'A']++; int tmp = 0, idx = 0; for(int j = 0; j &lt; 20; j++) if(tmp &lt; cnt[j]) { tmp = cnt[j]; idx = j; } h += cnt[0] + cnt[2] + cnt[6] + cnt[19]; h -= cnt[idx]; ans[i] = idx + 'A'; } for(int i = 0; i &lt; m; i++) cout &lt;&lt; ans[i]; cout &lt;&lt; endl &lt;&lt; h;}","link":"/2020/03/25/20200325-boj1969/"}],"tags":[{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"BOJ","slug":"BOJ","link":"/tags/BOJ/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"greedy","slug":"greedy","link":"/tags/greedy/"},{"name":"브루트 포스","slug":"브루트-포스","link":"/tags/%EB%B8%8C%EB%A3%A8%ED%8A%B8-%ED%8F%AC%EC%8A%A4/"},{"name":"다이나믹 프로그래밍","slug":"다이나믹-프로그래밍","link":"/tags/%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"name":"study","slug":"study","link":"/tags/study/"},{"name":"project","slug":"project","link":"/tags/project/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"jquery","slug":"jquery","link":"/tags/jquery/"},{"name":"chrome extension","slug":"chrome-extension","link":"/tags/chrome-extension/"},{"name":"theory","slug":"theory","link":"/tags/theory/"},{"name":"sort","slug":"sort","link":"/tags/sort/"},{"name":"Data Structure","slug":"Data-Structure","link":"/tags/Data-Structure/"},{"name":"bfs","slug":"bfs","link":"/tags/bfs/"},{"name":"dfs","slug":"dfs","link":"/tags/dfs/"},{"name":"search","slug":"search","link":"/tags/search/"},{"name":"다익스트라","slug":"다익스트라","link":"/tags/%EB%8B%A4%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%9D%BC/"},{"name":"크루스칼","slug":"크루스칼","link":"/tags/%ED%81%AC%EB%A3%A8%EC%8A%A4%EC%B9%BC/"},{"name":"소수","slug":"소수","link":"/tags/%EC%86%8C%EC%88%98/"},{"name":"heap","slug":"heap","link":"/tags/heap/"},{"name":"gcd","slug":"gcd","link":"/tags/gcd/"}],"categories":[{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"BOJ","slug":"algorithm/BOJ","link":"/categories/algorithm/BOJ/"},{"name":"etc","slug":"etc","link":"/categories/etc/"},{"name":"project","slug":"etc/project","link":"/categories/etc/project/"},{"name":"theory","slug":"algorithm/theory","link":"/categories/algorithm/theory/"},{"name":"math","slug":"etc/math","link":"/categories/etc/math/"}]}
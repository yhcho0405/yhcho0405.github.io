<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>yhcho0405</title>
    <link>https://yhcho0405.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>내가 보려고 쓰는 블로그</description>
    <pubDate>Mon, 06 Apr 2020 15:12:00 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[C++]BOJ 11057 - 오르막 수</title>
      <link>https://yhcho0405.github.io/2020/04/07/20200407-boj11057/</link>
      <guid>https://yhcho0405.github.io/2020/04/07/20200407-boj11057/</guid>
      <pubDate>Mon, 06 Apr 2020 15:12:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;각 자리수 별로 0 ~ 9까지 숫자들의 등장 가능한 빈도를 세면 된다.&lt;br&gt;dp로 풀 수 있고 바로 전 자리수에 자신보다 작거나 같은 수가 얼마나 있는지를 dp[i][j]에 저장해나가면 된다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>각 자리수 별로 0 ~ 9까지 숫자들의 등장 가능한 빈도를 세면 된다.<br>dp로 풀 수 있고 바로 전 자리수에 자신보다 작거나 같은 수가 얼마나 있는지를 dp[i][j]에 저장해나가면 된다.</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, ans, dp[<span class="number">1001</span>][<span class="number">11</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">dp[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = j; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">dp[i][j] += dp[i - <span class="number">1</span>][k];</span><br><span class="line">dp[i][j] %= <span class="number">10007</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">ans += dp[n][i];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans % <span class="number">10007</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/04/07/20200407-boj11057/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 2293 - 동전 1</title>
      <link>https://yhcho0405.github.io/2020/04/06/20200406-boj2293/</link>
      <guid>https://yhcho0405.github.io/2020/04/06/20200406-boj2293/</guid>
      <pubDate>Mon, 06 Apr 2020 05:59:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;dp로 접근해서 풀어야 한다.&lt;br&gt;처음에 생각했던 방법은 dp[i]에 i원을 만들 수 있는 경우의 수를 저장하고, 각 dp[i]에 가지고 있는 동전의 종류(arr[j])원을 뺀 dp[i - arr[j]]를 더해주는 방법으로 풀면 되겠다고 생각했다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>dp로 접근해서 풀어야 한다.<br>처음에 생각했던 방법은 dp[i]에 i원을 만들 수 있는 경우의 수를 저장하고, 각 dp[i]에 가지고 있는 동전의 종류(arr[j])원을 뺀 dp[i - arr[j]]를 더해주는 방법으로 풀면 되겠다고 생각했다.</p><a id="more"></a><p>&lt;예제 1 입력&gt;<br>3 10<br>1<br>2<br>5</p><p>&lt;예제 1 출력&gt;<br>10</p><br><p>막상 실행시켜보니 예제 1의 정답은 10이 나와야 하지만 내 코드는 128을 출력했다.</p><p>코드의 동작 과정을 생각해보면 오류가 보인다.<br><strong>1원을 만들 때의 경우의 수 = 1개 (1)</strong><br><strong>2원을 만들 때의 경우의 수 = 2개 (1, 1 / 2)</strong><br>여기서 내 코드의 논리로는 3원을 만들 때 1원(2원짜리 동전을 가지고 있으므로 3 - 2 = 1원)과 2원(1원짜리 동전을 가지고 있으므로 3 - 1 = 2원)의 경우의 수의 합과 같아야 한다.<br>따라서<br><strong>3원을 만들 때의 경우의 수 = 3개 (1, 2 / 1, 1, 1 / 2, 1)</strong><br>하지만 문제의 조건에서 순서만 다른 것은 같은 경우로 취급하라 했으므로 3원을 만들 때의 경우의 수에 동전의 조합이 중복되는 경우가 발생한다.<br>그래서 실제로 3원을 만들 때의 경우의 수는 2개이다. (1, 2 / 1, 1, 1)<br>아래 코드는 동전의 조합까지 모두 계산하는 결과를 출력한다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, arr[<span class="number">101</span>], dp[<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">dp[arr[i]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; n; a++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i - j == arr[a]) dp[i] += dp[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>물론 위의 코드는 오답처리를 받는다.<br><br></p><p>정답 처리를 받기 위해선 동전의 순서는 고려하지 않고 동전의 조합의 갯수만 출력하도록 작성해야한다.</p><p>그러기 위해 위의 예제의 경우 첫번째 동전만으로 경우의 수를 구하고, 두번째 동전까지 사용해 경우의 수를 구하고, 세번째 동전까지 사용해 경우의 수를 구하는 방법을 사용한다.<br>이 경우는 각각 동전들이 독립적인 결과를 가지므로 중복이 발생하지 않는다.<br>위의 코드와 대체로 유사하지만 dp[i]를 저장할 때 2중 for문에서 i와 j가 바뀐 형태다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, arr[<span class="number">101</span>], dp[<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i] &gt; j) <span class="keyword">continue</span>;</span><br><span class="line">dp[j] += dp[j - arr[i]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 코드가 정답이다.</p>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/04/06/20200406-boj2293/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 1010 - 다리 놓기</title>
      <link>https://yhcho0405.github.io/2020/04/04/20200404-boj1010/</link>
      <guid>https://yhcho0405.github.io/2020/04/04/20200404-boj1010/</guid>
      <pubDate>Sat, 04 Apr 2020 03:35:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;보자마자 떠오른것은 조합이다.&lt;br&gt;mCn을 계산하면 정답이 나오지만 m이 최대 29까지 등장하기 때문에 계산 과정에서 29!을 계산할 여지가 있다.&lt;br&gt;29!은 long long에도 못들어가는 아무튼 엄청 크다.&lt;br&gt;이를 해결하는 방법은 여러가지가 있다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>보자마자 떠오른것은 조합이다.<br>mCn을 계산하면 정답이 나오지만 m이 최대 29까지 등장하기 때문에 계산 과정에서 29!을 계산할 여지가 있다.<br>29!은 long long에도 못들어가는 아무튼 엄청 크다.<br>이를 해결하는 방법은 여러가지가 있다.</p><a id="more"></a><p>먼저 조합의 성질을 보자.<br><strong>nCr</strong>이라면 <strong>n! / {(n - r)! * r!}</strong> 이다.<br>이 때문에 r을 n - r로 바꾸어 계산해도 정답은 일치한다.<br>그렇다면 주어진 범위에서 계산 과정 중 분자의 크기가 가장 커지게 만드는 경우는 <strong>n이 29일 때와 r이 14또는 15일 때</strong> 이다.<br>수식을 약분하면 계산 과정 중 등장할 가장 큰 수인 29!/15!은<br><strong>6,761,440,164,390,912,000</strong><br>이고 long long의 양수 최대범위는<br><strong>9,223,372,036,854,775,807</strong><br>이다.<br><br><br>아슬아슬하게 걸친다.<br>가장 큰 수가 오버플로우가 발생하지 않는다면 주어진 범위 내의 모든 수도 계산하는데 문제가 없을 것이다.</p><p>위 내용을 코드로 나타내면 아래와 같다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> t, n, m, ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t--) &#123;</span><br><span class="line">ans = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">n = n &gt; m - n ? m - n : n; <span class="comment">// m - n과 n중 더 작은것을 사용한다.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">ans *= m - i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">ans /= i;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>또 다른 방법은 조합 계산을 동적 계획법을 이용해 재귀함수로 구현하는 것이다.<br>그 전에 조합 <strong>nCr = n-1Cr-1 + n-1Cr</strong>로 나타낼 수 있다는 것을 알아야 한다.(파스칼의 삼각형으로 부터 유래되었다.)<br>로또로 예를 들어 보면 45개 중 6개를 뽑을 때의 경우의 수는 <strong>1번 공을 미리 뽑고 5개를 랜덤으로 뽑는 경우와 1번 공을 제외하고 6개를 랜덤으로 뽑는 경우를 더한 것</strong>과 같다.<br>저 공식을 사용해 계속 쪼개나가서 n과 r이 같아지거나 r이 0이 될 때 1을 반환하면 된다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, a, b, dp[<span class="number">31</span>][<span class="number">31</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cbn</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n == r || r == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(dp[n][r]) <span class="keyword">return</span> dp[n][r];</span><br><span class="line"><span class="keyword">return</span> dp[n][r] = cbn(n - <span class="number">1</span>, r - <span class="number">1</span>) + cbn(n - <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t--) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cbn(b, a) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/04/04/20200404-boj1010/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 9465 - 스티커</title>
      <link>https://yhcho0405.github.io/2020/04/03/20200403-boj9465/</link>
      <guid>https://yhcho0405.github.io/2020/04/03/20200403-boj9465/</guid>
      <pubDate>Fri, 03 Apr 2020 06:11:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;동적 계획법으로 해결할 수 있다.&lt;br&gt;&lt;img src=&quot;/image-in-post/20200403-boj9465-1.PNG&quot; alt=&quot;먼저 dp00을 선택했을 때&quot;&gt;&lt;br&gt;&lt;img src=&quot;/image-in-post/20200403-boj9465-2.PNG&quot; alt=&quot;dp11을 선택하는 경우와&quot;&gt;&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>동적 계획법으로 해결할 수 있다.<br><img src="/image-in-post/20200403-boj9465-1.PNG" alt="먼저 dp00을 선택했을 때"><br><img src="/image-in-post/20200403-boj9465-2.PNG" alt="dp11을 선택하는 경우와"></p><a id="more"></a><p><img src="/image-in-post/20200403-boj9465-3.PNG" alt="dp12을 선택하는 경우가 있다."><br><img src="/image-in-post/20200403-boj9465-4.PNG" alt="물론 dp02또한 선택할 수는 있지만,"><br><img src="/image-in-post/20200403-boj9465-5.PNG" alt="dp11이 선택됐을 때 경우와 겹치기 때문에 점화식에서는 고려할 필요가 없다."></p><p>따라서 두 번째 사진 처럼 짧은 대각선에 있거나 세 번째 사진처럼 긴 대각선에 있는 경우만 생각해주면 된다.</p><p>위 내용을 코드로 옮기면 아래와 같다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, dp[<span class="number">2</span>][<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t--) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; dp[i][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">dp[<span class="number">0</span>][i] += max(dp[<span class="number">1</span>][i - <span class="number">1</span>], dp[<span class="number">1</span>][i - <span class="number">2</span>]);</span><br><span class="line">dp[<span class="number">1</span>][i] += max(dp[<span class="number">0</span>][i - <span class="number">1</span>], dp[<span class="number">0</span>][i - <span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; max(dp[<span class="number">0</span>][n], max(dp[<span class="number">0</span>][n - <span class="number">1</span>], max(dp[<span class="number">1</span>][n], dp[<span class="number">1</span>][n - <span class="number">1</span>]))) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다른 사람 풀이를 보니 마지막에 dp[0][n]과 dp[1][n]만 비교해도 AC를 받았다.<br>나는 위 설명에서 3번째 사진과 같은 경우 때문에 마지막 4개를 비교했으나 안해도 되는 이유를 생각해봐야겠다.</p>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/04/03/20200403-boj9465/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 14501 - 퇴사</title>
      <link>https://yhcho0405.github.io/2020/04/03/20200403-boj14501/</link>
      <guid>https://yhcho0405.github.io/2020/04/03/20200403-boj14501/</guid>
      <pubDate>Fri, 03 Apr 2020 05:11:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;n이 최대 15이기 때문에 최악의 경우에도 2^15가지의 경우의 수를 가진다.&lt;br&gt;따라서 완전탐색을 해도 문제가 없다.&lt;br&gt;하지만 동적 계획법으로도 해결할 수 있기 때문에 두가지 방법을 다뤄보겠다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>n이 최대 15이기 때문에 최악의 경우에도 2^15가지의 경우의 수를 가진다.<br>따라서 완전탐색을 해도 문제가 없다.<br>하지만 동적 계획법으로도 해결할 수 있기 때문에 두가지 방법을 다뤄보겠다.</p><a id="more"></a><p>먼저 깊이우선탐색을 이용한 방법이다. (이전 금액을 가져와 최종적으로 비교해야 하기 때문에 dfs를 사용한다.)<br>현재 day에서 선택 할지 안 할지를 재귀적으로 호출한다.<br>결과적으로 최종 money를 비교해 ans에 저장한다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, ans, t[<span class="number">16</span>], p[<span class="number">16</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> day, <span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(day &gt; n + <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(day == n + <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(ans &lt; money) ans = money;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">dfs(day + t[day], money + p[day]);</span><br><span class="line">dfs(day + <span class="number">1</span>, money);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t[i] &gt;&gt; p[i];</span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>동적 계획법을 이용한 방법이다.<br>dp[i + t]값 보다 dp[i] + p값이 크다면 dp[i + t]에 dp[i] + p를 넣는다.<br>내일까지 벌 수 있는 최대 금액보다 오늘 벌 수 있는 최대 금액이 더 크다면 내일도 오늘만큼 벌 수 있으므로 dp[i + 1] = dp[i] 한다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, t, p, dp[<span class="number">16</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t &gt;&gt; p;</span><br><span class="line">dp[i + t] = max(dp[i + t], dp[i] + p);</span><br><span class="line">dp[i + <span class="number">1</span>] = max(dp[i + <span class="number">1</span>], dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/04/03/20200403-boj14501/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 11052 - 카드 구매하기</title>
      <link>https://yhcho0405.github.io/2020/03/28/20200328-boj11052/</link>
      <guid>https://yhcho0405.github.io/2020/03/28/20200328-boj11052/</guid>
      <pubDate>Sat, 28 Mar 2020 04:20:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;좀 생각 많이 한 문제다.&lt;br&gt;카드 n개를 구매할 때 최대 금액은 카드 n - j개를 구매할 때의 최대 금액 + 카드 j개가 담겨있는 카드팩의 가격일 것이다.&lt;br&gt;카드팩의 가격은 arr[]에 저장하고 카드 n개를 가장 비싸게 구매할 때 금액을 dp[n]에 저장한다면, 카드 n개를 가장 비싸게 구매할 때 금액은 dp[n], dp[n - 1] + arr[1], dp[n - 2] + arr[2], dp[n - 3] + arr[3]…dp[n - n] + arr[n] 중 가장 큰 값이 된다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>좀 생각 많이 한 문제다.<br>카드 n개를 구매할 때 최대 금액은 카드 n - j개를 구매할 때의 최대 금액 + 카드 j개가 담겨있는 카드팩의 가격일 것이다.<br>카드팩의 가격은 arr[]에 저장하고 카드 n개를 가장 비싸게 구매할 때 금액을 dp[n]에 저장한다면, 카드 n개를 가장 비싸게 구매할 때 금액은 dp[n], dp[n - 1] + arr[1], dp[n - 2] + arr[2], dp[n - 3] + arr[3]…dp[n - n] + arr[n] 중 가장 큰 값이 된다.</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, arr[<span class="number">1001</span>], dp[<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">dp[i] = max(dp[i], dp[i - j] + arr[j]);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/28/20200328-boj11052/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 9461 - 파도반 수열</title>
      <link>https://yhcho0405.github.io/2020/03/28/20200328-boj9461/</link>
      <guid>https://yhcho0405.github.io/2020/03/28/20200328-boj9461/</guid>
      <pubDate>Fri, 27 Mar 2020 18:40:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;문제에서 주어진 그림을 보면 점화식을 세울 수 있다.&lt;br&gt;i번째 삼각형의 변의 길이는 i-1번째 삼각형의 변의 길이 + i - 5번째 삼각형의 변의 길이와 같다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>문제에서 주어진 그림을 보면 점화식을 세울 수 있다.<br>i번째 삼각형의 변의 길이는 i-1번째 삼각형의 변의 길이 + i - 5번째 삼각형의 변의 길이와 같다.</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, m, dp[<span class="number">101</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i &lt; <span class="number">101</span>; i++)</span><br><span class="line">dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; <span class="built_in">cin</span> &gt;&gt; m; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/28/20200328-boj9461/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 10844 - 쉬운 계단 수</title>
      <link>https://yhcho0405.github.io/2020/03/27/20200327-boj10844/</link>
      <guid>https://yhcho0405.github.io/2020/03/27/20200327-boj10844/</guid>
      <pubDate>Fri, 27 Mar 2020 09:10:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;숫자 i 다음 으로 나올 수 있는 수는 i-1과 i+1이다.&lt;br&gt;하지만 0과 9는 다음으로 나올 수 있는 수가 각각 1과 8이다.&lt;br&gt;이 부분에 대해 예외처리를 하려 했으나 dp가 전역으로 정의돼있기 때문에 필요가 없었다.  &lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>숫자 i 다음 으로 나올 수 있는 수는 i-1과 i+1이다.<br>하지만 0과 9는 다음으로 나올 수 있는 수가 각각 1과 8이다.<br>이 부분에 대해 예외처리를 하려 했으나 dp가 전역으로 정의돼있기 때문에 필요가 없었다.  </p><a id="more"></a><p>i번째 자릿수에 나올 수 있는 숫자 j를 2차원 배열 dp에 저장한다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> n, dp[<span class="number">101</span>][<span class="number">11</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">dp[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">dp[i][j] = (dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j + <span class="number">1</span>]) % mod;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">ans += dp[n][i];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/27/20200327-boj10844/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 1912 - 연속합</title>
      <link>https://yhcho0405.github.io/2020/03/27/20200327-boj1912/</link>
      <guid>https://yhcho0405.github.io/2020/03/27/20200327-boj1912/</guid>
      <pubDate>Fri, 27 Mar 2020 07:30:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;합이 가장 큰 연속된 부분집합을 찾는 문제로 dp[i - 1] + i번째 수와 i번째 수 중 큰 것을 dp[i]에 저장한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;dp[i - 1] + i번째 수&lt;/li&gt;
&lt;li&gt;i번째 수&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1번이 더 크다면 dp[i - 1]가 양수고, 2번이 더 크다면 dp[i - 1]가 음수다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>합이 가장 큰 연속된 부분집합을 찾는 문제로 dp[i - 1] + i번째 수와 i번째 수 중 큰 것을 dp[i]에 저장한다.</p><ol><li>dp[i - 1] + i번째 수</li><li>i번째 수</li></ol><p>1번이 더 크다면 dp[i - 1]가 양수고, 2번이 더 크다면 dp[i - 1]가 음수다.</p><a id="more"></a><p>가장 큰 부분합이 마지막 원소를 포함하지 않는다면 마지막 위치에 저장되지 않을 수 있으므로 dp[]를 정렬해서 부분합 중 가장 큰 것을 고른다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, dp[<span class="number">100001</span>] = &#123;<span class="number">-1001</span>, &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; <span class="built_in">cin</span> &gt;&gt; m; i++)</span><br><span class="line">dp[i] = max(dp[i - <span class="number">1</span>] + m, m);</span><br><span class="line">sort(dp, dp + n + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/27/20200327-boj1912/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 2156 - 포도주 시식</title>
      <link>https://yhcho0405.github.io/2020/03/27/20200327-boj2156/</link>
      <guid>https://yhcho0405.github.io/2020/03/27/20200327-boj2156/</guid>
      <pubDate>Thu, 26 Mar 2020 17:50:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;보자 마자 &lt;a href=&quot;https://yhcho0405.github.io/2020/03/27/20200327-boj2579/&quot;&gt;계단 오르기&lt;/a&gt;문제와 똑같다고 생각했지만 계단 오르기는 무조건 마지막 계단을 밟아야 하는 반면, 포도주는 꼭 마지막을 안 마셔도 된다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>보자 마자 <a href="https://yhcho0405.github.io/2020/03/27/20200327-boj2579/">계단 오르기</a>문제와 똑같다고 생각했지만 계단 오르기는 무조건 마지막 계단을 밟아야 하는 반면, 포도주는 꼭 마지막을 안 마셔도 된다.</p><a id="more"></a><p>그래서 계단 오르기 방법에서는 마지막을 포함하도록 한정 지었던 반면에 포도주에선 단순히 dp[i - 1]이 값도 비교하게 하므로써 전에 있던 값이 더 크다면 그 값을 뒤로 밀도록 변경했다.</p><p>그것 말곤 다른것이 없다. (사실 n의 범위가 다르다)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, d[<span class="number">10001</span>], dp[<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; d[i];</span><br><span class="line">dp[<span class="number">1</span>] = d[<span class="number">1</span>];</span><br><span class="line">dp[<span class="number">2</span>] = d[<span class="number">1</span>] + d[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">dp[i] = max(max(d[i - <span class="number">1</span>] + dp[i - <span class="number">3</span>] + d[i], dp[i - <span class="number">1</span>]), dp[i - <span class="number">2</span>] + d[i]);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/27/20200327-boj2156/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 1932 - 정수 삼각형</title>
      <link>https://yhcho0405.github.io/2020/03/27/20200327-boj1932/</link>
      <guid>https://yhcho0405.github.io/2020/03/27/20200327-boj1932/</guid>
      <pubDate>Thu, 26 Mar 2020 17:35:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;삼각형 내부의 모든 지점에 dp를 수행하던 방향에 따라 그 전 층의 자신과 인접한 지점의 값 중 큰 값을 추가한다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>삼각형 내부의 모든 지점에 dp를 수행하던 방향에 따라 그 전 층의 자신과 인접한 지점의 값 중 큰 값을 추가한다.</p><a id="more"></a><p>dp를 위에서 아래로 수행하는 방법과 아래에서 위로 수행하는 경우 두 가지를 가져와봤다.<br>결론은 아래에서 위가 더 효율적이다.</p><h2 id="위에서-아래로"><a href="#위에서-아래로" class="headerlink" title="위에서 아래로"></a>위에서 아래로</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, dp[<span class="number">501</span>][<span class="number">501</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">dp[<span class="number">1</span>][<span class="number">1</span>] = m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line"><span class="keyword">if</span>(j == <span class="number">1</span>) dp[i][j] = dp[i - <span class="number">1</span>][j] + m;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(j == i) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + m;</span><br><span class="line"><span class="keyword">else</span> dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(dp[n] + <span class="number">1</span>, dp[n] + n + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[n][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위에서 아래로 수행할 시 좌우 모서리 부분에 대한 예외처리가 필요하고, 또 마지막 바닥 줄에서 가장 큰 수를 찾아야 하므로 정렬이 필요했다.<br><br><br>하지만 아래에서 위로 수행하면 위의 두가지 단점을 해결해서 코드가 더 간결하다.</p><h2 id="아래에서-위로"><a href="#아래에서-위로" class="headerlink" title="아래에서 위로"></a>아래에서 위로</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">501</span>][<span class="number">501</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; dp[i][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">dp[i<span class="number">-1</span>][j] += max(dp[i][j], dp[i][j+<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>사실 처음에 생각해낸 방법이 위에서 아래로 방법이다.</del></p>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/27/20200327-boj1932/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 2193 - 이친수</title>
      <link>https://yhcho0405.github.io/2020/03/27/20200327-boj2193/</link>
      <guid>https://yhcho0405.github.io/2020/03/27/20200327-boj2193/</guid>
      <pubDate>Thu, 26 Mar 2020 17:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;가능한 경우를 부모노드가 1인 트리로 그려보면 규칙을 파악하기 쉽다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>가능한 경우를 부모노드가 1인 트리로 그려보면 규칙을 파악하기 쉽다.</p><a id="more"></a><p>이 문제도 어째 피보나치와 같은 형태가 되었다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, dp[<span class="number">91</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/27/20200327-boj2193/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 2579 - 계단 오르기</title>
      <link>https://yhcho0405.github.io/2020/03/27/20200327-boj2579/</link>
      <guid>https://yhcho0405.github.io/2020/03/27/20200327-boj2579/</guid>
      <pubDate>Thu, 26 Mar 2020 16:40:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;n번째 계단 까지 얻을 수 있는 최대 점수를 구하기 위해 두 가지 경우를 살펴보겠다.&lt;/p&gt;
&lt;h2 id=&quot;n-1번째-계단을-밟고-왔을-경우&quot;&gt;&lt;a href=&quot;#n-1번째-계단을-밟고-왔을-경우&quot; class=&quot;headerlink&quot; title=&quot;n-1번째 계단을 밟고 왔을 경우&quot;&gt;&lt;/a&gt;n-1번째 계단을 밟고 왔을 경우&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;이 경우는 주어진 조건에 의해 n-2계단을 밟으면 안되므로 무조건 n-3계단을 밟고 와야 한다.&lt;br&gt;따라서 n-3번째 계단 까지 얻을 수 있는 최대 점수 + n-1번 계단의 점수 + n번 계단의 점수가 n번째 계단까지 얻을 수 있는 최대 점수가 된다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>n번째 계단 까지 얻을 수 있는 최대 점수를 구하기 위해 두 가지 경우를 살펴보겠다.</p><h2 id="n-1번째-계단을-밟고-왔을-경우"><a href="#n-1번째-계단을-밟고-왔을-경우" class="headerlink" title="n-1번째 계단을 밟고 왔을 경우"></a>n-1번째 계단을 밟고 왔을 경우</h2><hr><p>이 경우는 주어진 조건에 의해 n-2계단을 밟으면 안되므로 무조건 n-3계단을 밟고 와야 한다.<br>따라서 n-3번째 계단 까지 얻을 수 있는 최대 점수 + n-1번 계단의 점수 + n번 계단의 점수가 n번째 계단까지 얻을 수 있는 최대 점수가 된다.</p><a id="more"></a><h2 id="n-2번째-계단을-밟고-왔을-경우"><a href="#n-2번째-계단을-밟고-왔을-경우" class="headerlink" title="n-2번째 계단을 밟고 왔을 경우"></a>n-2번째 계단을 밟고 왔을 경우</h2><hr><p>위의 상황보단 간단하다.<br>n-2계단 전에 n-3계단을 밟고 와도 문제가 없고 n-4계단을 밟고 왔어도 조건에 어긋나지 않는다.<br>따라서 n-2번째 계단 까지 얻을 수 있는 최대 점수 + n번 계단의 점수가 n번째 계단까지 얻을 수 있는 최대 점수가 된다.</p><br><p>위 두 경우 중 더 큰 값이 정답이다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, d[<span class="number">301</span>], dp[<span class="number">301</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; d[i];</span><br><span class="line">dp[<span class="number">1</span>] = d[<span class="number">1</span>];</span><br><span class="line">dp[<span class="number">2</span>] = d[<span class="number">1</span>] + d[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">dp[i] = max(d[i - <span class="number">1</span>] + dp[i - <span class="number">3</span>], dp[i - <span class="number">2</span>]) + d[i];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/27/20200327-boj2579/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 1149 - RGB거리</title>
      <link>https://yhcho0405.github.io/2020/03/27/20200327-boj1149/</link>
      <guid>https://yhcho0405.github.io/2020/03/27/20200327-boj1149/</guid>
      <pubDate>Thu, 26 Mar 2020 15:52:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;규칙이 헷갈리는데 요약하면 같은 색인 집이 연속되면 안 된다고 정리할 수 있다.&lt;br&gt;따라서 색(r, g, b)별로 n번째 집까지 색을 칠하는 비용의 최소값은 n - 1번째 집까지의 비용에서 현재 집의 색을 제외한 나머지 색 중 최소값이 될 것이다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>규칙이 헷갈리는데 요약하면 같은 색인 집이 연속되면 안 된다고 정리할 수 있다.<br>따라서 색(r, g, b)별로 n번째 집까지 색을 칠하는 비용의 최소값은 n - 1번째 집까지의 비용에서 현재 집의 색을 제외한 나머지 색 중 최소값이 될 것이다.</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, r, g, b, dp[<span class="number">1001</span>][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; r &gt;&gt; g &gt;&gt; b;</span><br><span class="line">dp[i][<span class="number">0</span>] = min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]) + r;</span><br><span class="line">dp[i][<span class="number">1</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]) + g;</span><br><span class="line">dp[i][<span class="number">2</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]) + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; min(min(dp[n][<span class="number">0</span>], dp[n][<span class="number">1</span>]), dp[n][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/27/20200327-boj1149/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 11726 - 2×n 타일링</title>
      <link>https://yhcho0405.github.io/2020/03/27/20200327-boj11726/</link>
      <guid>https://yhcho0405.github.io/2020/03/27/20200327-boj11726/</guid>
      <pubDate>Thu, 26 Mar 2020 15:40:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;2n 크기의 직사각형은 2(n-1)크기의 직사각형에서 세로로 길쭉한 블럭 하나를 추가한 것과 같고 2(n-2)크기의 직사각형에서 가로로 길쭉한 블럭 두개를 쌓아서 추가하는 경우와 같다.&lt;br&gt;2(n-2)크기의 직사각형 역시 세로로 길쭉한 블럭을 두개 추가하면 2n크기인 직사각형이 되지만, 2(n-1)와 겹치는 경우가 발생하기에 제외한다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>2n 크기의 직사각형은 2(n-1)크기의 직사각형에서 세로로 길쭉한 블럭 하나를 추가한 것과 같고 2(n-2)크기의 직사각형에서 가로로 길쭉한 블럭 두개를 쌓아서 추가하는 경우와 같다.<br>2(n-2)크기의 직사각형 역시 세로로 길쭉한 블럭을 두개 추가하면 2n크기인 직사각형이 되지만, 2(n-1)와 겹치는 경우가 발생하기에 제외한다.</p><a id="more"></a><p>어째 피보나치와 같은 형태가 되었다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, dp[<span class="number">1001</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    dp[i] %= <span class="number">10007</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/27/20200327-boj11726/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 1003 - 피보나치 함수</title>
      <link>https://yhcho0405.github.io/2020/03/26/20200326-boj1003/</link>
      <guid>https://yhcho0405.github.io/2020/03/26/20200326-boj1003/</guid>
      <pubDate>Thu, 26 Mar 2020 08:30:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;시간 제한이 0.25초로 걸려있는 것이 정직하게 피보나치 돌리면 시간 초과가 뜬다는 것을 암시한 것인가.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>시간 제한이 0.25초로 걸려있는 것이 정직하게 피보나치 돌리면 시간 초과가 뜬다는 것을 암시한 것인가.</p><a id="more"></a><p>n번째 피보나치를 구한다 생각하고 트리를 그려보면 매우 쉬워진다.<br>예를 들어 n번째 피보나치 수열을 구하는 트리에서 n + 1번째 피보나치 수열을 구하는 트리를 그린다 가정하면, 기존의 n이 부모인 트리에서 n + 1을 부모 노드로 추가하고 n - 1의 부분 트리가 하나 더 생긴다.<br>이것을 n + 1을 n으로 치환해서 읽어보면 n의 부모 노드에 n - 1과 n - 2의 자식 노드가 연결된 형태이다.<br>이 생각을 중심으로 0과 1 각각 갯수를 세어주면 된다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f1[<span class="number">41</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, f0[<span class="number">41</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, t, n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">41</span>; i++) &#123;</span><br><span class="line">f1[i] = f1[i - <span class="number">1</span>] + f1[i - <span class="number">2</span>];</span><br><span class="line">f0[i] = f0[i - <span class="number">1</span>] + f0[i - <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t &amp;&amp; <span class="built_in">cin</span> &gt;&gt; n; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f0[n] &lt;&lt; <span class="string">" "</span> &lt;&lt; f1[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/26/20200326-boj1003/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 9095 - 1, 2, 3 더하기</title>
      <link>https://yhcho0405.github.io/2020/03/26/20200326-boj9095/</link>
      <guid>https://yhcho0405.github.io/2020/03/26/20200326-boj9095/</guid>
      <pubDate>Thu, 26 Mar 2020 08:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;dp[i]에는 정수 i를 1, 2, 3의 합으로 나타내는 방법의 수가 담겨있다.&lt;br&gt;그래서 정수 5를 1, 2, 3의 합으로 나타내는 방법의 수가 궁금하다면, dp[2] + dp[3] + dp[4]가 될 것이다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>dp[i]에는 정수 i를 1, 2, 3의 합으로 나타내는 방법의 수가 담겨있다.<br>그래서 정수 5를 1, 2, 3의 합으로 나타내는 방법의 수가 궁금하다면, dp[2] + dp[3] + dp[4]가 될 것이다.</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">12</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>; i &lt; <span class="number">12</span>; i++)</span><br><span class="line">dp[i] = dp[i - <span class="number">3</span>] + dp[i - <span class="number">2</span>] + dp[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/26/20200326-boj9095/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 1463 - 1로 만들기</title>
      <link>https://yhcho0405.github.io/2020/03/26/20200326-boj1463/</link>
      <guid>https://yhcho0405.github.io/2020/03/26/20200326-boj1463/</guid>
      <pubDate>Thu, 26 Mar 2020 07:37:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;크게 두 가지 경우의 수가 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;3로 나누어 떨어질 경우&lt;/li&gt;
&lt;li&gt;3으로 나누어 떨어질 경우&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;3번 조건은 언제나 적용할 수 있기 때문에 처음부터 계산하고 시작한다.&lt;br&gt;2와 3의 공배수 같은 경우는 2와 3 둘 다 나누어 떨어지기 때문에 다른 조건을 만들어야 하나 싶었지만 어차피 dp[]에 저장된 값을 같은 i를 돌고 있을 때 다시 확인하므로 상관이 없다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>크게 두 가지 경우의 수가 있다.</p><ol><li>3로 나누어 떨어질 경우</li><li>3으로 나누어 떨어질 경우</li></ol><p>3번 조건은 언제나 적용할 수 있기 때문에 처음부터 계산하고 시작한다.<br>2와 3의 공배수 같은 경우는 2와 3 둘 다 나누어 떨어지기 때문에 다른 조건을 만들어야 하나 싶었지만 어차피 dp[]에 저장된 값을 같은 i를 돌고 있을 때 다시 확인하므로 상관이 없다.</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1000001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">dp[i] = dp[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>) dp[i] = min(dp[i/<span class="number">2</span>]+<span class="number">1</span>, dp[i]);</span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">0</span>) dp[i] = min(dp[i/<span class="number">3</span>]+<span class="number">1</span>, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/26/20200326-boj1463/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 1041 - 주사위</title>
      <link>https://yhcho0405.github.io/2020/03/25/20200325-boj1041/</link>
      <guid>https://yhcho0405.github.io/2020/03/25/20200325-boj1041/</guid>
      <pubDate>Wed, 25 Mar 2020 10:05:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;우선 한 면이 바닥에 가려져 있으므로 총 5n^2만큼의 면을 볼 수 있다.&lt;br&gt;그 중 3면이 보이는 주사위는 윗쪽 꼭지점 4개, 2면이 보이는 주사위는 눈에 보이는 모서리 8개와 아랫쪽 꼭지점 4개, 1면이 보이는 주사위는 5n^2 - (3 * 3면이 보이는 주사위의 수) - (2 * 2면이 보이는 주사위의 수) 이다.&lt;br&gt;이를 식으로 나타내면,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;3 면 == 4 개&lt;br&gt;2 면 == 8n  - 12 개&lt;br&gt;1 면 == 5n^2 - 16n + 12 개&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;로 정리할 수 있다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>우선 한 면이 바닥에 가려져 있으므로 총 5n^2만큼의 면을 볼 수 있다.<br>그 중 3면이 보이는 주사위는 윗쪽 꼭지점 4개, 2면이 보이는 주사위는 눈에 보이는 모서리 8개와 아랫쪽 꼭지점 4개, 1면이 보이는 주사위는 5n^2 - (3 * 3면이 보이는 주사위의 수) - (2 * 2면이 보이는 주사위의 수) 이다.<br>이를 식으로 나타내면,</p><blockquote><p>3 면 == 4 개<br>2 면 == 8n  - 12 개<br>1 면 == 5n^2 - 16n + 12 개</p></blockquote><p>로 정리할 수 있다.</p><a id="more"></a><p>그리고 3면과 2면을 고를 때 단순히 주사위 면 중 숫자가 작은 면을 골라내면 문제가 발생하기 때문에 서로 이어진 면들을 선택해야 한다.</p><blockquote><p>3면이 보이는 경우 == 마주보는 3쌍의 면들 중 각 쌍에서 작은 면을 고른다.<br>2면이 보이는 경우 == 마주보는 면을 제외하고 모든 경우의 합(12개)을 저장하고 가장 작은 값을 이용한다.</p></blockquote><p>마지막으로 주사위가 하나일 경우 예외처리를 해준다.  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, d[<span class="number">6</span>], v3, v[<span class="number">12</span>], v2, cnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; d[i];</span><br><span class="line">v3 = min(d[<span class="number">0</span>], d[<span class="number">5</span>]) + min(d[<span class="number">2</span>], d[<span class="number">3</span>]) + min(d[<span class="number">1</span>], d[<span class="number">4</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>((i==<span class="number">0</span>&amp;&amp;j==<span class="number">5</span>)||(i==<span class="number">2</span>&amp;&amp;j==<span class="number">3</span>)||(i==<span class="number">1</span>&amp;&amp;j==<span class="number">4</span>)) <span class="keyword">continue</span>;</span><br><span class="line">v[cnt++] = d[i] + d[j];</span><br><span class="line">&#125;</span><br><span class="line">sort(v, v + <span class="number">12</span>);</span><br><span class="line">sort(d, d + <span class="number">6</span>);</span><br><span class="line">v2 = v[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d[<span class="number">0</span>] + d[<span class="number">1</span>] + d[<span class="number">2</span>] + d[<span class="number">3</span>] + d[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v3 * <span class="number">4</span> + v2 * (<span class="number">8</span> * n - <span class="number">12</span>) + d[<span class="number">0</span>] * (<span class="number">5</span> * (n * n) - <span class="number">16</span> * n + <span class="number">12</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/25/20200325-boj1041/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 1969 - DNA</title>
      <link>https://yhcho0405.github.io/2020/03/25/20200325-boj1969/</link>
      <guid>https://yhcho0405.github.io/2020/03/25/20200325-boj1969/</guid>
      <pubDate>Wed, 25 Mar 2020 05:59:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;사전순이기 때문에 A, C, G, T 순으로 세로줄에 등장하는 갯수가 제일 많은 뉴클레오타이드로 배치한다.&lt;br&gt;Hamming Distance는 세로줄에서 선택된 뉴클레오타이드를 제외하고 나머지 뉴클레오타이드의 등장횟수를 세면 된다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>사전순이기 때문에 A, C, G, T 순으로 세로줄에 등장하는 갯수가 제일 많은 뉴클레오타이드로 배치한다.<br>Hamming Distance는 세로줄에서 선택된 뉴클레오타이드를 제외하고 나머지 뉴클레오타이드의 등장횟수를 세면 된다.</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, h;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> c[<span class="number">1000</span>][<span class="number">50</span>];</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; c[i][j];</span><br><span class="line"><span class="keyword">char</span> ans[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">20</span>] = &#123;<span class="number">0</span>, &#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">cnt[c[j][i] - <span class="string">'A'</span>]++;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>, idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++)</span><br><span class="line"><span class="keyword">if</span>(tmp &lt; cnt[j]) &#123;</span><br><span class="line">tmp = cnt[j];</span><br><span class="line">idx = j;</span><br><span class="line">&#125;</span><br><span class="line">h += cnt[<span class="number">0</span>] + cnt[<span class="number">2</span>] + cnt[<span class="number">6</span>] + cnt[<span class="number">19</span>];</span><br><span class="line">h -= cnt[idx];</span><br><span class="line">ans[i] = idx + <span class="string">'A'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans[i];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/25/20200325-boj1969/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>

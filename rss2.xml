<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>yhcho0405</title>
    <link>https://yhcho0405.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>내가 보려고 쓰는 블로그</description>
    <pubDate>Wed, 15 Apr 2020 13:50:00 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>파이썬 - 네이버 영화 크롤링</title>
      <link>https://yhcho0405.github.io/2020/04/15/20200415-python-movie-crawling/</link>
      <guid>https://yhcho0405.github.io/2020/04/15/20200415-python-movie-crawling/</guid>
      <pubDate>Wed, 15 Apr 2020 13:50:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;네이버 영화 페이지에서 현재 상영중인 영화와 정보들을 가져오고 각 영화에 달린 댓글들도 가져오는 파이썬 크롤러를 만들어 봤다.&lt;br&gt;모듈은 requests와 beautifulsoup4를 사용했다.&lt;br&gt;requests로 HTTP요청을 보내고 beautifulsoup4는 html구문을 분석할 때 사용했다.&lt;br&gt;마지막으로 크롤링이 끝난 후 csv형식으로 내보낸다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>네이버 영화 페이지에서 현재 상영중인 영화와 정보들을 가져오고 각 영화에 달린 댓글들도 가져오는 파이썬 크롤러를 만들어 봤다.<br>모듈은 requests와 beautifulsoup4를 사용했다.<br>requests로 HTTP요청을 보내고 beautifulsoup4는 html구문을 분석할 때 사용했다.<br>마지막으로 크롤링이 끝난 후 csv형식으로 내보낸다.</p><a id="more"></a><p><strong><em>내용 추가 예정</em></strong></p><blockquote><p><a href="https://docs.google.com/spreadsheets/d/19u8H0vsYq4FNuS_yd3jA89wlkTdBUtSbmP7zmMYeVz0/edit?usp=sharing" rel="external nofollow noopener noreferrer" target="_blank">크롤링 결과 csv파일</a></p></blockquote><blockquote><p><a href="https://test.yhcho0405.repl.run" rel="external nofollow noopener noreferrer" target="_blank">이 링크를 통해 repl.it에서 가상으로 테스트 할 수 있다.</a></p></blockquote><blockquote><p><a href="https://github.com/yhcho0405/python_movie_crawling" rel="external nofollow noopener noreferrer" target="_blank">소스코드</a></p></blockquote><br><p>####2020년 4월 21일<br>너무 허전해보여서 flask로 웹에서 돌아가게 만들어 보았다.</p><blockquote><p><a href="https://scrapper.yhcho0405.repl.co" rel="external nofollow noopener noreferrer" target="_blank">역시나 repl.it의 서버를 사용하기 때문에 크롤링 속도가 굉장히 느리다.</a><br>page 값으로 0을 넣으면 빠른 결과를 얻을 수 있다.<br>대신 댓글은 가져오지 못한다.</p></blockquote>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/04/15/20200415-python-movie-crawling/#disqus_thread</comments>
    </item>
    
    <item>
      <title>파이썬 문법 사전 - if, for, 함수</title>
      <link>https://yhcho0405.github.io/2020/04/13/20200413-python2/</link>
      <guid>https://yhcho0405.github.io/2020/04/13/20200413-python2/</guid>
      <pubDate>Mon, 13 Apr 2020 11:18:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;if문&quot;&gt;&lt;a href=&quot;#if문&quot; class=&quot;headerlink&quot; title=&quot;if문&quot;&gt;&lt;/a&gt;if문&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;if 후에 여러개의 elif가 있을 수 있고 else는 선택적으로 사용할 수 있다.&lt;/p&gt;
&lt;figure class=&quot;highlight py&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;x = int(input(&lt;span class=&quot;string&quot;&gt;&quot;Please enter an integer: &quot;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Please enter an integer: &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; x &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;... &lt;/span&gt;    x = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;... &lt;/span&gt;    print(&lt;span class=&quot;string&quot;&gt;&#39;Negative changed to zero&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;... &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; x == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;... &lt;/span&gt;    print(&lt;span class=&quot;string&quot;&gt;&#39;Zero&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;... &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; x == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;... &lt;/span&gt;    print(&lt;span class=&quot;string&quot;&gt;&#39;Single&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;... &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;... &lt;/span&gt;    print(&lt;span class=&quot;string&quot;&gt;&#39;More&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;More&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="if문"><a href="#if문" class="headerlink" title="if문"></a>if문</h2><hr><p>if 후에 여러개의 elif가 있을 수 있고 else는 선택적으로 사용할 수 있다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = int(input(<span class="string">"Please enter an integer: "</span>))</span><br><span class="line">Please enter an integer: <span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>    x = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Negative changed to zero'</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">elif</span> x == <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Zero'</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">elif</span> x == <span class="number">1</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Single'</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'More'</span>)</span><br><span class="line">...</span><br><span class="line">More</span><br></pre></td></tr></table></figure><a id="more"></a><br><h2 id="for문"><a href="#for문" class="headerlink" title="for문"></a>for문</h2><hr><p>파이썬에서 for문은 임의의 시퀀스(리스트나 문자열)의 항목들을 순서대로 이터레이션 할 수 있다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Measure some strings:</span></span><br><span class="line"><span class="meta">... </span>words = [<span class="string">'cat'</span>, <span class="string">'window'</span>, <span class="string">'defenestrate'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line"><span class="meta">... </span>    print(w, len(w))</span><br><span class="line">...</span><br><span class="line">cat <span class="number">3</span></span><br><span class="line">window <span class="number">6</span></span><br><span class="line">defenestrate <span class="number">12</span></span><br></pre></td></tr></table></figure><p>시퀀스를 이터레이트 하는 동안 시퀀스를 수정하는 것은 원래의 의도대로 동작하지 않을 수도 있다.<br>이 경우 보통 복사본을 만드는 방법을 사용한다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Strategy:  Iterate over a copy</span></span><br><span class="line"><span class="keyword">for</span> user, status <span class="keyword">in</span> users.copy().items():</span><br><span class="line">    <span class="keyword">if</span> status == <span class="string">'inactive'</span>:</span><br><span class="line">        <span class="keyword">del</span> users[user]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Strategy:  Create a new collection</span></span><br><span class="line">active_users = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> user, status <span class="keyword">in</span> users.items():</span><br><span class="line">    <span class="keyword">if</span> status == <span class="string">'active'</span>:</span><br><span class="line">        active_users[user] = status</span><br></pre></td></tr></table></figure><br><h3 id="range-함수"><a href="#range-함수" class="headerlink" title="range() 함수"></a>range() 함수</h3><hr><p>숫자들의 시퀀스로 이터레이트 해야 할 때 range()를 사용하면 편리하다. range()는 수열을 만든다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">'Mary'</span>, <span class="string">'had'</span>, <span class="string">'a'</span>, <span class="string">'little'</span>, <span class="string">'lamb'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line"><span class="meta">... </span>    print(i, a[i])</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> Mary</span><br><span class="line"><span class="number">1</span> had</span><br><span class="line"><span class="number">2</span> a</span><br><span class="line"><span class="number">3</span> little</span><br><span class="line"><span class="number">4</span> lamb</span><br></pre></td></tr></table></figure><p>주의해야 할 점은 range()는 리스트 처럼 동작하지만 리스트가 아니라는 점이다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(range(<span class="number">10</span>))</span><br><span class="line">range(<span class="number">0</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>이처럼 리스트를 출력하지 않는다.<br>이터레이트할 때 원하는 시퀀스 항목들을 순서대로 돌려주는 객체이지만, 실제로 리스트를 만들지 않아서 공간을 절약한다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum(range(<span class="number">4</span>))  <span class="comment"># 0 + 1 + 2 + 3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(<span class="number">4</span>))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>이런것도 가능하다.</p><br><h3 id="break-continue-for-else문"><a href="#break-continue-for-else문" class="headerlink" title="break, continue, for-else문"></a>break, continue, for-else문</h3><hr><p>break문은 가장 가까이 둘러싸는 반복문을 빠져나가게 만든다.</p><p>특이하게 파이썬에서 루프문은 else를 가질 수 있다.<br>루프가 이터러블 소진이나 조건이 거짓이 돼서 종료할 때 실행된다. 단, 루프가 break문으로 종료될 때는 실행되지 않는다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> n % x == <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>            print(n, <span class="string">'equals'</span>, x, <span class="string">'*'</span>, n//x)</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">break</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="comment"># loop fell through without finding a factor</span></span><br><span class="line"><span class="meta">... </span>        print(n, <span class="string">'is a prime number'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="number">2</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">3</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">4</span> equals <span class="number">2</span> * <span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">6</span> equals <span class="number">2</span> * <span class="number">3</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">8</span> equals <span class="number">2</span> * <span class="number">4</span></span><br><span class="line"><span class="number">9</span> equals <span class="number">3</span> * <span class="number">3</span></span><br></pre></td></tr></table></figure><p>continue는 루프의 다음 이터레이션에서 계속 실행하도록 만든다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"Found an even number"</span>, num)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">continue</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"Found a number"</span>, num)</span><br><span class="line">Found an even number <span class="number">2</span></span><br><span class="line">Found a number <span class="number">3</span></span><br><span class="line">Found an even number <span class="number">4</span></span><br><span class="line">Found a number <span class="number">5</span></span><br><span class="line">Found an even number <span class="number">6</span></span><br><span class="line">Found a number <span class="number">7</span></span><br><span class="line">Found an even number <span class="number">8</span></span><br><span class="line">Found a number <span class="number">9</span></span><br></pre></td></tr></table></figure><br><h3 id="pass문"><a href="#pass문" class="headerlink" title="pass문"></a>pass문</h3><hr><p>아무것도 하지 않는다.<br>문법적으로 문장이 필요하지만 특별히 할 일이 없을 때 사용한다.<br>ex) 최소한의 클래스를 만들 때</p><h2 id="함수-정의"><a href="#함수-정의" class="headerlink" title="함수 정의"></a>함수 정의</h2><hr><p>def를 이용해서 함수를 정의한다.<br>함수 이름과 괄호로 싸인 매개변수들의 목록이 뒤따른다.<br>함수 내부 문장들은 반드시 들여쓰기 해야 한다.<br>“””독스트링””” 은 함수 바디의 첫번째 문장으로 사용해 함수에 대한 설명으로 사용할 수 있다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span>    <span class="comment"># write Fibonacci series up to n</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">"""Print a Fibonacci series up to n."""</span></span><br><span class="line"><span class="meta">... </span>    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> a &lt; n:</span><br><span class="line"><span class="meta">... </span>        print(a, end=<span class="string">' '</span>)</span><br><span class="line"><span class="meta">... </span>        a, b = b, a+b</span><br><span class="line"><span class="meta">... </span>    print()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Now call the function we just defined:</span></span><br><span class="line"><span class="meta">... </span>fib(<span class="number">2000</span>)</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span> <span class="number">610</span> <span class="number">987</span> <span class="number">1597</span></span><br></pre></td></tr></table></figure><h3 id="기본-인자-값"><a href="#기본-인자-값" class="headerlink" title="기본 인자 값"></a>기본 인자 값</h3><p>하나 이상의 인자들에 기본값을 지정하여 정의된 것보다 더 적은 개수의 인자들로 호출될 수 있는 함수를 만든다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ask_ok</span><span class="params">(prompt, retries=<span class="number">4</span>, reminder=<span class="string">'Please try again!'</span>)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ok = input(prompt)</span><br><span class="line">        <span class="keyword">if</span> ok <span class="keyword">in</span> (<span class="string">'y'</span>, <span class="string">'ye'</span>, <span class="string">'yes'</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> ok <span class="keyword">in</span> (<span class="string">'n'</span>, <span class="string">'no'</span>, <span class="string">'nop'</span>, <span class="string">'nope'</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        retries = retries - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> retries &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'invalid user response'</span>)</span><br><span class="line">        print(reminder)</span><br></pre></td></tr></table></figure><blockquote><p><strong>Reference</strong><br><a href="python.org">python.org</a></p></blockquote><p><em>이 게시물은 파이썬 문법을 까먹었을 때 검색하려고 작성됨.</em></p>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/04/13/20200413-python2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>파이썬 문법 사전 - 숫자, 문자열, 리스트</title>
      <link>https://yhcho0405.github.io/2020/04/12/20200412-python1/</link>
      <guid>https://yhcho0405.github.io/2020/04/12/20200412-python1/</guid>
      <pubDate>Sun, 12 Apr 2020 08:41:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;숫자&quot;&gt;&lt;a href=&quot;#숫자&quot; class=&quot;headerlink&quot; title=&quot;숫자&quot;&gt;&lt;/a&gt;숫자&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;+, -, *, / 같이 사칙연산 연산자를 사용할 수 있다.&lt;br&gt;괄호는 연산의 우선순위를 정할 때 사용한다.&lt;/p&gt;
&lt;figure class=&quot;highlight py&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt; - &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt; - &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;) / &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;5.0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt; / &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;# division always returns a floating point number&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1.6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="숫자"><a href="#숫자" class="headerlink" title="숫자"></a>숫자</h2><hr><p>+, -, *, / 같이 사칙연산 연산자를 사용할 수 있다.<br>괄호는 연산의 우선순위를 정할 때 사용한다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> + <span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">50</span> - <span class="number">5</span>*<span class="number">6</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">50</span> - <span class="number">5</span>*<span class="number">6</span>) / <span class="number">4</span></span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">8</span> / <span class="number">5</span>  <span class="comment"># division always returns a floating point number</span></span><br><span class="line"><span class="number">1.6</span></span><br></pre></td></tr></table></figure><a id="more"></a><br><p>나눗셈은 항상 float을 리턴한다.<br>정수 나눗셈으로 정수 결과를 얻으려면 // 을 사용하면 된다.<br>나머지 연산에서는 %을 사용한다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">17</span> / <span class="number">3</span>  <span class="comment"># classic division returns a float</span></span><br><span class="line"><span class="number">5.666666666666667</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">17</span> // <span class="number">3</span>  <span class="comment"># floor division discards the fractional part</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">17</span> % <span class="number">3</span>  <span class="comment"># the % operator returns the remainder of the division</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> * <span class="number">3</span> + <span class="number">2</span>  <span class="comment"># result * divisor + remainder</span></span><br><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure><br><p>거듭제곱은 **을 사용한다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> ** <span class="number">2</span>  <span class="comment"># 5 squared</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> ** <span class="number">7</span>  <span class="comment"># 2 to the power of 7</span></span><br><span class="line"><span class="number">128</span></span><br></pre></td></tr></table></figure><p>변수를 값에 대입할 때는 등호 =를 사용한다.</p><br><h2 id="문자열"><a href="#문자열" class="headerlink" title="문자열"></a>문자열</h2><hr><p>파이썬에서 문자열은 ‘작은따옴표’나 “큰따옴표”로 둘러쌀 수 있고 둘다 같은 결과를 가져온다.<br>따옴표를 이스케이핑 하는 방법은 \를 사용하면 된다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'spam eggs'</span>  <span class="comment"># single quotes</span></span><br><span class="line"><span class="string">'spam eggs'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'doesn\'t'</span>  <span class="comment"># use \' to escape the single quote...</span></span><br><span class="line"><span class="string">"doesn't"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"doesn't"</span>  <span class="comment"># ...or use double quotes instead</span></span><br><span class="line"><span class="string">"doesn't"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'"Yes," they said.'</span></span><br><span class="line"><span class="string">'"Yes," they said.'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"\"Yes,\" they said."</span></span><br><span class="line"><span class="string">'"Yes," they said.'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'"Isn\'t," they said.'</span></span><br><span class="line"><span class="string">'"Isn\'t," they said.'</span></span><br></pre></td></tr></table></figure><br><p>print()를 사용할 때 \뒤의 문자가 특수문자로 취급되게 하고 싶지 않다면, 첫 따옴표 앞에 r을 붙여서 raw string을 만들 수 있다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'C:\some\name'</span>)  <span class="comment"># here \n means newline!</span></span><br><span class="line">C:\some</span><br><span class="line">ame</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">r'C:\some\name'</span>)  <span class="comment"># note the r before the quote</span></span><br><span class="line">C:\some\name</span><br></pre></td></tr></table></figure><p>삼중따옴표 “””, ‘’’를 통해 줄넘김 문자를 자동으로 문자열에 포함 할 수도 있다. 줄 끝에 \를 붙여 이를 무시할 수도 있다.<br>또 연산자를 이어 붙이기도 가능하다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"""\</span></span><br><span class="line"><span class="string">    Usage: thingy [OPTIONS]</span></span><br><span class="line"><span class="string">         -h                        Display this usage message</span></span><br><span class="line"><span class="string">         -H hostname               Hostname to connect to</span></span><br><span class="line"><span class="string">    """</span>)    </span><br><span class="line">Usage: thingy [OPTIONS]</span><br><span class="line">     -h                        Display this usage message</span><br><span class="line">     -H hostname  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 3 times 'un', followed by 'ium'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> * <span class="string">'un'</span> + <span class="string">'ium'</span></span><br><span class="line"><span class="string">'unununium'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Py'</span> <span class="string">'thon'</span></span><br><span class="line"><span class="string">'Python'</span></span><br></pre></td></tr></table></figure><br>문자열은 인덱스 될 수 있다. 첫 번째 문자가 인덱스 0에 대응된다.인덱스는 음수가 될 수도 있다.<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word = <span class="string">'Python'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">0</span>]  <span class="comment"># character in position 0</span></span><br><span class="line"><span class="string">'P'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">5</span>]  <span class="comment"># character in position 5</span></span><br><span class="line"><span class="string">'n'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">-1</span>]  <span class="comment"># last character</span></span><br><span class="line"><span class="string">'n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">-2</span>]  <span class="comment"># second-last character</span></span><br><span class="line"><span class="string">'o'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">-6</span>]</span><br><span class="line"><span class="string">'P'</span></span><br></pre></td></tr></table></figure><p>슬라이싱도 지원한다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">0</span>:<span class="number">2</span>]  <span class="comment"># characters from position 0 (included) to 2 (excluded)</span></span><br><span class="line"><span class="string">'Py'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">2</span>:<span class="number">5</span>]  <span class="comment"># characters from position 2 (included) to 5 (excluded)</span></span><br><span class="line"><span class="string">'tho'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[:<span class="number">2</span>] + word[<span class="number">2</span>:]</span><br><span class="line"><span class="string">'Python'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[:<span class="number">4</span>] + word[<span class="number">4</span>:]</span><br><span class="line"><span class="string">'Python'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[:<span class="number">2</span>]   <span class="comment"># character from the beginning to position 2 (excluded)</span></span><br><span class="line"><span class="string">'Py'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">4</span>:]   <span class="comment"># characters from position 4 (included) to the end</span></span><br><span class="line"><span class="string">'on'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">-2</span>:]  <span class="comment"># characters from the second-last (included) to the end</span></span><br><span class="line"><span class="string">'on'</span></span><br></pre></td></tr></table></figure><p>이렇게 보면 이해하기 쉽다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+---+---+---+---+---+---+</span><br><span class="line">| P | y | t | h | o | n |</span><br><span class="line">+---+---+---+---+---+---+</span><br><span class="line">0   1   2   3   4   5   6</span><br><span class="line">-6  -5  -4  -3  -2  -1</span><br></pre></td></tr></table></figure><p>범위 밖의 값을 인덱스로 사용하면 오류가 나지만 슬라이싱을 할 때는 부드럽게 처리된다.</p><p>파이썬의 문자열은 변경할 수 없다. 그래서 특정 인덱스의 값을 바꾸려 할 때는 에러가 난다. 만약 꼭 바꿔야한다면 새 문자열을 만들어야 한다.</p><br>내장함수 len()은 문자열의 길이를 반환한다.<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'supercalifragilisticexpialidocious'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(s)</span><br><span class="line"><span class="number">34</span></span><br></pre></td></tr></table></figure><br><h2 id="리스트"><a href="#리스트" class="headerlink" title="리스트"></a>리스트</h2><hr><p>대괄호 사이에 쉼표로 구분된 항목들의 목록으로 표현된다.<br>리스트는 서로 다른 자료형의 항목을 포함할 수 있다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br></pre></td></tr></table></figure><p>문자열과 마찬가지로 슬라이싱 가능하다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares[<span class="number">0</span>]  <span class="comment"># indexing returns the item</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares[<span class="number">-1</span>]</span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares[<span class="number">-3</span>:]  <span class="comment"># slicing returns a new list</span></span><br><span class="line">[<span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br></pre></td></tr></table></figure><p>리스트는 이어붙이기 가능하다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares + [<span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure><p>문자열과 다르게 리스트는 내용을 변경할 수 있다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cubes = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">27</span>, <span class="number">65</span>, <span class="number">125</span>]  <span class="comment"># something's wrong here</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cubes[<span class="number">3</span>] = <span class="number">64</span>  <span class="comment"># replace the wrong value</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cubes</span><br><span class="line">[<span class="number">1</span>, <span class="number">8</span>, <span class="number">27</span>, <span class="number">64</span>, <span class="number">125</span>]</span><br></pre></td></tr></table></figure><p>append() 메서드를 사용하면 리스트의 끝에 새 항목을 추가할 수 있다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cubes.append(<span class="number">216</span>)  <span class="comment"># add the cube of 6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cubes.append(<span class="number">7</span> ** <span class="number">3</span>)  <span class="comment"># and the cube of 7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cubes</span><br><span class="line">[<span class="number">1</span>, <span class="number">8</span>, <span class="number">27</span>, <span class="number">64</span>, <span class="number">125</span>, <span class="number">216</span>, <span class="number">343</span>]</span><br></pre></td></tr></table></figure><p>슬라이싱 후 대입이 가능하기 때문에 길이변경과 항목삭제도 가능하다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># replace some values</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters[<span class="number">2</span>:<span class="number">5</span>] = [<span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># now remove them</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters[<span class="number">2</span>:<span class="number">5</span>] = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># clear the list by replacing all the elements with an empty list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters[:] = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><p>len()를 통해 길이를 가져올 수 있다.</p><blockquote><p><strong>Reference</strong><br><a href="python.org">python.org</a></p></blockquote><p><em>이 게시물은 파이썬 문법을 까먹었을 때 검색하려고 작성됨.</em></p>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/04/12/20200412-python1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 2294 - 동전 2</title>
      <link>https://yhcho0405.github.io/2020/04/08/20200408-boj2294/</link>
      <guid>https://yhcho0405.github.io/2020/04/08/20200408-boj2294/</guid>
      <pubDate>Wed, 08 Apr 2020 03:29:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;처음 생각했던 방법은 dp[i]에 i원을 만들기 위한 동전의 최소 갯수를 저장하는 방식으로 현재 i보다 작은 j원을 순차로 돌며 i - j원 짜리 동전이 있나 확인한 후, dp[i]에는 그 중 가장 작은 값을 넣도록 작성했다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>처음 생각했던 방법은 dp[i]에 i원을 만들기 위한 동전의 최소 갯수를 저장하는 방식으로 현재 i보다 작은 j원을 순차로 돌며 i - j원 짜리 동전이 있나 확인한 후, dp[i]에는 그 중 가장 작은 값을 넣도록 작성했다.</p><a id="more"></a><p>실제로 돌려보니 시간초과를 받았다.<br>최악의 경우에서 i * j * n == 10,000 * 10,000 * 100 == 백 억 번을 반복하기 때문이다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, arr[<span class="number">101</span>], dp[<span class="number">10001</span>], ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">dp[i] = <span class="number">99999</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = n - <span class="number">1</span>; l &gt;= <span class="number">0</span>; l--)</span><br><span class="line"><span class="keyword">if</span>(i - j == arr[l]) dp[i] = min(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ans = (dp[k] == <span class="number">99999</span>) ? <span class="number">-1</span> : dp[k];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드는 시간초과가 발생한다.</p><br><p>이 문제를 해결하기 위해 <a href="/2020/04/06/20200406-boj2293/">동전 1</a> 문제 처럼 첫 번째 동전만 사용 했을 때의 최소값과 두 번째 동전까지 사용 했을 때의 최소값과 … 이런식으로 마지막 동전까지 모두 사용했을 때의 최소값을 구하면 dp[k]에 k원을 만들 때 필요한 동전의 최소 갯수가 들어간다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, arr[<span class="number">101</span>], dp[<span class="number">10001</span>], ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">dp[i] = <span class="number">99999</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = arr[i]; j &lt;= k; j++)</span><br><span class="line">dp[j] = min(dp[j], dp[j - arr[i]] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ans = (dp[k] == <span class="number">99999</span>) ? <span class="number">-1</span> : dp[k];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>99999는 10000보다 크기 때문에 절대 나올 수 없다.</p></blockquote>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/04/08/20200408-boj2294/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 11048 - 이동하기</title>
      <link>https://yhcho0405.github.io/2020/04/07/20200407-boj11048/</link>
      <guid>https://yhcho0405.github.io/2020/04/07/20200407-boj11048/</guid>
      <pubDate>Tue, 07 Apr 2020 08:05:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;단순한 dp문제다. 문제의 이동 조건에서 (r+1, c), (r, c+1), (r+1, c+1) 이렇게 3가지를 제시했지만, 사실 상 마지막 (r+1, c+1)은 신경쓰지 않아도 된다.&lt;br&gt;왜냐하면 사탕의 갯수는 0이거나 양수이기 때문에 더 많은 사탕을 가져와야 될 판에 굳이 대각선으로 가로질러 올 필요가 없기 때문이다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>단순한 dp문제다. 문제의 이동 조건에서 (r+1, c), (r, c+1), (r+1, c+1) 이렇게 3가지를 제시했지만, 사실 상 마지막 (r+1, c+1)은 신경쓰지 않아도 된다.<br>왜냐하면 사탕의 갯수는 0이거나 양수이기 때문에 더 많은 사탕을 가져와야 될 판에 굳이 대각선으로 가로질러 올 필요가 없기 때문이다.</p><a id="more"></a><p>dp[i][j]에 현재 칸 까지 가장 많이 가져올 수 있는 사탕의 갯수를 넣는다.<br>마지막에 dp[n][m]을 출력한다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, dp[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; dp[i][j];</span><br><span class="line">dp[i][j] += max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/04/07/20200407-boj11048/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 2167 - 2차원 배열의 합</title>
      <link>https://yhcho0405.github.io/2020/04/07/20200407-boj2167/</link>
      <guid>https://yhcho0405.github.io/2020/04/07/20200407-boj2167/</guid>
      <pubDate>Tue, 07 Apr 2020 07:25:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;그리디로 풀었을 때 최악의 경우 n * m * k번, 300 * 300 * 10,000 = 900,000,000번 계산하므로 시간초과가 난다.&lt;br&gt;그래서 dp로 풀어야 한다. 할 줄 알았는데 그리디하게 풀어도 맞는다고 한다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>그리디로 풀었을 때 최악의 경우 n * m * k번, 300 * 300 * 10,000 = 900,000,000번 계산하므로 시간초과가 난다.<br>그래서 dp로 풀어야 한다. 할 줄 알았는데 그리디하게 풀어도 맞는다고 한다.</p><a id="more"></a><p>어쨌든 dp[i][j]에는 (0, 0)부터 (i, j)까지의 숫자 합을 저장한다.</p><h2 id="dp-를-채워나가는-방법"><a href="#dp-를-채워나가는-방법" class="headerlink" title="dp[][]를 채워나가는 방법"></a>dp[][]를 채워나가는 방법</h2><hr><p><img src="/image-in-post/20200407-boj2167-1.png" alt="노란 영역 까지의 합을 구하려면"><br><img src="/image-in-post/20200407-boj2167-10.png" alt="초록 칸의 값과"><br><img src="/image-in-post/20200407-boj2167-2.png" alt="이 파란 영역의 합과"><br><img src="/image-in-post/20200407-boj2167-3.png" alt="이 파란 영역의 합을 더하고"><br><img src="/image-in-post/20200407-boj2167-4.png" alt="중복된 빨간 영역의 합을 빼면 된다."></p><br><h2 id="주어진-영역의-합을-구하는-방법"><a href="#주어진-영역의-합을-구하는-방법" class="headerlink" title="주어진 영역의 합을 구하는 방법"></a>주어진 영역의 합을 구하는 방법</h2><hr><p><img src="/image-in-post/20200407-boj2167-5.png" alt="노란 영역의 합을 구하려면"><br><img src="/image-in-post/20200407-boj2167-6.png" alt="이 파란 영역의 합에서"><br><img src="/image-in-post/20200407-boj2167-7.png" alt="필요없는 이 빨간 영역의 합과"><br><img src="/image-in-post/20200407-boj2167-8.png" alt="이 빨간 영역의 합을 빼고"><br><img src="/image-in-post/20200407-boj2167-9.png" alt="중복되서 빼버린 이 파란 영역의 합을 더해주면 된다."></p><br><p>위 과정을 코드로 작성하면 아래와 같다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, ans, i, j, x, y, dp[<span class="number">301</span>][<span class="number">301</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; dp[i][j];</span><br><span class="line">dp[i][j] += dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>] - dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; i &gt;&gt; j &gt;&gt; x &gt;&gt; y;</span><br><span class="line">ans = dp[x][y] - dp[x][j - <span class="number">1</span>] - dp[i - <span class="number">1</span>][y] + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/04/07/20200407-boj2167/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 11055 - 가장 큰 증가 부분 수열</title>
      <link>https://yhcho0405.github.io/2020/04/07/20200407-boj11055/</link>
      <guid>https://yhcho0405.github.io/2020/04/07/20200407-boj11055/</guid>
      <pubDate>Tue, 07 Apr 2020 03:38:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;a href=&quot;/2019/11/04/20191104-boj11053/&quot;&gt;가장 긴 증가하는 부분 수열&lt;/a&gt; 문제에서 dp[]에 길이를 넣었다면 지금 이 문제는 최대값을 넣으면 된다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p><a href="/2019/11/04/20191104-boj11053/">가장 긴 증가하는 부분 수열</a> 문제에서 dp[]에 길이를 넣었다면 지금 이 문제는 최대값을 넣으면 된다.</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, arr[<span class="number">1001</span>], dp[<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">dp[i] = arr[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line"><span class="keyword">if</span>(arr[j] &lt; arr[i]) dp[i] = max(dp[j] + arr[i], dp[i]);</span><br><span class="line">&#125;</span><br><span class="line">sort(dp, dp + n + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/04/07/20200407-boj11055/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 1699 - 제곱수의 합</title>
      <link>https://yhcho0405.github.io/2020/04/07/20200407-boj1699/</link>
      <guid>https://yhcho0405.github.io/2020/04/07/20200407-boj1699/</guid>
      <pubDate>Mon, 06 Apr 2020 23:14:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;만약 i라는 숫자보다 &lt;strong&gt;j * j&lt;/strong&gt;만큼 작은 수 인 &lt;strong&gt;i - j * j&lt;/strong&gt;는 숫자 &lt;strong&gt;i&lt;/strong&gt;의 &lt;strong&gt;제곱수의 최소항 갯수 - 1&lt;/strong&gt;을 가질 것이다.&lt;br&gt;만약 &lt;strong&gt;j * j&lt;/strong&gt;가 &lt;strong&gt;i&lt;/strong&gt;와 같다면 &lt;strong&gt;j * j = i&lt;/strong&gt;이므로 제곱수의 최소항 갯수가 한개가 된다.&lt;br&gt;이 과정을 &lt;strong&gt;j * j&lt;/strong&gt;가 &lt;strong&gt;i&lt;/strong&gt;보다 작거나 같을 때까지 반복해 가장 작은 값을 &lt;strong&gt;dp[i]&lt;/strong&gt;에 넣고 &lt;strong&gt;i&lt;/strong&gt;가 &lt;strong&gt;n&lt;/strong&gt;만큼 돌면 &lt;strong&gt;dp[n]&lt;/strong&gt;이 답이 된다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>만약 i라는 숫자보다 <strong>j * j</strong>만큼 작은 수 인 <strong>i - j * j</strong>는 숫자 <strong>i</strong>의 <strong>제곱수의 최소항 갯수 - 1</strong>을 가질 것이다.<br>만약 <strong>j * j</strong>가 <strong>i</strong>와 같다면 <strong>j * j = i</strong>이므로 제곱수의 최소항 갯수가 한개가 된다.<br>이 과정을 <strong>j * j</strong>가 <strong>i</strong>보다 작거나 같을 때까지 반복해 가장 작은 값을 <strong>dp[i]</strong>에 넣고 <strong>i</strong>가 <strong>n</strong>만큼 돌면 <strong>dp[n]</strong>이 답이 된다.</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, dp[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">dp[i] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j * j &lt;= i; j++)</span><br><span class="line">dp[i] = min(dp[i - j * j] + <span class="number">1</span>, dp[i]);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>구글링 하다가 동적 계획법 말고 다른 방법을 사용한 다른 풀이를 발견해서 첨부한다.<br><strong>라그랑주의 네 제곱수 정리</strong>에 의하여 모든 양의 정수는 최대 4개의 제곱수의 합으로 나타낼 수 있기 때문에 3개의 제곱수의 합으로 못찾아내면 4개라는 점을 이용한 반쪽짜리 완전탐색 코드다.<br>3중 for문이라 되게 오래 걸릴 것 같지만 제곱근 n에 대하여 매우 빠르게 수가 불어나서 생각보다 빠르다.<br>오히려 dp보다 빠를 수도 있다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, ans = <span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">1</span>; a * a &lt;= n; a++) &#123;</span><br><span class="line"><span class="keyword">if</span>(a * a == n) ans = min(ans, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">1</span>; a * a + b * b &lt;= n; b++) &#123;</span><br><span class="line"><span class="keyword">if</span>(a * a + b * b == n) ans = min(ans, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">1</span>; a * a + b * b + c * c &lt;= n; c++)</span><br><span class="line"><span class="keyword">if</span>(a * a + b * b + c * c == n) ans = min(ans, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>채첨 안해봐서 정답 처리 받을 수 있는지 모른다.<br>근데 잘 나온다.</p>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/04/07/20200407-boj1699/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 11057 - 오르막 수</title>
      <link>https://yhcho0405.github.io/2020/04/07/20200407-boj11057/</link>
      <guid>https://yhcho0405.github.io/2020/04/07/20200407-boj11057/</guid>
      <pubDate>Mon, 06 Apr 2020 15:12:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;각 자리수 별로 0 ~ 9까지 숫자들의 등장 가능한 빈도를 세면 된다.&lt;br&gt;dp로 풀 수 있고 바로 전 자리수에 자신보다 작거나 같은 수가 얼마나 있는지를 dp[i][j]에 저장해나가면 된다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>각 자리수 별로 0 ~ 9까지 숫자들의 등장 가능한 빈도를 세면 된다.<br>dp로 풀 수 있고 바로 전 자리수에 자신보다 작거나 같은 수가 얼마나 있는지를 dp[i][j]에 저장해나가면 된다.</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, ans, dp[<span class="number">1001</span>][<span class="number">11</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">dp[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = j; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">dp[i][j] += dp[i - <span class="number">1</span>][k];</span><br><span class="line">dp[i][j] %= <span class="number">10007</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">ans += dp[n][i];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans % <span class="number">10007</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/04/07/20200407-boj11057/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 2293 - 동전 1</title>
      <link>https://yhcho0405.github.io/2020/04/06/20200406-boj2293/</link>
      <guid>https://yhcho0405.github.io/2020/04/06/20200406-boj2293/</guid>
      <pubDate>Mon, 06 Apr 2020 05:59:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;dp로 접근해서 풀어야 한다.&lt;br&gt;처음에 생각했던 방법은 dp[i]에 i원을 만들 수 있는 경우의 수를 저장하고, 각 dp[i]에 가지고 있는 동전의 종류(arr[j])원을 뺀 dp[i - arr[j]]를 더해주는 방법으로 풀면 되겠다고 생각했다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>dp로 접근해서 풀어야 한다.<br>처음에 생각했던 방법은 dp[i]에 i원을 만들 수 있는 경우의 수를 저장하고, 각 dp[i]에 가지고 있는 동전의 종류(arr[j])원을 뺀 dp[i - arr[j]]를 더해주는 방법으로 풀면 되겠다고 생각했다.</p><a id="more"></a><p>&lt;예제 1 입력&gt;<br>3 10<br>1<br>2<br>5</p><p>&lt;예제 1 출력&gt;<br>10</p><br><p>막상 실행시켜보니 예제 1의 정답은 10이 나와야 하지만 내 코드는 128을 출력했다.</p><p>코드의 동작 과정을 생각해보면 오류가 보인다.<br><strong>1원을 만들 때의 경우의 수 = 1개 (1)</strong><br><strong>2원을 만들 때의 경우의 수 = 2개 (1, 1 / 2)</strong><br>여기서 내 코드의 논리로는 3원을 만들 때 1원(2원짜리 동전을 가지고 있으므로 3 - 2 = 1원)과 2원(1원짜리 동전을 가지고 있으므로 3 - 1 = 2원)의 경우의 수의 합과 같아야 한다.<br>따라서<br><strong>3원을 만들 때의 경우의 수 = 3개 (1, 2 / 1, 1, 1 / 2, 1)</strong><br>하지만 문제의 조건에서 순서만 다른 것은 같은 경우로 취급하라 했으므로 3원을 만들 때의 경우의 수에 동전의 조합이 중복되는 경우가 발생한다.<br>그래서 실제로 3원을 만들 때의 경우의 수는 2개이다. (1, 2 / 1, 1, 1)<br>아래 코드는 동전의 조합까지 모두 계산하는 결과를 출력한다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, arr[<span class="number">101</span>], dp[<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">dp[arr[i]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; n; a++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i - j == arr[a]) dp[i] += dp[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>물론 위의 코드는 오답처리를 받는다.<br><br></p><p>정답 처리를 받기 위해선 동전의 순서는 고려하지 않고 동전의 조합의 갯수만 출력하도록 작성해야한다.</p><p>그러기 위해 위의 예제의 경우 첫번째 동전만으로 경우의 수를 구하고, 두번째 동전까지 사용해 경우의 수를 구하고, 세번째 동전까지 사용해 경우의 수를 구하는 방법을 사용한다.<br>이 경우는 각각 동전들이 독립적인 결과를 가지므로 중복이 발생하지 않는다.<br>위의 코드와 대체로 유사하지만 dp[i]를 저장할 때 2중 for문에서 i와 j가 바뀐 형태다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, arr[<span class="number">101</span>], dp[<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i] &gt; j) <span class="keyword">continue</span>;</span><br><span class="line">dp[j] += dp[j - arr[i]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 코드가 정답이다.</p>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/04/06/20200406-boj2293/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 1010 - 다리 놓기</title>
      <link>https://yhcho0405.github.io/2020/04/04/20200404-boj1010/</link>
      <guid>https://yhcho0405.github.io/2020/04/04/20200404-boj1010/</guid>
      <pubDate>Sat, 04 Apr 2020 03:35:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;보자마자 떠오른것은 조합이다.&lt;br&gt;mCn을 계산하면 정답이 나오지만 m이 최대 29까지 등장하기 때문에 계산 과정에서 29!을 계산할 여지가 있다.&lt;br&gt;29!은 long long에도 못들어가는 아무튼 엄청 크다.&lt;br&gt;이를 해결하는 방법은 여러가지가 있다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>보자마자 떠오른것은 조합이다.<br>mCn을 계산하면 정답이 나오지만 m이 최대 29까지 등장하기 때문에 계산 과정에서 29!을 계산할 여지가 있다.<br>29!은 long long에도 못들어가는 아무튼 엄청 크다.<br>이를 해결하는 방법은 여러가지가 있다.</p><a id="more"></a><p>먼저 조합의 성질을 보자.<br><strong>nCr</strong>이라면 <strong>n! / {(n - r)! * r!}</strong> 이다.<br>이 때문에 r을 n - r로 바꾸어 계산해도 정답은 일치한다.<br>그렇다면 주어진 범위에서 계산 과정 중 분자의 크기가 가장 커지게 만드는 경우는 <strong>n이 29일 때와 r이 14또는 15일 때</strong> 이다.<br>수식을 약분하면 계산 과정 중 등장할 가장 큰 수인 29!/15!은<br><strong>6,761,440,164,390,912,000</strong><br>이고 long long의 양수 최대범위는<br><strong>9,223,372,036,854,775,807</strong><br>이다.<br><br><br>아슬아슬하게 걸친다.<br>가장 큰 수가 오버플로우가 발생하지 않는다면 주어진 범위 내의 모든 수도 계산하는데 문제가 없을 것이다.</p><p>위 내용을 코드로 나타내면 아래와 같다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> t, n, m, ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t--) &#123;</span><br><span class="line">ans = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">n = n &gt; m - n ? m - n : n; <span class="comment">// m - n과 n중 더 작은것을 사용한다.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">ans *= m - i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">ans /= i;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>또 다른 방법은 조합 계산을 동적 계획법을 이용해 재귀함수로 구현하는 것이다.<br>그 전에 조합 <strong>nCr = n-1Cr-1 + n-1Cr</strong>로 나타낼 수 있다는 것을 알아야 한다.(파스칼의 삼각형으로 부터 유래되었다.)<br>로또로 예를 들어 보면 45개 중 6개를 뽑을 때의 경우의 수는 <strong>1번 공을 미리 뽑고 5개를 랜덤으로 뽑는 경우와 1번 공을 제외하고 6개를 랜덤으로 뽑는 경우를 더한 것</strong>과 같다.<br>저 공식을 사용해 계속 쪼개나가서 n과 r이 같아지거나 r이 0이 될 때 1을 반환하면 된다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, a, b, dp[<span class="number">31</span>][<span class="number">31</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cbn</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n == r || r == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(dp[n][r]) <span class="keyword">return</span> dp[n][r];</span><br><span class="line"><span class="keyword">return</span> dp[n][r] = cbn(n - <span class="number">1</span>, r - <span class="number">1</span>) + cbn(n - <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t--) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cbn(b, a) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/04/04/20200404-boj1010/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 9465 - 스티커</title>
      <link>https://yhcho0405.github.io/2020/04/03/20200403-boj9465/</link>
      <guid>https://yhcho0405.github.io/2020/04/03/20200403-boj9465/</guid>
      <pubDate>Fri, 03 Apr 2020 06:11:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;동적 계획법으로 해결할 수 있다.&lt;br&gt;&lt;img src=&quot;/image-in-post/20200403-boj9465-1.PNG&quot; alt=&quot;먼저 dp00을 선택했을 때&quot;&gt;&lt;br&gt;&lt;img src=&quot;/image-in-post/20200403-boj9465-2.PNG&quot; alt=&quot;dp11을 선택하는 경우와&quot;&gt;&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>동적 계획법으로 해결할 수 있다.<br><img src="/image-in-post/20200403-boj9465-1.PNG" alt="먼저 dp00을 선택했을 때"><br><img src="/image-in-post/20200403-boj9465-2.PNG" alt="dp11을 선택하는 경우와"></p><a id="more"></a><p><img src="/image-in-post/20200403-boj9465-3.PNG" alt="dp12을 선택하는 경우가 있다."><br><img src="/image-in-post/20200403-boj9465-4.PNG" alt="물론 dp02또한 선택할 수는 있지만,"><br><img src="/image-in-post/20200403-boj9465-5.PNG" alt="dp11이 선택됐을 때 경우와 겹치기 때문에 점화식에서는 고려할 필요가 없다."></p><p>따라서 두 번째 사진 처럼 짧은 대각선에 있거나 세 번째 사진처럼 긴 대각선에 있는 경우만 생각해주면 된다.</p><p>위 내용을 코드로 옮기면 아래와 같다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, n, dp[<span class="number">2</span>][<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t--) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; dp[i][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">dp[<span class="number">0</span>][i] += max(dp[<span class="number">1</span>][i - <span class="number">1</span>], dp[<span class="number">1</span>][i - <span class="number">2</span>]);</span><br><span class="line">dp[<span class="number">1</span>][i] += max(dp[<span class="number">0</span>][i - <span class="number">1</span>], dp[<span class="number">0</span>][i - <span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; max(dp[<span class="number">0</span>][n], max(dp[<span class="number">0</span>][n - <span class="number">1</span>], max(dp[<span class="number">1</span>][n], dp[<span class="number">1</span>][n - <span class="number">1</span>]))) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다른 사람 풀이를 보니 마지막에 dp[0][n]과 dp[1][n]만 비교해도 AC를 받았다.<br>나는 위 설명에서 3번째 사진과 같은 경우 때문에 마지막 4개를 비교했으나 안해도 되는 이유를 생각해봐야겠다.</p>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/04/03/20200403-boj9465/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 14501 - 퇴사</title>
      <link>https://yhcho0405.github.io/2020/04/03/20200403-boj14501/</link>
      <guid>https://yhcho0405.github.io/2020/04/03/20200403-boj14501/</guid>
      <pubDate>Fri, 03 Apr 2020 05:11:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;n이 최대 15이기 때문에 최악의 경우에도 2^15가지의 경우의 수를 가진다.&lt;br&gt;따라서 완전탐색을 해도 문제가 없다.&lt;br&gt;하지만 동적 계획법으로도 해결할 수 있기 때문에 두가지 방법을 다뤄보겠다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>n이 최대 15이기 때문에 최악의 경우에도 2^15가지의 경우의 수를 가진다.<br>따라서 완전탐색을 해도 문제가 없다.<br>하지만 동적 계획법으로도 해결할 수 있기 때문에 두가지 방법을 다뤄보겠다.</p><a id="more"></a><p>먼저 깊이우선탐색을 이용한 방법이다. (이전 금액을 가져와 최종적으로 비교해야 하기 때문에 dfs를 사용한다.)<br>현재 day에서 선택 할지 안 할지를 재귀적으로 호출한다.<br>결과적으로 최종 money를 비교해 ans에 저장한다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, ans, t[<span class="number">16</span>], p[<span class="number">16</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> day, <span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(day &gt; n + <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(day == n + <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(ans &lt; money) ans = money;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">dfs(day + t[day], money + p[day]);</span><br><span class="line">dfs(day + <span class="number">1</span>, money);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t[i] &gt;&gt; p[i];</span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>동적 계획법을 이용한 방법이다.<br>dp[i + t]값 보다 dp[i] + p값이 크다면 dp[i + t]에 dp[i] + p를 넣는다.<br>내일까지 벌 수 있는 최대 금액보다 오늘 벌 수 있는 최대 금액이 더 크다면 내일도 오늘만큼 벌 수 있으므로 dp[i + 1] = dp[i] 한다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, t, p, dp[<span class="number">16</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t &gt;&gt; p;</span><br><span class="line">dp[i + t] = max(dp[i + t], dp[i] + p);</span><br><span class="line">dp[i + <span class="number">1</span>] = max(dp[i + <span class="number">1</span>], dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/04/03/20200403-boj14501/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 11052 - 카드 구매하기</title>
      <link>https://yhcho0405.github.io/2020/03/28/20200328-boj11052/</link>
      <guid>https://yhcho0405.github.io/2020/03/28/20200328-boj11052/</guid>
      <pubDate>Sat, 28 Mar 2020 04:20:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;좀 생각 많이 한 문제다.&lt;br&gt;카드 n개를 구매할 때 최대 금액은 카드 n - j개를 구매할 때의 최대 금액 + 카드 j개가 담겨있는 카드팩의 가격일 것이다.&lt;br&gt;카드팩의 가격은 arr[]에 저장하고 카드 n개를 가장 비싸게 구매할 때 금액을 dp[n]에 저장한다면, 카드 n개를 가장 비싸게 구매할 때 금액은 dp[n], dp[n - 1] + arr[1], dp[n - 2] + arr[2], dp[n - 3] + arr[3]…dp[n - n] + arr[n] 중 가장 큰 값이 된다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>좀 생각 많이 한 문제다.<br>카드 n개를 구매할 때 최대 금액은 카드 n - j개를 구매할 때의 최대 금액 + 카드 j개가 담겨있는 카드팩의 가격일 것이다.<br>카드팩의 가격은 arr[]에 저장하고 카드 n개를 가장 비싸게 구매할 때 금액을 dp[n]에 저장한다면, 카드 n개를 가장 비싸게 구매할 때 금액은 dp[n], dp[n - 1] + arr[1], dp[n - 2] + arr[2], dp[n - 3] + arr[3]…dp[n - n] + arr[n] 중 가장 큰 값이 된다.</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, arr[<span class="number">1001</span>], dp[<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">dp[i] = max(dp[i], dp[i - j] + arr[j]);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/28/20200328-boj11052/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 9461 - 파도반 수열</title>
      <link>https://yhcho0405.github.io/2020/03/28/20200328-boj9461/</link>
      <guid>https://yhcho0405.github.io/2020/03/28/20200328-boj9461/</guid>
      <pubDate>Fri, 27 Mar 2020 18:40:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;문제에서 주어진 그림을 보면 점화식을 세울 수 있다.&lt;br&gt;i번째 삼각형의 변의 길이는 i-1번째 삼각형의 변의 길이 + i - 5번째 삼각형의 변의 길이와 같다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>문제에서 주어진 그림을 보면 점화식을 세울 수 있다.<br>i번째 삼각형의 변의 길이는 i-1번째 삼각형의 변의 길이 + i - 5번째 삼각형의 변의 길이와 같다.</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, m, dp[<span class="number">101</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>; i &lt; <span class="number">101</span>; i++)</span><br><span class="line">dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; <span class="built_in">cin</span> &gt;&gt; m; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/28/20200328-boj9461/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 10844 - 쉬운 계단 수</title>
      <link>https://yhcho0405.github.io/2020/03/27/20200327-boj10844/</link>
      <guid>https://yhcho0405.github.io/2020/03/27/20200327-boj10844/</guid>
      <pubDate>Fri, 27 Mar 2020 09:10:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;숫자 i 다음 으로 나올 수 있는 수는 i-1과 i+1이다.&lt;br&gt;하지만 0과 9는 다음으로 나올 수 있는 수가 각각 1과 8이다.&lt;br&gt;이 부분에 대해 예외처리를 하려 했으나 dp가 전역으로 정의돼있기 때문에 필요가 없었다.  &lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>숫자 i 다음 으로 나올 수 있는 수는 i-1과 i+1이다.<br>하지만 0과 9는 다음으로 나올 수 있는 수가 각각 1과 8이다.<br>이 부분에 대해 예외처리를 하려 했으나 dp가 전역으로 정의돼있기 때문에 필요가 없었다.  </p><a id="more"></a><p>i번째 자릿수에 나올 수 있는 숫자 j를 2차원 배열 dp에 저장한다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">int</span> n, dp[<span class="number">101</span>][<span class="number">11</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">dp[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">dp[i][j] = (dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j + <span class="number">1</span>]) % mod;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">ans += dp[n][i];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/27/20200327-boj10844/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 1912 - 연속합</title>
      <link>https://yhcho0405.github.io/2020/03/27/20200327-boj1912/</link>
      <guid>https://yhcho0405.github.io/2020/03/27/20200327-boj1912/</guid>
      <pubDate>Fri, 27 Mar 2020 07:30:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;합이 가장 큰 연속된 부분집합을 찾는 문제로 dp[i - 1] + i번째 수와 i번째 수 중 큰 것을 dp[i]에 저장한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;dp[i - 1] + i번째 수&lt;/li&gt;
&lt;li&gt;i번째 수&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1번이 더 크다면 dp[i - 1]가 양수고, 2번이 더 크다면 dp[i - 1]가 음수다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>합이 가장 큰 연속된 부분집합을 찾는 문제로 dp[i - 1] + i번째 수와 i번째 수 중 큰 것을 dp[i]에 저장한다.</p><ol><li>dp[i - 1] + i번째 수</li><li>i번째 수</li></ol><p>1번이 더 크다면 dp[i - 1]가 양수고, 2번이 더 크다면 dp[i - 1]가 음수다.</p><a id="more"></a><p>가장 큰 부분합이 마지막 원소를 포함하지 않는다면 마지막 위치에 저장되지 않을 수 있으므로 dp[]를 정렬해서 부분합 중 가장 큰 것을 고른다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, dp[<span class="number">100001</span>] = &#123;<span class="number">-1001</span>, &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n &amp;&amp; <span class="built_in">cin</span> &gt;&gt; m; i++)</span><br><span class="line">dp[i] = max(dp[i - <span class="number">1</span>] + m, m);</span><br><span class="line">sort(dp, dp + n + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/27/20200327-boj1912/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 2156 - 포도주 시식</title>
      <link>https://yhcho0405.github.io/2020/03/27/20200327-boj2156/</link>
      <guid>https://yhcho0405.github.io/2020/03/27/20200327-boj2156/</guid>
      <pubDate>Thu, 26 Mar 2020 17:50:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;보자 마자 &lt;a href=&quot;https://yhcho0405.github.io/2020/03/27/20200327-boj2579/&quot;&gt;계단 오르기&lt;/a&gt;문제와 똑같다고 생각했지만 계단 오르기는 무조건 마지막 계단을 밟아야 하는 반면, 포도주는 꼭 마지막을 안 마셔도 된다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>보자 마자 <a href="https://yhcho0405.github.io/2020/03/27/20200327-boj2579/">계단 오르기</a>문제와 똑같다고 생각했지만 계단 오르기는 무조건 마지막 계단을 밟아야 하는 반면, 포도주는 꼭 마지막을 안 마셔도 된다.</p><a id="more"></a><p>그래서 계단 오르기 방법에서는 마지막을 포함하도록 한정 지었던 반면에 포도주에선 단순히 dp[i - 1]이 값도 비교하게 하므로써 전에 있던 값이 더 크다면 그 값을 뒤로 밀도록 변경했다.</p><p>그것 말곤 다른것이 없다. (사실 n의 범위가 다르다)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, d[<span class="number">10001</span>], dp[<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; d[i];</span><br><span class="line">dp[<span class="number">1</span>] = d[<span class="number">1</span>];</span><br><span class="line">dp[<span class="number">2</span>] = d[<span class="number">1</span>] + d[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">dp[i] = max(max(d[i - <span class="number">1</span>] + dp[i - <span class="number">3</span>] + d[i], dp[i - <span class="number">1</span>]), dp[i - <span class="number">2</span>] + d[i]);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/27/20200327-boj2156/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 1932 - 정수 삼각형</title>
      <link>https://yhcho0405.github.io/2020/03/27/20200327-boj1932/</link>
      <guid>https://yhcho0405.github.io/2020/03/27/20200327-boj1932/</guid>
      <pubDate>Thu, 26 Mar 2020 17:35:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;삼각형 내부의 모든 지점에 dp를 수행하던 방향에 따라 그 전 층의 자신과 인접한 지점의 값 중 큰 값을 추가한다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>삼각형 내부의 모든 지점에 dp를 수행하던 방향에 따라 그 전 층의 자신과 인접한 지점의 값 중 큰 값을 추가한다.</p><a id="more"></a><p>dp를 위에서 아래로 수행하는 방법과 아래에서 위로 수행하는 경우 두 가지를 가져와봤다.<br>결론은 아래에서 위가 더 효율적이다.</p><h2 id="위에서-아래로"><a href="#위에서-아래로" class="headerlink" title="위에서 아래로"></a>위에서 아래로</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, dp[<span class="number">501</span>][<span class="number">501</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">dp[<span class="number">1</span>][<span class="number">1</span>] = m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line"><span class="keyword">if</span>(j == <span class="number">1</span>) dp[i][j] = dp[i - <span class="number">1</span>][j] + m;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(j == i) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + m;</span><br><span class="line"><span class="keyword">else</span> dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort(dp[n] + <span class="number">1</span>, dp[n] + n + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[n][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위에서 아래로 수행할 시 좌우 모서리 부분에 대한 예외처리가 필요하고, 또 마지막 바닥 줄에서 가장 큰 수를 찾아야 하므로 정렬이 필요했다.<br><br><br>하지만 아래에서 위로 수행하면 위의 두가지 단점을 해결해서 코드가 더 간결하다.</p><h2 id="아래에서-위로"><a href="#아래에서-위로" class="headerlink" title="아래에서 위로"></a>아래에서 위로</h2><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">501</span>][<span class="number">501</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; dp[i][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">dp[i<span class="number">-1</span>][j] += max(dp[i][j], dp[i][j+<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>사실 처음에 생각해낸 방법이 위에서 아래로 방법이다.</del></p>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/27/20200327-boj1932/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 2193 - 이친수</title>
      <link>https://yhcho0405.github.io/2020/03/27/20200327-boj2193/</link>
      <guid>https://yhcho0405.github.io/2020/03/27/20200327-boj2193/</guid>
      <pubDate>Thu, 26 Mar 2020 17:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;가능한 경우를 부모노드가 1인 트리로 그려보면 규칙을 파악하기 쉽다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>가능한 경우를 부모노드가 1인 트리로 그려보면 규칙을 파악하기 쉽다.</p><a id="more"></a><p>이 문제도 어째 피보나치와 같은 형태가 되었다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, dp[<span class="number">91</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/27/20200327-boj2193/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>

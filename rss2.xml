<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>yhcho0405</title>
    <link>https://yhcho0405.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>내가 보려고 쓰는 블로그</description>
    <pubDate>Thu, 26 Mar 2020 08:30:00 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[C++]BOJ 1003 - 피보나치 함수</title>
      <link>https://yhcho0405.github.io/2020/03/26/20200326-boj1003/</link>
      <guid>https://yhcho0405.github.io/2020/03/26/20200326-boj1003/</guid>
      <pubDate>Thu, 26 Mar 2020 08:30:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;시간 제한이 0.25초로 걸려있는 것이 정직하게 피보나치 돌리면 시간 초과가 뜬다는 것을 암시한 것인가.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>시간 제한이 0.25초로 걸려있는 것이 정직하게 피보나치 돌리면 시간 초과가 뜬다는 것을 암시한 것인가.</p><a id="more"></a><p>n번째 피보나치를 구한다 생각하고 트리를 그려보면 매우 쉬워진다.<br>예를 들어 n번째 피보나치 수열을 구하는 트리에서 n + 1번째 피보나치 수열을 구하는 트리를 그린다 가정하면, 기존의 n이 부모인 트리에서 n + 1을 부모 노드로 추가하고 n - 1의 부분 트리가 하나 더 생긴다.<br>이것을 n + 1을 n으로 치환해서 읽어보면 n의 부모 노드에 n - 1과 n - 2의 자식 노드가 연결된 형태이다.<br>이 생각을 중심으로 0과 1 각각 갯수를 세어주면 된다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f1[<span class="number">41</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, f0[<span class="number">41</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, t, n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">41</span>; i++) &#123;</span><br><span class="line">f1[i] = f1[i - <span class="number">1</span>] + f1[i - <span class="number">2</span>];</span><br><span class="line">f0[i] = f0[i - <span class="number">1</span>] + f0[i - <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t &amp;&amp; <span class="built_in">cin</span> &gt;&gt; n; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f0[n] &lt;&lt; <span class="string">" "</span> &lt;&lt; f1[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/26/20200326-boj1003/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 9095 - 1, 2, 3 더하기</title>
      <link>https://yhcho0405.github.io/2020/03/26/20200326-boj9095/</link>
      <guid>https://yhcho0405.github.io/2020/03/26/20200326-boj9095/</guid>
      <pubDate>Thu, 26 Mar 2020 08:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;dp[i]에는 정수 i를 1, 2, 3의 합으로 나타내는 방법의 수가 담겨있다.&lt;br&gt;그래서 정수 5를 1, 2, 3의 합으로 나타내는 방법의 수가 궁금하다면, dp[2] + dp[3] + dp[4]가 될 것이다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>dp[i]에는 정수 i를 1, 2, 3의 합으로 나타내는 방법의 수가 담겨있다.<br>그래서 정수 5를 1, 2, 3의 합으로 나타내는 방법의 수가 궁금하다면, dp[2] + dp[3] + dp[4]가 될 것이다.</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">12</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>; i &lt; <span class="number">12</span>; i++)</span><br><span class="line">dp[i] = dp[i - <span class="number">3</span>] + dp[i - <span class="number">2</span>] + dp[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/26/20200326-boj9095/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 1463 - 1로 만들기</title>
      <link>https://yhcho0405.github.io/2020/03/26/20200326-boj1463/</link>
      <guid>https://yhcho0405.github.io/2020/03/26/20200326-boj1463/</guid>
      <pubDate>Thu, 26 Mar 2020 07:37:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;크게 두 가지 경우의 수가 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;3로 나누어 떨어질 경우&lt;/li&gt;
&lt;li&gt;3으로 나누어 떨어질 경우&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;3번 조건은 언제나 적용할 수 있기 때문에 처음부터 계산하고 시작한다.&lt;br&gt;2와 3의 공배수 같은 경우는 2와 3 둘 다 나누어 떨어지기 때문에 다른 조건을 만들어야 하나 싶었지만 어차피 dp[]에 저장된 값을 같은 i를 돌고 있을 때 다시 확인하므로 상관이 없다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>크게 두 가지 경우의 수가 있다.</p><ol><li>3로 나누어 떨어질 경우</li><li>3으로 나누어 떨어질 경우</li></ol><p>3번 조건은 언제나 적용할 수 있기 때문에 처음부터 계산하고 시작한다.<br>2와 3의 공배수 같은 경우는 2와 3 둘 다 나누어 떨어지기 때문에 다른 조건을 만들어야 하나 싶었지만 어차피 dp[]에 저장된 값을 같은 i를 돌고 있을 때 다시 확인하므로 상관이 없다.</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1000001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">dp[i] = dp[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>) dp[i] = min(dp[i/<span class="number">2</span>]+<span class="number">1</span>, dp[i]);</span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">0</span>) dp[i] = min(dp[i/<span class="number">3</span>]+<span class="number">1</span>, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/26/20200326-boj1463/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 2579 - 계단 오르기</title>
      <link>https://yhcho0405.github.io/2020/03/26/20200327-boj2579/</link>
      <guid>https://yhcho0405.github.io/2020/03/26/20200327-boj2579/</guid>
      <pubDate>Wed, 25 Mar 2020 16:40:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;n번째 계단 까지 얻을 수 있는 최대 점수를 구하기 위해 두 가지 경우를 살펴보겠다.&lt;/p&gt;
&lt;h2 id=&quot;n-1번째-계단을-밟고-왔을-경우&quot;&gt;&lt;a href=&quot;#n-1번째-계단을-밟고-왔을-경우&quot; class=&quot;headerlink&quot; title=&quot;n-1번째 계단을 밟고 왔을 경우&quot;&gt;&lt;/a&gt;n-1번째 계단을 밟고 왔을 경우&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;이 경우는 주어진 조건에 의해 n-2계단을 밟으면 안되므로 무조건 n-3계단을 밟고 와야 한다.&lt;br&gt;따라서 n-3번째 계단 까지 얻을 수 있는 최대 점수 + n-1번 계단의 점수 + n번 계단의 점수가 n번째 계단까지 얻을 수 있는 최대 점수가 된다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>n번째 계단 까지 얻을 수 있는 최대 점수를 구하기 위해 두 가지 경우를 살펴보겠다.</p><h2 id="n-1번째-계단을-밟고-왔을-경우"><a href="#n-1번째-계단을-밟고-왔을-경우" class="headerlink" title="n-1번째 계단을 밟고 왔을 경우"></a>n-1번째 계단을 밟고 왔을 경우</h2><hr><p>이 경우는 주어진 조건에 의해 n-2계단을 밟으면 안되므로 무조건 n-3계단을 밟고 와야 한다.<br>따라서 n-3번째 계단 까지 얻을 수 있는 최대 점수 + n-1번 계단의 점수 + n번 계단의 점수가 n번째 계단까지 얻을 수 있는 최대 점수가 된다.</p><a id="more"></a><h2 id="n-2번째-계단을-밟고-왔을-경우"><a href="#n-2번째-계단을-밟고-왔을-경우" class="headerlink" title="n-2번째 계단을 밟고 왔을 경우"></a>n-2번째 계단을 밟고 왔을 경우</h2><hr><p>위의 상황보단 간단하다.<br>n-2계단 전에 n-3계단을 밟고 와도 문제가 없고 n-4계단을 밟고 왔어도 조건에 어긋나지 않는다.<br>따라서 n-2번째 계단 까지 얻을 수 있는 최대 점수 + n번 계단의 점수가 n번째 계단까지 얻을 수 있는 최대 점수가 된다.</p><br><p>위 두 경우 중 더 큰 값이 정답이다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, d[<span class="number">301</span>], dp[<span class="number">301</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; d[i];</span><br><span class="line">dp[<span class="number">1</span>] = d[<span class="number">1</span>];</span><br><span class="line">dp[<span class="number">2</span>] = d[<span class="number">1</span>] + d[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">dp[i] = max(d[i - <span class="number">1</span>] + dp[i - <span class="number">3</span>], dp[i - <span class="number">2</span>]) + d[i];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/26/20200327-boj2579/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 1149 - RGB거리</title>
      <link>https://yhcho0405.github.io/2020/03/26/20200327-boj1149/</link>
      <guid>https://yhcho0405.github.io/2020/03/26/20200327-boj1149/</guid>
      <pubDate>Wed, 25 Mar 2020 15:52:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;규칙이 헷갈리는데 요약하면 같은 색인 집이 연속되면 안 된다고 정리할 수 있다.&lt;br&gt;따라서 색(r, g, b)별로 n번째 집까지 색을 칠하는 비용의 최소값은 n - 1번째 집까지의 비용에서 현재 집의 색을 제외한 나머지 색 중 최소값이 될 것이다. &lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>규칙이 헷갈리는데 요약하면 같은 색인 집이 연속되면 안 된다고 정리할 수 있다.<br>따라서 색(r, g, b)별로 n번째 집까지 색을 칠하는 비용의 최소값은 n - 1번째 집까지의 비용에서 현재 집의 색을 제외한 나머지 색 중 최소값이 될 것이다. </p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, r, g, b, dp[<span class="number">1001</span>][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; r &gt;&gt; g &gt;&gt; b;</span><br><span class="line">dp[i][<span class="number">0</span>] = min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]) + r;</span><br><span class="line">dp[i][<span class="number">1</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]) + g;</span><br><span class="line">dp[i][<span class="number">2</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]) + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; min(min(dp[n][<span class="number">0</span>], dp[n][<span class="number">1</span>]), dp[n][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/26/20200327-boj1149/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 11726 - 2×n 타일링</title>
      <link>https://yhcho0405.github.io/2020/03/26/20200327-boj11726/</link>
      <guid>https://yhcho0405.github.io/2020/03/26/20200327-boj11726/</guid>
      <pubDate>Wed, 25 Mar 2020 15:40:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;2n 크기의 직사각형은 2(n-1)크기의 직사각형에서 세로로 길쭉한 블럭 하나를 추가한 것과 같고 2(n-2)크기의 직사각형에서 가로로 길쭉한 블럭 두개를 쌓아서 추가하는 경우와 같다.&lt;br&gt;2(n-2)크기의 직사각형 역시 세로로 길쭉한 블럭을 두개 추가하면 2n크기인 직사각형이 되지만, 2(n-1)와 겹치는 경우가 발생하기에 제외한다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>2n 크기의 직사각형은 2(n-1)크기의 직사각형에서 세로로 길쭉한 블럭 하나를 추가한 것과 같고 2(n-2)크기의 직사각형에서 가로로 길쭉한 블럭 두개를 쌓아서 추가하는 경우와 같다.<br>2(n-2)크기의 직사각형 역시 세로로 길쭉한 블럭을 두개 추가하면 2n크기인 직사각형이 되지만, 2(n-1)와 겹치는 경우가 발생하기에 제외한다.</p><a id="more"></a><p>어째 피보나치와 같은 형태가 되었다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, dp[<span class="number">1001</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    dp[i] %= <span class="number">10007</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/26/20200327-boj11726/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 1041 - 주사위</title>
      <link>https://yhcho0405.github.io/2020/03/25/20200325-boj1041/</link>
      <guid>https://yhcho0405.github.io/2020/03/25/20200325-boj1041/</guid>
      <pubDate>Wed, 25 Mar 2020 10:05:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;우선 한 면이 바닥에 가려져 있으므로 총 5n^2만큼의 면을 볼 수 있다.&lt;br&gt;그 중 3면이 보이는 주사위는 윗쪽 꼭지점 4개, 2면이 보이는 주사위는 눈에 보이는 모서리 8개와 아랫쪽 꼭지점 4개, 1면이 보이는 주사위는 5n^2 - (3 * 3면이 보이는 주사위의 수) - (2 * 2면이 보이는 주사위의 수) 이다.&lt;br&gt;이를 식으로 나타내면,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;3 면 == 4 개&lt;br&gt;2 면 == 8n  - 12 개&lt;br&gt;1 면 == 5n^2 - 16n + 12 개&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;로 정리할 수 있다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>우선 한 면이 바닥에 가려져 있으므로 총 5n^2만큼의 면을 볼 수 있다.<br>그 중 3면이 보이는 주사위는 윗쪽 꼭지점 4개, 2면이 보이는 주사위는 눈에 보이는 모서리 8개와 아랫쪽 꼭지점 4개, 1면이 보이는 주사위는 5n^2 - (3 * 3면이 보이는 주사위의 수) - (2 * 2면이 보이는 주사위의 수) 이다.<br>이를 식으로 나타내면,</p><blockquote><p>3 면 == 4 개<br>2 면 == 8n  - 12 개<br>1 면 == 5n^2 - 16n + 12 개</p></blockquote><p>로 정리할 수 있다.</p><a id="more"></a><p>그리고 3면과 2면을 고를 때 단순히 주사위 면 중 숫자가 작은 면을 골라내면 문제가 발생하기 때문에 서로 이어진 면들을 선택해야 한다.</p><blockquote><p>3면이 보이는 경우 == 마주보는 3쌍의 면들 중 각 쌍에서 작은 면을 고른다.<br>2면이 보이는 경우 == 마주보는 면을 제외하고 모든 경우의 합(12개)을 저장하고 가장 작은 값을 이용한다.</p></blockquote><p>마지막으로 주사위가 하나일 경우 예외처리를 해준다.  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, d[<span class="number">6</span>], v3, v[<span class="number">12</span>], v2, cnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; d[i];</span><br><span class="line">v3 = min(d[<span class="number">0</span>], d[<span class="number">5</span>]) + min(d[<span class="number">2</span>], d[<span class="number">3</span>]) + min(d[<span class="number">1</span>], d[<span class="number">4</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>((i==<span class="number">0</span>&amp;&amp;j==<span class="number">5</span>)||(i==<span class="number">2</span>&amp;&amp;j==<span class="number">3</span>)||(i==<span class="number">1</span>&amp;&amp;j==<span class="number">4</span>)) <span class="keyword">continue</span>;</span><br><span class="line">v[cnt++] = d[i] + d[j];</span><br><span class="line">&#125;</span><br><span class="line">sort(v, v + <span class="number">12</span>);</span><br><span class="line">sort(d, d + <span class="number">6</span>);</span><br><span class="line">v2 = v[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d[<span class="number">0</span>] + d[<span class="number">1</span>] + d[<span class="number">2</span>] + d[<span class="number">3</span>] + d[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v3 * <span class="number">4</span> + v2 * (<span class="number">8</span> * n - <span class="number">12</span>) + d[<span class="number">0</span>] * (<span class="number">5</span> * (n * n) - <span class="number">16</span> * n + <span class="number">12</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/25/20200325-boj1041/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 1969 - DNA</title>
      <link>https://yhcho0405.github.io/2020/03/25/20200325-boj1969/</link>
      <guid>https://yhcho0405.github.io/2020/03/25/20200325-boj1969/</guid>
      <pubDate>Wed, 25 Mar 2020 05:59:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;사전순이기 때문에 A, C, G, T 순으로 세로줄에 등장하는 갯수가 제일 많은 뉴클레오타이드로 배치한다.&lt;br&gt;Hamming Distance는 세로줄에서 선택된 뉴클레오타이드를 제외하고 나머지 뉴클레오타이드의 등장횟수를 세면 된다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>사전순이기 때문에 A, C, G, T 순으로 세로줄에 등장하는 갯수가 제일 많은 뉴클레오타이드로 배치한다.<br>Hamming Distance는 세로줄에서 선택된 뉴클레오타이드를 제외하고 나머지 뉴클레오타이드의 등장횟수를 세면 된다.</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, h;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> c[<span class="number">1000</span>][<span class="number">50</span>];</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; c[i][j];</span><br><span class="line"><span class="keyword">char</span> ans[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">20</span>] = &#123;<span class="number">0</span>, &#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">cnt[c[j][i] - <span class="string">'A'</span>]++;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>, idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++)</span><br><span class="line"><span class="keyword">if</span>(tmp &lt; cnt[j]) &#123;</span><br><span class="line">tmp = cnt[j];</span><br><span class="line">idx = j;</span><br><span class="line">&#125;</span><br><span class="line">h += cnt[<span class="number">0</span>] + cnt[<span class="number">2</span>] + cnt[<span class="number">6</span>] + cnt[<span class="number">19</span>];</span><br><span class="line">h -= cnt[idx];</span><br><span class="line">ans[i] = idx + <span class="string">'A'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans[i];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/25/20200325-boj1969/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 1343 - 폴리오미노</title>
      <link>https://yhcho0405.github.io/2020/03/25/20200325-boj1343/</link>
      <guid>https://yhcho0405.github.io/2020/03/25/20200325-boj1343/</guid>
      <pubDate>Tue, 24 Mar 2020 18:01:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;보자마자 스택이 떠올랐다.&lt;br&gt;물론 스택을 사용하지는 않았다.&lt;br&gt;한 글자씩 받아와서 ‘X’ 4개가 쌓일 때, ‘.’을 만날 때, 모두 읽어서 종료됐을 때의 경우에서 최종 str에 추가해주는 방식으로 풀었다.&lt;br&gt;&lt;br&gt;&lt;br&gt;‘.’을 만났을 때와 종료됐을 때 종료조건과 2개가 쌓였을 때 “BB”를 str에 추가한다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>보자마자 스택이 떠올랐다.<br>물론 스택을 사용하지는 않았다.<br>한 글자씩 받아와서 ‘X’ 4개가 쌓일 때, ‘.’을 만날 때, 모두 읽어서 종료됐을 때의 경우에서 최종 str에 추가해주는 방식으로 풀었다.<br><br><br>‘.’을 만났을 때와 종료됐을 때 종료조건과 2개가 쌓였을 때 “BB”를 str에 추가한다.</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> a;</span><br><span class="line"><span class="keyword">for</span>(; <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;a), a != <span class="number">10</span>;) &#123;</span><br><span class="line"><span class="keyword">if</span>(a == <span class="string">'X'</span>)&#123;</span><br><span class="line">c++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="string">'.'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(c % <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"-1"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="number">2</span>) &#123;</span><br><span class="line">str += <span class="string">"BB"</span>;</span><br><span class="line">c = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">str += <span class="string">'.'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(c == <span class="number">4</span>) &#123;</span><br><span class="line">str += <span class="string">"AAAA"</span>;</span><br><span class="line">c = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(c % <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"-1"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="number">2</span>) &#123;</span><br><span class="line">str += <span class="string">"BB"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다른 사람들의 풀이를 봤는데 find, replace로 쉽게 풀고 있었다.<br>통수맞은 기분이다.</p>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/25/20200325-boj1343/#disqus_thread</comments>
    </item>
    
    <item>
      <title>유클리드 호제법(Euclidean algorithm)</title>
      <link>https://yhcho0405.github.io/2020/03/24/20200324-etc-math1/</link>
      <guid>https://yhcho0405.github.io/2020/03/24/20200324-etc-math1/</guid>
      <pubDate>Tue, 24 Mar 2020 14:50:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;유클리드 호제법은 2개의 자연수 사이의 최대공약수를 구할 때 사용하는 알고리즘이다.&lt;br&gt;&lt;br&gt;&lt;br&gt;2개의 자연수 a, b(a &amp;gt; b)가 있고 a % b = r 이라고 한다면 a, b의 최대공약수는 a, r의 최대공약수와 같다. 이 성질을 이용해 b를 r로 나눈 나머지 r’을 구하고 다시 r을 r’으로 나눈 나머지를 구하는 과정을 반복해서 나머지가 0이 되었을 때 나누는 수가 a와 b의 최대공약수라고 한다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>유클리드 호제법은 2개의 자연수 사이의 최대공약수를 구할 때 사용하는 알고리즘이다.<br><br><br>2개의 자연수 a, b(a &gt; b)가 있고 a % b = r 이라고 한다면 a, b의 최대공약수는 a, r의 최대공약수와 같다. 이 성질을 이용해 b를 r로 나눈 나머지 r’을 구하고 다시 r을 r’으로 나눈 나머지를 구하는 과정을 반복해서 나머지가 0이 되었을 때 나누는 수가 a와 b의 최대공약수라고 한다.</p><a id="more"></a><br><p>최대 공약수를 구하기 위해 a, b(a &gt; b)에 대하여 2부터 b까지 모든 수를 나누는 방법이 있겠으나 수가 커지면 시간이 오래걸린다.<br>하지만 유클리드 호제법은 mod연산을 통해 빠르게 수를 줄여나감으로 기존의 방법보다 효율적이다.</p><p>wikipedia의 예시를 보자.</p><p>79696과 19332의 최대공약수를 구하는 예시다.</p><blockquote><p>78696 ＝ 19332×4 ＋ 1368<br>19332 ＝ 1368×14 ＋ 180<br> 1368 ＝ 180×7 ＋ 108<br>    180 ＝ 108×1 ＋ 72<br>    108 ＝ 72×1 ＋ 36<br>     72 ＝ 36×2 ＋ 0<br>따라서, 최대공약수는 36이다.</p></blockquote><p>매우 간결하다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>재귀함수는 쓸모가 많다.</p>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/24/20200324-etc-math1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 1110 - 더하기 사이클</title>
      <link>https://yhcho0405.github.io/2020/03/24/20200324-boj1110/</link>
      <guid>https://yhcho0405.github.io/2020/03/24/20200324-boj1110/</guid>
      <pubDate>Tue, 24 Mar 2020 14:12:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;읽히는 대로 짜면 된다.&lt;br&gt;신기한 점은 이 문제의 정답은 1, 3, 4, 12, 20, 60으로 6가지 밖에 없다.&lt;br&gt;0부터 99까지의 숫자 중에 정답이 1인 숫자가 1개, 3인 숫자가 3개 4인 숫자가 4개, 5인 숫자가 5개, 12인 숫자가 12개, 20인 숫자가 20개, 60인 숫자가 60개다.&lt;br&gt;각 정답이 같은 숫자끼리 돌아가며 등장한다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>읽히는 대로 짜면 된다.<br>신기한 점은 이 문제의 정답은 1, 3, 4, 12, 20, 60으로 6가지 밖에 없다.<br>0부터 99까지의 숫자 중에 정답이 1인 숫자가 1개, 3인 숫자가 3개 4인 숫자가 4개, 5인 숫자가 5개, 12인 숫자가 12개, 20인 숫자가 20개, 60인 숫자가 60개다.<br>각 정답이 같은 숫자끼리 돌아가며 등장한다.</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, i = <span class="number">0</span> ,a, b, c;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">c = n;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">a = c / <span class="number">10</span>;</span><br><span class="line">b = c % <span class="number">10</span>;</span><br><span class="line">c = (b * <span class="number">10</span>) + (a + b) % <span class="number">10</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125; <span class="keyword">while</span>(n != c);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>1 + 3 + 4 + 12 + 20 + 60 = 100</p></blockquote>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/24/20200324-boj1110/#disqus_thread</comments>
    </item>
    
    <item>
      <title>에라토스테네스의 체 (+ 골드바흐의 추측)</title>
      <link>https://yhcho0405.github.io/2020/03/24/20200324-algorithm-theory11/</link>
      <guid>https://yhcho0405.github.io/2020/03/24/20200324-algorithm-theory11/</guid>
      <pubDate>Tue, 24 Mar 2020 12:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;자연수의 집합에서 소수를 찾아내는 방법으로 모든 수를 나눠보며 나머지를 확인하는 방법보다 빠르기 때문에 유용하게 사용된다.&lt;br&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif&quot; alt=&quot;에라토스테네스의 체&quot;&gt;&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>자연수의 집합에서 소수를 찾아내는 방법으로 모든 수를 나눠보며 나머지를 확인하는 방법보다 빠르기 때문에 유용하게 사용된다.<br><img src="https://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif" alt="에라토스테네스의 체"></p><a id="more"></a><br><ol><li>소수를 구하고자 하는 구간의 모든 수를 나열한다.</li><li>2의 배수, 3의 배수, 5의 배수… 로 계속 지워나간다.<br>위의 움짤에선 숫자가 120까지 있으니 7의 배수 까지만 지워나가면 된다.(7의 다음 소수인 11의 제곱은 121이기 때문)</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">bool</span> p[<span class="number">1000001</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= <span class="number">1000001</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(p[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i * i; j &lt; <span class="number">1000001</span>; j += i)</span><br><span class="line">p[j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000001</span>; i++)</span><br><span class="line"><span class="keyword">if</span>(!p[i]) prime.push_back(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>골드바흐의 추측은 정수론의 미해결 문제로, 2보다 큰 모든 짝수는 두개의 소수의 합으로 나타낼 수 있다는 추측이다.<br>1742년 부터 아직까지도 증명은 안 됐지만 작은 범위의 숫자 내에선 부분적으로 증명해볼 수 있다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ll, rr, l, r, sum, tmp;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">    sum = prime[l] + prime[r];</span><br><span class="line">    <span class="keyword">if</span>(sum == tmp) &#123;</span><br><span class="line">      ll = prime[l], rr = prime[r];</span><br><span class="line">      l++;</span><br><span class="line">      r--;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; tmp) &#123;</span><br><span class="line">      l++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      r--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>두개의 위치 인덱스를 조건이 맞을 때 까지 좁혀오며 답을 구하는 투 포인터 알고리즘을 사용하면 쉽다.</p>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/24/20200324-algorithm-theory11/#disqus_thread</comments>
    </item>
    
    <item>
      <title>크루스칼 알고리즘(Kruskal Algorithm) (feat. Union-Find)</title>
      <link>https://yhcho0405.github.io/2020/03/23/20200323-algorithm-theory9/</link>
      <guid>https://yhcho0405.github.io/2020/03/23/20200323-algorithm-theory9/</guid>
      <pubDate>Mon, 23 Mar 2020 03:18:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;크루스칼 알고리즘은 가장 적은 비용으로 모든 노드를 연결하여 최소비용신장트리를 만들 때 사용하는 알고리즘이다.&lt;/p&gt;
&lt;br&gt;

&lt;p&gt;가장 가중치가 작은 간선부터 골라가는 그리디한 방법이며 작동과정 중 사이클이 생기지 않도록 유니온파인드를 사용해 해결한다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>크루스칼 알고리즘은 가장 적은 비용으로 모든 노드를 연결하여 최소비용신장트리를 만들 때 사용하는 알고리즘이다.</p><br><p>가장 가중치가 작은 간선부터 골라가는 그리디한 방법이며 작동과정 중 사이클이 생기지 않도록 유니온파인드를 사용해 해결한다.</p><a id="more"></a><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a8/Prim_Algorithm_0.svg/300px-Prim_Algorithm_0.svg.png" alt><br><em>사용할 그래프</em></p><br><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b4/Kruskal_Algorithm_1.svg/300px-Kruskal_Algorithm_1.svg.png" alt><br><em>가중치가 가장 작은 간선을 선택한다.</em></p><br><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Kruskal_Algorithm_2.svg/300px-Kruskal_Algorithm_2.svg.png" alt><br><em>마찬가지로 가중치가 가장 작은 간선을 선택한다.</em></p><br><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/59/Kruskal_Algorithm_3.svg/300px-Kruskal_Algorithm_3.svg.png" alt><br><em>그 다음으로 작은 간선을 선택한다.</em></p><br><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2e/Kruskal_Algorithm_4.svg/300px-Kruskal_Algorithm_4.svg.png" alt><br><em>간선 AB를 선택하고 사이클이 발생하는 BD는 제외한다.</em></p><br><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f4/Kruskal_Algorithm_5.svg/300px-Kruskal_Algorithm_5.svg.png" alt><br><em>다음으로 작은 간선을 고르고 사이클이 발생하면 제외한다.</em></p><br><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/87/Kruskal_Algorithm_6.svg/300px-Kruskal_Algorithm_6.svg.png" alt><br><em>반복하면 최소 비용 신장 부분 그래프가 완성된다.</em></p><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getParent</span><span class="params">(<span class="keyword">int</span> <span class="built_in">set</span>[], <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">set</span>[x] == x) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">set</span>[x] = getParent(<span class="built_in">set</span>, <span class="built_in">set</span>[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionParent</span><span class="params">(<span class="keyword">int</span> <span class="built_in">set</span>[], <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">a = getParent(<span class="built_in">set</span>, a);</span><br><span class="line">b = getParent(<span class="built_in">set</span>, b);</span><br><span class="line"><span class="keyword">if</span>(a &lt; b) <span class="built_in">set</span>[b] = a;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">set</span>[a] = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> <span class="built_in">set</span>[], <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">a = getParent(<span class="built_in">set</span>, a);</span><br><span class="line">b = getParent(<span class="built_in">set</span>, b);</span><br><span class="line"><span class="keyword">if</span>(a == b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> node[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> distance;</span><br><span class="line">Edge(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> distance) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;node[<span class="number">0</span>] = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;node[<span class="number">1</span>] = b;</span><br><span class="line"><span class="keyword">this</span>-&gt;distance = distance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(Edge &amp;edge) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;distance &lt; edge.distance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; v;</span><br><span class="line"></span><br><span class="line">v.push_back(Edge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>));</span><br><span class="line">v.push_back(Edge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">v.push_back(Edge(<span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>));</span><br><span class="line">v.push_back(Edge(<span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>));</span><br><span class="line">v.push_back(Edge(<span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>));</span><br><span class="line">v.push_back(Edge(<span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>));</span><br><span class="line">v.push_back(Edge(<span class="number">4</span>, <span class="number">5</span>, <span class="number">15</span>));</span><br><span class="line">v.push_back(Edge(<span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>));</span><br><span class="line">v.push_back(Edge(<span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>));</span><br><span class="line">v.push_back(Edge(<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>));</span><br><span class="line">v.push_back(Edge(<span class="number">6</span>, <span class="number">7</span>, <span class="number">11</span>));</span><br><span class="line"></span><br><span class="line">sort(v.begin(), v.end());</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">set</span>[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">set</span>[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!find(<span class="built_in">set</span>, v[i].node[<span class="number">0</span>] - <span class="number">1</span>, v[i].node[<span class="number">1</span>] - <span class="number">1</span>)) &#123;</span><br><span class="line">sum += v[i].distance;</span><br><span class="line">unionParent(<span class="built_in">set</span>, v[i].node[<span class="number">0</span>] - <span class="number">1</span>, v[i].node[<span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드에서 정점 A, B, C, D, E, F, E는 각 1, 2, 3, 4, 5, 6으로 표현했다.<br>최소 비용 신장 트리에서 간선들의 가중치 합을 출력하는 코드다.</p>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/23/20200323-algorithm-theory9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>DFS(Depth First Search)와 BFS(Breath First Search)</title>
      <link>https://yhcho0405.github.io/2020/03/18/20200318-algorithm-theory8/</link>
      <guid>https://yhcho0405.github.io/2020/03/18/20200318-algorithm-theory8/</guid>
      <pubDate>Wed, 18 Mar 2020 09:00:00 GMT</pubDate>
      <description>
      
        &lt;ul&gt;
&lt;li&gt;깊이 우선 탐색(Depth First Search)&lt;ul&gt;
&lt;li&gt;루트 노드에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법&lt;/li&gt;
&lt;li&gt;재귀함수를 기반으로 순환 알고리즘의 형태를 지님.&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;너비 우선 탐색(Breath First Search)&lt;ul&gt;
&lt;li&gt;루트 노드에서 시작해서 인접한 노드를 먼저 탐색하는 방법&lt;/li&gt;
&lt;li&gt;재귀함수로 동작하지 않는다.&lt;/li&gt;
&lt;li&gt;큐를 사용하여 효율적으로 구현 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://blog.hackerearth.com/wp-content/uploads/2015/05/dfsbfs_animation_final.gif&quot; alt=&quot;hackerearth&quot;&gt;&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<ul><li>깊이 우선 탐색(Depth First Search)<ul><li>루트 노드에서 시작해서 다음 분기(branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법</li><li>재귀함수를 기반으로 순환 알고리즘의 형태를 지님.<br></li></ul></li><li>너비 우선 탐색(Breath First Search)<ul><li>루트 노드에서 시작해서 인접한 노드를 먼저 탐색하는 방법</li><li>재귀함수로 동작하지 않는다.</li><li>큐를 사용하여 효율적으로 구현 가능하다.</li></ul></li></ul><p><img src="http://blog.hackerearth.com/wp-content/uploads/2015/05/dfsbfs_animation_final.gif" alt="hackerearth"></p><a id="more"></a><p>미로찾기에서도 사용된다.<br><a href="https://codepen.io/Owlree/details/PPomzo" target="_blank" rel="external nofollow noopener noreferrer">https://codepen.io/Owlree/details/PPomzo</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">1001</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">v[s] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(v[i] == <span class="number">1</span> || ans[s][i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">dfs(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">q.push(s);</span><br><span class="line">v[s] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">s = q.front();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(ans[s][i] == <span class="number">0</span> || v[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">q.push(i);</span><br><span class="line">v[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a, b, s;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">ans[a][b] = ans[b][a] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">dfs(s);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">bfs(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드는 1260번 내 채점 소스코드를 복붙해왔다.<br><a href="https://www.acmicpc.net/problem/1260" target="_blank" rel="external nofollow noopener noreferrer">https://www.acmicpc.net/problem/1260</a></p>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/18/20200318-algorithm-theory8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]스택(Stack)과 큐(Queue)</title>
      <link>https://yhcho0405.github.io/2020/03/17/20200317-algorithm-theory7/</link>
      <guid>https://yhcho0405.github.io/2020/03/17/20200317-algorithm-theory7/</guid>
      <pubDate>Tue, 17 Mar 2020 04:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;스택과 큐는 선형구조로 분류되는 자료구조 중 대표적인 예시이다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>스택과 큐는 선형구조로 분류되는 자료구조 중 대표적인 예시이다.</p><a id="more"></a><ul><li>스택(Stack)<ul><li>push(element) : top에 원소를 추가</li><li>pop() : top에 있는 원소를 삭제</li><li>top() : top에 있는 원소를 반환</li><li>empty() : 스택이 비어있으면 true 아니면 false를 반환</li><li>size() : 스택 사이즈를 반환<br></li></ul></li></ul><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/29/Data_stack.svg/450px-Data_stack.svg.png" alt="wikipedia"></p><br><ul><li>큐(Queue)<ul><li>push(element) : 큐 뒤에 원소를 추가</li><li>pop() : 큐 앞에 있는 원소를 삭제</li><li>front() : 큐 제일 앞에 있는 원소를 반환</li><li>back() : 큐 제일 뒤에 있는 원소를 반환</li><li>empty() : 큐가 비어있으면 true 아니면 false를 반환</li><li>size() : 큐 사이즈를 반환</li></ul></li></ul><br><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/52/Data_Queue.svg/450px-Data_Queue.svg.png" alt="wikipedia"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">s.push(<span class="number">1</span>);</span><br><span class="line">s.push(<span class="number">2</span>);</span><br><span class="line">s.push(<span class="number">3</span>);</span><br><span class="line">s.pop();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (s.empty() ? <span class="string">"empty"</span> : <span class="string">"!empty"</span>) &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">q.push(<span class="number">1</span>);</span><br><span class="line">q.push(<span class="number">2</span>);</span><br><span class="line">q.push(<span class="number">3</span>);</span><br><span class="line">q.pop();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; q.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; q.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; q.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (q.empty() ? <span class="string">"empty"</span> : <span class="string">"!empty"</span>) &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/17/20200317-algorithm-theory7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 1202 - 보석 도둑</title>
      <link>https://yhcho0405.github.io/2020/03/16/20200316-boj1202/</link>
      <guid>https://yhcho0405.github.io/2020/03/16/20200316-boj1202/</guid>
      <pubDate>Mon, 16 Mar 2020 10:29:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;처음엔 무식하게 2중 for문으로 돌려보았다.&lt;br&gt;맞겠지 싶었는데 시간초과가 떴다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>처음엔 무식하게 2중 for문으로 돌려보았다.<br>맞겠지 싶었는데 시간초과가 떴다.</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p;</span><br><span class="line">p b[<span class="number">300001</span>];</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">300001</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">com</span><span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.first == b.first) <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line"><span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; b[i].second &gt;&gt; b[i].first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; c[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(b, b + n, com);</span><br><span class="line">sort(c, c + k);</span><br><span class="line"><span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(c[i] &gt;= b[j].second) &#123;</span><br><span class="line">total += b[j].first;</span><br><span class="line">b[j].second = INT_MAX;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>시간초과가 떴기 때문에 논리가 맞고 틀리고는 모르지만 맞다고 생각하기로 했다.<br><br><br>생각해보니 n과 k가 300,000이라 가정했을 때 최악의 경우 2중 for문에서 300,000^2 번 연산하므로 제한시간 1초는 터무니없었다.<br><br><br>구글링해보니 우선순위 큐를 사용하더라<br>우선순위 큐를 얕게 핥아봤다.<br><br><br>우선순위 큐는 비선형자료구조로써 넣은 순서와 상관없이 우선순위대로 나간다.<br><br><br>max heap의 형태로 원소들이 저장되어 있다고 한다.<br>굉장한 우연으로 이거 풀기 전에 힙 정렬을 공부하고 왔다.</p><p>위 코드를 변형해서 우선순위 큐가지고 짜봤다.</p><ol><li>보석과 가방을 무게기준으로 오름차순 정렬한다.</li><li>가방 무게가 작은 것부터 for문을 돌며 그 가방에 들어갈 수 있는 보석을 우선순위 큐에 넣는다.</li><li>가장 큰 요소를 큐어서 빼서 total에 더한다.</li><li>반복한다.</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; pq;</span><br><span class="line">p b[<span class="number">300001</span>];</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">300001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; b[i].first &gt;&gt; b[i].second;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; c[i];</span><br><span class="line">sort(b, b + n);</span><br><span class="line">sort(c, c + k);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line"><span class="keyword">while</span>(j &lt; n &amp;&amp; b[j].first &lt;= c[i])</span><br><span class="line">pq.push(b[j++].second);</span><br><span class="line"><span class="keyword">if</span>(!pq.empty()) &#123;</span><br><span class="line">total += pq.top();</span><br><span class="line">pq.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>맞았다.</p>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/16/20200316-boj1202/#disqus_thread</comments>
    </item>
    
    <item>
      <title>힙 정렬(Heap Sort)</title>
      <link>https://yhcho0405.github.io/2020/03/16/20200316-algorithm-theory6/</link>
      <guid>https://yhcho0405.github.io/2020/03/16/20200316-algorithm-theory6/</guid>
      <pubDate>Mon, 16 Mar 2020 04:30:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;최대 힙 트리나 최소 힙 트리를 구현해 정렬하는 방법이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/1/1b/Sorting_heapsort_anim.gif&quot; alt=&quot;wikipedia&quot;&gt;&lt;/p&gt;
&lt;p&gt;트리 구조로 보여주는 움짤을 찾아보려 했으나 귀찮았다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>최대 힙 트리나 최소 힙 트리를 구현해 정렬하는 방법이다.</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/1/1b/Sorting_heapsort_anim.gif" alt="wikipedia"></p><p>트리 구조로 보여주는 움짤을 찾아보려 했으나 귀찮았다.</p><a id="more"></a><p>n개의 노드에 대해 완전 이진 트리를 구성한다.<br>heapify과정을 통해 부모노드의 요소가 자식노드의 요소보다 크도록 만든다.<br>가장 첫번째 요소와 가장 마지막 요소를 swap후 다시 heapify한다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> heap[<span class="number">10</span>] = &#123;<span class="number">10</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> c = i;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">int</span> root = (c - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(heap[root] &lt; heap[c]) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = heap[root];</span><br><span class="line">heap[root] = heap[c];</span><br><span class="line">heap[c] = temp;</span><br><span class="line">&#125;</span><br><span class="line">c = root;</span><br><span class="line">&#125; <span class="keyword">while</span>(c != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = heap[<span class="number">0</span>];</span><br><span class="line">heap[<span class="number">0</span>] = heap[i];</span><br><span class="line">heap[i] = temp;</span><br><span class="line"><span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">c = <span class="number">2</span> * root + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(heap[c] &lt; heap[c + <span class="number">1</span>] &amp;&amp; c &lt; i - <span class="number">1</span>) &#123;</span><br><span class="line">c++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(heap[root] &lt; heap[c] &amp;&amp; c &lt; i) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = heap[root];</span><br><span class="line">heap[root] = heap[c];</span><br><span class="line">heap[c] = temp;</span><br><span class="line">&#125;</span><br><span class="line">root = c;</span><br><span class="line">&#125; <span class="keyword">while</span>(c &lt; i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; heap[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드는 최대 힙 트리를 통해 정렬한다.</p><blockquote><p>최대 힙 트리는 부모노드의 요소가 자식노드의 요소보다 크다.</p></blockquote><br><p>추가적인 메모리를 필요로 하지 않으면서 모든 경우에 대해 O(NlogN)의 시간복잡도를 보장받는다.<br>만능처럼 보이지만 실제로는 퀵소트가 더 빠르고 데이터의 상태에 따른 편차가 발생한다. 또 stable을 보장받지 못한다.</p><blockquote><p>heapify과정은 트리의 깊이 만큼 진행되므로 logN 만큼 수행하고 swap하는 과정을 n번 하면 정렬되므로 O(NlogN)의 시간복잡도가 나온다.</p></blockquote><table><thead><tr><th align="center">algorithm</th><th align="center">average</th><th align="center">worst</th><th align="center">best</th><th align="center">space</th></tr></thead><tbody><tr><td align="center">heap</td><td align="center">O(NlogN)</td><td align="center">O(NlogN)</td><td align="center">O(NlogN)</td><td align="center">O(1)</td></tr></tbody></table>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/16/20200316-algorithm-theory6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>병합 정렬(Merge Sort)</title>
      <link>https://yhcho0405.github.io/2020/03/15/20200315-algorithm-theory5/</link>
      <guid>https://yhcho0405.github.io/2020/03/15/20200315-algorithm-theory5/</guid>
      <pubDate>Sun, 15 Mar 2020 10:53:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;퀵소트와 마찬가지로 분할정복 알고리즘이다.&lt;br&gt;재귀함수를 이용해 배열을 절반으로 잘라가며 분할하고 정복한다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif&quot; alt=&quot;wikipedia&quot;&gt;&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>퀵소트와 마찬가지로 분할정복 알고리즘이다.<br>재귀함수를 이용해 배열을 절반으로 잘라가며 분할하고 정복한다.</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif" alt="wikipedia"></p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> m, <span class="keyword">int</span> mid, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = m;</span><br><span class="line"><span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> k = m;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= n) &#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] &lt;= a[j]) &#123;</span><br><span class="line">arr[k] = a[i];</span><br><span class="line">i++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">arr[k] = a[j];</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i &gt; mid) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t = j; t &lt;= n; t++) &#123;</span><br><span class="line">arr[k] = a[t];</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t = i; t &lt;= mid; t++) &#123;</span><br><span class="line">arr[k] = a[t];</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t = m; t &lt;= n; t++) &#123;</span><br><span class="line">a[t] = arr[t];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(m &lt; n) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (m + n) / <span class="number">2</span>;</span><br><span class="line">mergeSort(a, m, mid);</span><br><span class="line">mergeSort(a, mid + <span class="number">1</span>, n);</span><br><span class="line">merge(a, m, mid, n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>] = &#123;<span class="number">10</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">8</span>&#125;;</span><br><span class="line">mergeSort(<span class="built_in">array</span>, <span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드에서 mergeSort()함수는 재귀함수로써 배열을 절반으로 나눠가며 merge()함수를 호출하고, merge()함수에서는 요소들을 비교하며 정렬하는 정복 과정을 수행한다.</p><blockquote><p>mergeSort()는 분할, merge()는 정복의 역할을 한다.</p></blockquote><br><p>피봇에 따라 성능이 다른 퀵소트와 다르게 무조건 절반으로 분할하기 때문에 모든 경우에서 O(NlogN)의 시간복잡도를 보장받는다.<br>다만 데이터를 담을 추가적인 공간이 필요하기 때문에 메모리 측면에서 비효율적이다.</p><table><thead><tr><th align="center">algorithm</th><th align="center">average</th><th align="center">worst</th><th align="center">best</th><th align="center">space</th></tr></thead><tbody><tr><td align="center">merge</td><td align="center">O(NlogN)</td><td align="center">O(NlogN)</td><td align="center">O(NlogN)</td><td align="center">O(n)</td></tr></tbody></table>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/15/20200315-algorithm-theory5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>퀵 정렬(Quick Sort)</title>
      <link>https://yhcho0405.github.io/2020/03/14/20200314-algorithm-theory4/</link>
      <guid>https://yhcho0405.github.io/2020/03/14/20200314-algorithm-theory4/</guid>
      <pubDate>Sat, 14 Mar 2020 03:22:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;분할 정복 알고리즘의 대표적인 예시이며 피봇을 기준으로 정렬해 나가는 정렬 방법이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif&quot; alt=&quot;wikipedia&quot;&gt;&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>분할 정복 알고리즘의 대표적인 예시이며 피봇을 기준으로 정렬해 나가는 정렬 방법이다.</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif" alt="wikipedia"></p><a id="more"></a><p>분할과정과 정복과정으로 나누어져 있으며, 피봇을 정한 뒤 피봇을 기준으로 작거나 큰것으로 나눠간다.<br>퀵소트의 피봇 선정 방식은 여러가지가 존재한다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">10</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(start &gt;= end) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> key = start;</span><br><span class="line"><span class="keyword">int</span> i = start + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = end;</span><br><span class="line"><span class="keyword">int</span> tmp;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line"><span class="keyword">while</span>(arr[i] &lt;= arr[key]) &#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(arr[j] &gt;= arr[key] &amp;&amp; j &gt; start) &#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i &gt; j) &#123;</span><br><span class="line">tmp = arr[j];</span><br><span class="line">arr[j] = arr[key];</span><br><span class="line">arr[key] = tmp;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tmp = arr[j];</span><br><span class="line">arr[j] = arr[i];</span><br><span class="line">arr[i] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">quickSort(arr, start, j - <span class="number">1</span>);</span><br><span class="line">quickSort(arr, j + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">quickSort(arr, <span class="number">0</span>, num - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드는 피봇을 왼쪽의 요소로 잡는 알고리즘이다.<br><br><br>퀵소트는 이름에서 알 수 있드시 매우 빠른 정렬 알고리즘에 속한다.<br>하지만 최악의 경우 n^2으로 작동할 여지가 있다.<br>아이러니하게도 최악의 경우는 배열이 이미 정렬 되어있을 때 발생한다.<br><br><br>이 문제를 해결하기 위해 피봇을 랜덤으로 선정하거나 중위법을 이용하는 방법, 작은 분할 범위의 정렬은 삽입정렬을 이용하는 방법등이 있다.</p><blockquote><p>여담으로 C++ STL #include &lt;algorithm&gt; 라이브러리의 sort() 함수는 퀵소트를 기반으로 작성되었다.<br>(모든 경우에서 O(n log n)을 보장한다.)</p></blockquote><br><table><thead><tr><th align="center">algorithm</th><th align="center">average</th><th align="center">worst</th><th align="center">best</th><th align="center">space</th></tr></thead><tbody><tr><td align="center">quick</td><td align="center">O(NlogN)</td><td align="center">O(N^2)</td><td align="center">O(NlogN)</td><td align="center">O(logN)</td></tr></tbody></table>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/14/20200314-algorithm-theory4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>삽입 정렬(Insertion Sort)</title>
      <link>https://yhcho0405.github.io/2020/03/09/20200309-algorithm-theory3/</link>
      <guid>https://yhcho0405.github.io/2020/03/09/20200309-algorithm-theory3/</guid>
      <pubDate>Mon, 09 Mar 2020 05:24:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;배열의 모든 요소를 앞에서부터 이미 정렬된 배열과 비교하여 적절한 위치를 찾는 정렬 방법이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://media.geeksforgeeks.org/wp-content/uploads/insertionsort.png&quot; alt=&quot;geeksforgeeks&quot;&gt;&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>배열의 모든 요소를 앞에서부터 이미 정렬된 배열과 비교하여 적절한 위치를 찾는 정렬 방법이다.</p><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/insertionsort.png" alt="geeksforgeeks"></p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp, arr[<span class="number">10</span>] = &#123;<span class="number">10</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> j = i;</span><br><span class="line"><span class="keyword">while</span>(arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">tmp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>최악의 경우<br><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/6fd040d16ddcc273c6928e0e06485727f2c3c2cf" alt="wikipedia"><br>번의 비교를 하게 되므로, O(n^2) 가 된다.<br><br><br>역시나 선택정렬이나 버블정렬과 같은 시간복잡도를 가지지만 실제론 삽입정렬이 가장 빠르다.<br>필요할 때만 위치를 바꾸기 때문에 거의 정렬이 된 상태일 때 가장 빠르고, 자원을 덜 사용하여 효율적으로 작동한다.<br>때문에 다른 정렬 알고리즘의 일부로 사용되는 경우가 있다.<br><br></p><table><thead><tr><th align="center">algorithm</th><th align="center">average</th><th align="center">worst</th><th align="center">best</th><th align="center">space</th></tr></thead><tbody><tr><td align="center">insert</td><td align="center">O(N^2)</td><td align="center">O(N^2)</td><td align="center">O(N)</td><td align="center">O(1)</td></tr></tbody></table>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/03/09/20200309-algorithm-theory3/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>

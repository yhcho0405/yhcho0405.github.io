<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>yhcho0405</title>
    <link>https://yhcho0405.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>내가 보려고 쓰는 블로그</description>
    <pubDate>Tue, 26 May 2020 09:06:00 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[C++]BOJ 6603 - 로또</title>
      <link>https://yhcho0405.github.io/2020/05/26/20200526-boj6603/</link>
      <guid>https://yhcho0405.github.io/2020/05/26/20200526-boj6603/</guid>
      <pubDate>Tue, 26 May 2020 09:06:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;주어진 집합에서 수 6개를 고르는 경우의 수를 완전탐색하는 문제다.&lt;br&gt;사전순 출력이기 때문에 dfs로 가지치기를 해 나가면 된다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>주어진 집합에서 수 6개를 고르는 경우의 수를 완전탐색하는 문제다.<br>사전순 출력이기 때문에 dfs로 가지치기를 해 나가면 된다.</p><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> k, arr[<span class="number">15</span>], ans[<span class="number">15</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(c == <span class="number">6</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = s; i &lt; k; i++) &#123;</span><br><span class="line">ans[c] = arr[i];</span><br><span class="line">dfs(i + <span class="number">1</span>, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; k &amp;&amp; k) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>구조 자체가 이해했더라도 갑자기 떠올릴 수 없는 형태다.</p>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/05/26/20200526-boj6603/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 11403 - 경로 찾기</title>
      <link>https://yhcho0405.github.io/2020/05/24/20200524-boj11403/</link>
      <guid>https://yhcho0405.github.io/2020/05/24/20200524-boj11403/</guid>
      <pubDate>Sun, 24 May 2020 14:30:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;방향성을 가지는 그래프를 탐색하는 것으로 dfs, bfs 모두 가능하다.&lt;br&gt;이 문제는 dfs로 풀어봤다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>방향성을 가지는 그래프를 탐색하는 것으로 dfs, bfs 모두 가능하다.<br>이 문제는 dfs로 풀어봤다.</p><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, arr[<span class="number">102</span>][<span class="number">102</span>], v[<span class="number">102</span>][<span class="number">102</span>], ans[<span class="number">102</span>][<span class="number">102</span>], cs;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!arr[s][i] || v[s][i]) <span class="keyword">continue</span>;</span><br><span class="line">v[s][i] = <span class="number">1</span>;</span><br><span class="line">ans[cs][i] = <span class="number">1</span>;</span><br><span class="line">dfs(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; arr[i][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span>(v));</span><br><span class="line">cs = i;</span><br><span class="line">dfs(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/05/24/20200524-boj11403/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 11724 - 연결 요소의 개수</title>
      <link>https://yhcho0405.github.io/2020/05/24/20200524-boj11724/</link>
      <guid>https://yhcho0405.github.io/2020/05/24/20200524-boj11724/</guid>
      <pubDate>Sun, 24 May 2020 08:24:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;단순한 탐색 문제다.&lt;br&gt;모든 노드를 간선을 따라 탐색하며 방문처리를 한 후, 방문을 안한 노드가 있다면 모든 노드를 방문할 때 까지 탐색하고 총 탐색 횟수를 출력하면 된다.&lt;br&gt;dfs와 bfs모두 쓸 수 있다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>단순한 탐색 문제다.<br>모든 노드를 간선을 따라 탐색하며 방문처리를 한 후, 방문을 안한 노드가 있다면 모든 노드를 방문할 때 까지 탐색하고 총 탐색 횟수를 출력하면 된다.<br>dfs와 bfs모두 쓸 수 있다.</p><a id="more"></a><br>bfs로 이 문제 풀다가 시간초과가 났는데 얼타다가 생각해보니 방문처리를 큐에서 뺀 후가 아니라 넣은 후에 해줘야 했다는걸 간과했다.기억할것<br><p>###bfs</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, arr[<span class="number">1002</span>][<span class="number">1002</span>], vs[<span class="number">1002</span>], u, v, tmp, ans;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">q.push(s);</span><br><span class="line"><span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">s = q.front(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!arr[s][i] || vs[i]) <span class="keyword">continue</span>;</span><br><span class="line">q.push(i);</span><br><span class="line">vs[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">while</span>(m--) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">arr[u][v] = arr[v][u] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span>(!vs[i]) &#123;</span><br><span class="line">bfs(i);</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>###dfs</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, arr[<span class="number">1002</span>][<span class="number">1002</span>], vs[<span class="number">1002</span>], u, v, tmp, ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">vs[s] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(vs[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(arr[s][i]) dfs(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">while</span>(m--) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">arr[u][v] = arr[v][u] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span>(!vs[i]) &#123;</span><br><span class="line">dfs(i);</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/05/24/20200524-boj11724/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 14502 - 연구소</title>
      <link>https://yhcho0405.github.io/2020/05/24/20200524-boj14502/</link>
      <guid>https://yhcho0405.github.io/2020/05/24/20200524-boj14502/</guid>
      <pubDate>Sun, 24 May 2020 07:24:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;주어진 지도의 크기가 최대 &lt;code&gt;8 * 8&lt;/code&gt;이므로 바이러스와 벽이 아무것도 없다고 가정하면 벽을 세울 수 있는 경우의 수는 &lt;code&gt;64C3&lt;/code&gt; 대략, &lt;code&gt;40,000&lt;/code&gt; 가지이다.&lt;br&gt;그러므로 벽을 세우는 문제는 완전탐색으로 해결할 수 있다.&lt;br&gt;벽을 세우는 모든 방법의 수 마다 바이러스가 퍼지는 경우를 dfs로 탐색하고 안전영역이 가장 큰 경우의 수를 기억해 마지막에 &lt;code&gt;전체 칸의 갯수 - 퍼진 바이러스의 갯수 - 처음에 있던 벽의 갯수 - 3&lt;/code&gt;을 출력한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;bfs로도 풀 수 있다. 귀찮아서 안 해봤다.&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>주어진 지도의 크기가 최대 <code>8 * 8</code>이므로 바이러스와 벽이 아무것도 없다고 가정하면 벽을 세울 수 있는 경우의 수는 <code>64C3</code> 대략, <code>40,000</code> 가지이다.<br>그러므로 벽을 세우는 문제는 완전탐색으로 해결할 수 있다.<br>벽을 세우는 모든 방법의 수 마다 바이러스가 퍼지는 경우를 dfs로 탐색하고 안전영역이 가장 큰 경우의 수를 기억해 마지막에 <code>전체 칸의 갯수 - 퍼진 바이러스의 갯수 - 처음에 있던 벽의 갯수 - 3</code>을 출력한다.</p><blockquote><p>bfs로도 풀 수 있다. 귀찮아서 안 해봤다.</p></blockquote><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, arr[<span class="number">10</span>][<span class="number">10</span>], v[<span class="number">10</span>][<span class="number">10</span>], ay, ax, by, bx, cy, cx, tmp, dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, tx, ty, wal, vir = <span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">v[y][x] = <span class="number">1</span>; tmp++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">tx = x + dx[i]; ty = y + dy[i];</span><br><span class="line"><span class="keyword">if</span>(tx &gt; m || ty &gt; n || tx &lt; <span class="number">1</span> || ty &lt; <span class="number">1</span> || v[ty][tx] || arr[ty][tx]) <span class="keyword">continue</span>;</span><br><span class="line">dfs(tx, ty);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span>(v)); tmp = <span class="number">0</span>;</span><br><span class="line">arr[ay][ax] = <span class="number">1</span>; arr[by][bx] = <span class="number">1</span>; arr[cy][cx] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line"><span class="keyword">if</span>(arr[i][j] == <span class="number">2</span>) dfs(j, i);</span><br><span class="line">arr[ay][ax] = <span class="number">0</span>; arr[by][bx] = <span class="number">0</span>; arr[cy][cx] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; arr[i][j];</span><br><span class="line"><span class="keyword">if</span>(arr[i][j] == <span class="number">1</span>) wal++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(ay = <span class="number">1</span>; ay &lt;= n; ay++)</span><br><span class="line"><span class="keyword">for</span>(ax = <span class="number">1</span>; ax &lt;= m; ax++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[ay][ax]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(by = <span class="number">1</span>; by &lt;= n; by++)</span><br><span class="line"><span class="keyword">for</span>(bx = <span class="number">1</span>; bx &lt;= m; bx++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[by][bx]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(cy = <span class="number">1</span>; cy &lt;= n; cy++)</span><br><span class="line"><span class="keyword">for</span>(cx = <span class="number">1</span>; cx &lt;= m; cx++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[cy][cx]) <span class="keyword">continue</span>;</span><br><span class="line">vir = min(vir, solve());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n * m - vir - wal - <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/05/24/20200524-boj14502/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 1012 - 유기농 배추</title>
      <link>https://yhcho0405.github.io/2020/05/21/20200521-boj1012/</link>
      <guid>https://yhcho0405.github.io/2020/05/21/20200521-boj1012/</guid>
      <pubDate>Wed, 20 May 2020 17:12:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;배열을 순회하며 배추를 만나면 그 지점부터 bfs나 dfs를 돌리며 모두 0으로 초기화한다.&lt;br&gt;이 과정을 반복해 모둔 배추 영역을 찾은 후 그 영역의 갯수를 출력하면 된다.&lt;br&gt;bfs와 dfs모두 다뤄보겠다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>배열을 순회하며 배추를 만나면 그 지점부터 bfs나 dfs를 돌리며 모두 0으로 초기화한다.<br>이 과정을 반복해 모둔 배추 영역을 찾은 후 그 영역의 갯수를 출력하면 된다.<br>bfs와 dfs모두 다뤄보겠다.</p><a id="more"></a><br><p>###bfs</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, m, n, k, sx, sy, xx, yy, cx, cy, arr[<span class="number">52</span>][<span class="number">52</span>], dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, ans;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qx, qy;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(!qx.empty()) &#123;</span><br><span class="line">sx = qx.front(); qx.pop();</span><br><span class="line">sy = qy.front(); qy.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">xx = sx + dx[i];</span><br><span class="line">yy = sy + dy[i];</span><br><span class="line"><span class="keyword">if</span>(xx &gt; m || yy &gt; n || xx &lt; <span class="number">1</span> || yy &lt; <span class="number">1</span> || !arr[yy][xx]) <span class="keyword">continue</span>;</span><br><span class="line">arr[yy][xx] = <span class="number">0</span>;</span><br><span class="line">qx.push(xx), qy.push(yy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t--) &#123;</span><br><span class="line"><span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">while</span>(k--) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; cx &gt;&gt; cy;</span><br><span class="line">arr[cy + <span class="number">1</span>][cx + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line"><span class="keyword">if</span>(arr[i][j]) &#123;</span><br><span class="line">qx.push(j), qy.push(i);</span><br><span class="line">bfs(j, i);</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>###dfs</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, m, n, k, cx, cy, xx, yy, arr[<span class="number">52</span>][<span class="number">52</span>], dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">arr[y][x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">xx = x + dx[i];</span><br><span class="line">yy = y + dy[i];</span><br><span class="line"><span class="keyword">if</span>(xx &gt; m || yy &gt; n || xx &lt; <span class="number">1</span> || yy &lt; <span class="number">1</span> || !arr[yy][xx]) <span class="keyword">continue</span>;</span><br><span class="line">dfs(xx, yy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t--) &#123;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line"><span class="keyword">while</span>(k--) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; cx &gt;&gt; cy;</span><br><span class="line">arr[cy + <span class="number">1</span>][cx + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line"><span class="keyword">if</span>(arr[i][j]) &#123;</span><br><span class="line">dfs(j, i);</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/05/21/20200521-boj1012/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 1697 - 숨바꼭질</title>
      <link>https://yhcho0405.github.io/2020/05/20/20200520-boj1697/</link>
      <guid>https://yhcho0405.github.io/2020/05/20/20200520-boj1697/</guid>
      <pubDate>Wed, 20 May 2020 06:54:00 GMT</pubDate>
      <description>
      
        &lt;p&gt; bfs로 &lt;code&gt;n + 1&lt;/code&gt;, &lt;code&gt;n - 1&lt;/code&gt;, &lt;code&gt;n * 2&lt;/code&gt;의 경우를 계속 탐색해나가며 동생의 위치에 가장 먼저 도달한 경우의 횟수를 출력하면 된다.&lt;br&gt; 트리를 그려보면 알겠지만 중복되는 경우가 자주 등장해서 메모이제이션을 사용하지 않으면 메모리 초과가 뜬다.&lt;br&gt; 방문을 저장할 배열 하나를 만들어준다.  &lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p> bfs로 <code>n + 1</code>, <code>n - 1</code>, <code>n * 2</code>의 경우를 계속 탐색해나가며 동생의 위치에 가장 먼저 도달한 경우의 횟수를 출력하면 된다.<br> 트리를 그려보면 알겠지만 중복되는 경우가 자주 등장해서 메모이제이션을 사용하지 않으면 메모리 초과가 뜬다.<br> 방문을 저장할 배열 하나를 만들어준다.  </p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, sn, sc, ans, v[<span class="number">101010</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q, cnt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">q.push(n), cnt.push(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">sn = q.front(); q.pop();</span><br><span class="line">sc = cnt.front(); cnt.pop();</span><br><span class="line"><span class="keyword">if</span>(sn &lt; <span class="number">0</span> || sn &gt; <span class="number">100000</span>) <span class="keyword">continue</span>; <span class="keyword">if</span>(v[sn]) <span class="keyword">continue</span>; <span class="comment">// runtime</span></span><br><span class="line">v[sn] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(sn == k) &#123;</span><br><span class="line">ans = sc;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">q.push(sn * <span class="number">2</span>), cnt.push(sc + <span class="number">1</span>);</span><br><span class="line">q.push(sn + <span class="number">1</span>), cnt.push(sc + <span class="number">1</span>);</span><br><span class="line">q.push(sn - <span class="number">1</span>), cnt.push(sc + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/05/20/20200520-boj1697/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 7576 - 토마토</title>
      <link>https://yhcho0405.github.io/2020/05/20/20200520-boj7576/</link>
      <guid>https://yhcho0405.github.io/2020/05/20/20200520-boj7576/</guid>
      <pubDate>Wed, 20 May 2020 06:04:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;익은 토마토의 위치를 전부 큐에 넣고 bfs를 돌린다.&lt;br&gt;익혀진 토마토의 배열 위치에 익혀진 날짜의 값을 저장한다.  &lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>익은 토마토의 위치를 전부 큐에 넣고 bfs를 돌린다.<br>익혀진 토마토의 배열 위치에 익혀진 날짜의 값을 저장한다.  </p><a id="more"></a><p>결과적으로 익은 토마토의 주변에 안 익은 토마토가 있다면 <code>익은토마토의 인덱스에 담긴 값 + 1</code>을 안 익은 토마토의 값에 넣은 후 위치를 큐에 넣는다.</p><p>bfs가 끝나고 배열을 전부 순회하면서 0이 있다면 못 익힌 토마토가 있다는 것이므로 -1을 출력하고 아니라면 담긴 값 중 가장 큰 값을 출력하면 된다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, arr[<span class="number">1002</span>][<span class="number">1002</span>], x, y, cx, cy, dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, ans;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qx, qy;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; arr[i][j];</span><br><span class="line"><span class="keyword">if</span>(arr[i][j] == <span class="number">1</span>) qx.push(j), qy.push(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!qx.empty()) &#123;</span><br><span class="line">x = qx.front(); qx.pop();</span><br><span class="line">y = qy.front(); qy.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">cx = x + dx[i];</span><br><span class="line">cy = y + dy[i];</span><br><span class="line"><span class="keyword">if</span>(cx &gt; n || cy &gt; m || cx &lt; <span class="number">1</span> || cy &lt; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(arr[cy][cx] == <span class="number">0</span>) &#123;</span><br><span class="line">arr[cy][cx] = arr[y][x] + <span class="number">1</span>;</span><br><span class="line">qx.push(cx), qy.push(cy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!arr[i][j]) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"-1"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans &lt; arr[i][j]) ans = arr[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/05/20/20200520-boj7576/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 2667 - 단지번호붙이기</title>
      <link>https://yhcho0405.github.io/2020/05/19/20200519-boj2667/</link>
      <guid>https://yhcho0405.github.io/2020/05/19/20200519-boj2667/</guid>
      <pubDate>Tue, 19 May 2020 14:08:00 GMT</pubDate>
      <description>
      
        &lt;p&gt; 지도를 배열에 저장하고 칸별로 분기를 돌며 집이 있는 칸을 만나면 인접한 집들을 탐색한다.&lt;br&gt; 위 과정을 반복해 단지를 나누고 집의 수를 벡터에 저장한 후 정렬해 출력한다.&lt;br&gt; bfs dfs 두 방법 모두 다뤄보겠다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p> 지도를 배열에 저장하고 칸별로 분기를 돌며 집이 있는 칸을 만나면 인접한 집들을 탐색한다.<br> 위 과정을 반복해 단지를 나누고 집의 수를 벡터에 저장한 후 정렬해 출력한다.<br> bfs dfs 두 방법 모두 다뤄보겠다.</p><a id="more"></a><p>두 방법 모두 한번 탐색한 집은 배열에서 삭제하므로 다음 분기에서 중복탐색하지 않는다.<br>덕분에 bfs에서 삭제 횟수가 해당 단지의 집 수가 된다.<br><br></p><p>bfs는 처음으로 집을 발견한 위치를 기준으로 상하좌우를 탐색하며 큐에 넣는다.<br>탐색하며 삭제한 집의 갯수가 곧 단지내의 집 수이기 때문에 그 값을 리턴한다.<br>리턴된 값을 벡터에 넣고 정렬 후 출력한다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, v[<span class="number">27</span>][<span class="number">27</span>], sx, sy, sc, cnt;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qx, qy;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">cnt = <span class="number">0</span>;</span><br><span class="line">qx.push(x), qy.push(y);</span><br><span class="line"><span class="keyword">while</span>(!(qx.empty() &amp;&amp; qy.empty())) &#123;</span><br><span class="line">sx = qx.front(); qx.pop();</span><br><span class="line">sy = qy.front(); qy.pop();</span><br><span class="line"><span class="keyword">if</span>(!v[sy][sx]) <span class="keyword">continue</span>;</span><br><span class="line">v[sy][sx] = <span class="number">0</span>; cnt++;</span><br><span class="line"><span class="keyword">if</span>(v[sy - <span class="number">1</span>][sx]) qx.push(sx), qy.push(sy - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(v[sy + <span class="number">1</span>][sx]) qx.push(sx), qy.push(sy + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(v[sy][sx - <span class="number">1</span>]) qx.push(sx - <span class="number">1</span>), qy.push(sy);</span><br><span class="line"><span class="keyword">if</span>(v[sy][sx + <span class="number">1</span>]) qx.push(sx + <span class="number">1</span>), qy.push(sy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%1d"</span>, &amp;v[i][j]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="keyword">if</span>(v[i][j]) ans.push_back(bfs(j, i));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">sort(ans.begin(), ans.end());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>dfs를 사용한 방법도 마찬가지로 지도 전체를 돌며 집을 발견한 위치를 시작점으로 탐색을 수행한다.<br>상하좌우 더 이상 이동할 공간이 없을때까지 재귀적으로 탐색하고 1씩 더해나간다.<br>최종적으로 dfs 탐색과정을 트리를 그리면 최하단 노드에는 1이 담기고 각 부모노드에는 자식노드 들의 합이 담겨있는 형태가 될 것이다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, arr[<span class="number">27</span>][<span class="number">27</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!arr[y][x]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">arr[y][x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> dfs(x - <span class="number">1</span>, y) + dfs(x + <span class="number">1</span>, y) + dfs(x, y - <span class="number">1</span>) + dfs(x, y + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%1d"</span>, &amp;arr[i][j]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="keyword">if</span>(arr[i][j]) ans.push_back(dfs(j, i));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">sort(ans.begin(), ans.end());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/05/19/20200519-boj2667/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 2178 - 미로 탐색</title>
      <link>https://yhcho0405.github.io/2020/05/19/20200519-boj2178/</link>
      <guid>https://yhcho0405.github.io/2020/05/19/20200519-boj2178/</guid>
      <pubDate>Tue, 19 May 2020 09:10:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;각 칸에서 이동할 수 있는 칸으로 탐색해나가 도착점에 도달하면 그 이동 거리가 최소 거리가 되므로 bfs를 사용하면 빠르게 해결할 수 있다.&lt;br&gt;dfs로도 해결할 수 있지만 한번 방문한 칸은 다신 방문하지 않는 bfs와는 다르게 모든 경로를 탐색하므로 작동시간이 다소 오래걸린다.&lt;/p&gt;
&lt;p&gt;두 방법 모두 다뤄보겠다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>각 칸에서 이동할 수 있는 칸으로 탐색해나가 도착점에 도달하면 그 이동 거리가 최소 거리가 되므로 bfs를 사용하면 빠르게 해결할 수 있다.<br>dfs로도 해결할 수 있지만 한번 방문한 칸은 다신 방문하지 않는 bfs와는 다르게 모든 경로를 탐색하므로 작동시간이 다소 오래걸린다.</p><p>두 방법 모두 다뤄보겠다.</p><a id="more"></a><br><p>우선 bfs를 사용한 방법은 x, y방향, 이동횟수 큐를 만들어서 각각 1을 넣어준다. (<code>시작점 좌표(1, 1)</code>, <code>시작 이동횟수 = 1</code>)<br>이후 상하좌우로 이동할 수 있는 칸을 큐에 계속 넣어주고 이동횟수도 업데이트한다.<br>큐가 비었거나 도착점에 도달하면 종료 후 이동횟수를 출력한다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qx, qy, qc;</span><br><span class="line"><span class="keyword">int</span> n, m, arr[<span class="number">101</span>][<span class="number">101</span>], v[<span class="number">101</span>][<span class="number">101</span>], sx, sy, sc, ans;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x &gt; m || x &lt; <span class="number">1</span> || y &gt; n || y &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(!arr[y][x]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(v[y][x]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%1d"</span>, &amp;arr[i][j]);</span><br><span class="line">qx.push(<span class="number">1</span>), qy.push(<span class="number">1</span>), qc.push(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(!qx.empty()) &#123;</span><br><span class="line">sx = qx.front(); qx.pop();</span><br><span class="line">sy = qy.front(); qy.pop();</span><br><span class="line">sc = qc.front(); qc.pop();</span><br><span class="line"><span class="keyword">if</span>(v[sy][sx]) <span class="keyword">continue</span>;</span><br><span class="line">v[sy][sx] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(sx == m &amp;&amp; sy == n) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(chk(sx - <span class="number">1</span>, sy)) qx.push(sx - <span class="number">1</span>), qy.push(sy), qc.push(sc + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(chk(sx + <span class="number">1</span>, sy)) qx.push(sx + <span class="number">1</span>), qy.push(sy), qc.push(sc + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(chk(sx, sy - <span class="number">1</span>)) qx.push(sx), qy.push(sy - <span class="number">1</span>), qc.push(sc + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(chk(sx, sy + <span class="number">1</span>)) qx.push(sx), qy.push(sy + <span class="number">1</span>), qc.push(sc + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>dfs를 사용한 방법은 앞서 설명한 bfs보다 간단하다.<br>이동할 수 있는 모든 칸을 찾으며 각 칸까지 도달하는데 최소 이동횟수를 저장한다.<br>도착점에 저장된 이동횟수를 출력한다.<br>모든 경우를 탐색하므로 시간이 오래 걸린다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, arr[<span class="number">101</span>][<span class="number">101</span>], ans[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!arr[y][x]) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(x &lt; <span class="number">1</span> || y &lt; <span class="number">1</span> || x &gt; m || y &gt; n) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(ans[y][x] &lt;= cnt &amp;&amp; ans[y][x]) <span class="keyword">return</span>;</span><br><span class="line">ans[y][x] = cnt;</span><br><span class="line">dfs(x - <span class="number">1</span>, y, cnt + <span class="number">1</span>);</span><br><span class="line">dfs(x + <span class="number">1</span>, y, cnt + <span class="number">1</span>);</span><br><span class="line">dfs(x, y - <span class="number">1</span>, cnt + <span class="number">1</span>);</span><br><span class="line">dfs(x, y + <span class="number">1</span>, cnt + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%1d"</span>, &amp;arr[i][j]);</span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/05/19/20200519-boj2178/#disqus_thread</comments>
    </item>
    
    <item>
      <title>파이썬 - 네이버 영화 크롤링</title>
      <link>https://yhcho0405.github.io/2020/04/15/20200415-python-movie-crawling/</link>
      <guid>https://yhcho0405.github.io/2020/04/15/20200415-python-movie-crawling/</guid>
      <pubDate>Wed, 15 Apr 2020 13:50:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;네이버 영화 페이지에서 현재 상영중인 영화와 정보들을 가져오고 각 영화에 달린 댓글들도 가져오는 파이썬 크롤러를 만들어 봤다.&lt;br&gt;모듈은 requests와 beautifulsoup4를 사용했다.&lt;br&gt;requests로 HTTP요청을 보내고 beautifulsoup4는 html구문을 분석할 때 사용했다.&lt;br&gt;마지막으로 크롤링이 끝난 후 csv형식으로 내보낸다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>네이버 영화 페이지에서 현재 상영중인 영화와 정보들을 가져오고 각 영화에 달린 댓글들도 가져오는 파이썬 크롤러를 만들어 봤다.<br>모듈은 requests와 beautifulsoup4를 사용했다.<br>requests로 HTTP요청을 보내고 beautifulsoup4는 html구문을 분석할 때 사용했다.<br>마지막으로 크롤링이 끝난 후 csv형식으로 내보낸다.</p><a id="more"></a><p><strong><em>내용 추가 예정</em></strong></p><blockquote><p><a href="https://docs.google.com/spreadsheets/d/19u8H0vsYq4FNuS_yd3jA89wlkTdBUtSbmP7zmMYeVz0/edit?usp=sharing" rel="external nofollow noopener noreferrer" target="_blank">크롤링 결과 csv파일</a></p></blockquote><blockquote><p><a href="https://test.yhcho0405.repl.run" rel="external nofollow noopener noreferrer" target="_blank">이 링크를 통해 repl.it에서 가상으로 테스트 할 수 있다.</a></p></blockquote><blockquote><p><a href="https://github.com/yhcho0405/python_movie_crawling" rel="external nofollow noopener noreferrer" target="_blank">소스코드</a></p></blockquote><br><p>####2020년 4월 21일<br>너무 허전해보여서 flask로 웹에서 돌아가게 만들어 보았다.</p><blockquote><p><a href="https://scrapper.yhcho0405.repl.co" rel="external nofollow noopener noreferrer" target="_blank">역시나 repl.it의 서버를 사용하기 때문에 크롤링 속도가 굉장히 느리다.</a><br>page 값으로 0을 넣으면 빠른 결과를 얻을 수 있다.<br>대신 댓글은 가져오지 못한다.</p></blockquote>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/04/15/20200415-python-movie-crawling/#disqus_thread</comments>
    </item>
    
    <item>
      <title>파이썬 문법 사전 - if, for, 함수</title>
      <link>https://yhcho0405.github.io/2020/04/13/20200413-python2/</link>
      <guid>https://yhcho0405.github.io/2020/04/13/20200413-python2/</guid>
      <pubDate>Mon, 13 Apr 2020 11:18:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;if문&quot;&gt;&lt;a href=&quot;#if문&quot; class=&quot;headerlink&quot; title=&quot;if문&quot;&gt;&lt;/a&gt;if문&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;if 후에 여러개의 elif가 있을 수 있고 else는 선택적으로 사용할 수 있다.&lt;/p&gt;
&lt;figure class=&quot;highlight py&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;x = int(input(&lt;span class=&quot;string&quot;&gt;&quot;Please enter an integer: &quot;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Please enter an integer: &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; x &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;... &lt;/span&gt;    x = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;... &lt;/span&gt;    print(&lt;span class=&quot;string&quot;&gt;&#39;Negative changed to zero&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;... &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; x == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;... &lt;/span&gt;    print(&lt;span class=&quot;string&quot;&gt;&#39;Zero&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;... &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;elif&lt;/span&gt; x == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;... &lt;/span&gt;    print(&lt;span class=&quot;string&quot;&gt;&#39;Single&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;... &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;... &lt;/span&gt;    print(&lt;span class=&quot;string&quot;&gt;&#39;More&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;More&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="if문"><a href="#if문" class="headerlink" title="if문"></a>if문</h2><hr><p>if 후에 여러개의 elif가 있을 수 있고 else는 선택적으로 사용할 수 있다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = int(input(<span class="string">"Please enter an integer: "</span>))</span><br><span class="line">Please enter an integer: <span class="number">42</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>    x = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Negative changed to zero'</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">elif</span> x == <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Zero'</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">elif</span> x == <span class="number">1</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Single'</span>)</span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'More'</span>)</span><br><span class="line">...</span><br><span class="line">More</span><br></pre></td></tr></table></figure><a id="more"></a><br><h2 id="for문"><a href="#for문" class="headerlink" title="for문"></a>for문</h2><hr><p>파이썬에서 for문은 임의의 시퀀스(리스트나 문자열)의 항목들을 순서대로 이터레이션 할 수 있다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Measure some strings:</span></span><br><span class="line"><span class="meta">... </span>words = [<span class="string">'cat'</span>, <span class="string">'window'</span>, <span class="string">'defenestrate'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line"><span class="meta">... </span>    print(w, len(w))</span><br><span class="line">...</span><br><span class="line">cat <span class="number">3</span></span><br><span class="line">window <span class="number">6</span></span><br><span class="line">defenestrate <span class="number">12</span></span><br></pre></td></tr></table></figure><p>시퀀스를 이터레이트 하는 동안 시퀀스를 수정하는 것은 원래의 의도대로 동작하지 않을 수도 있다.<br>이 경우 보통 복사본을 만드는 방법을 사용한다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Strategy:  Iterate over a copy</span></span><br><span class="line"><span class="keyword">for</span> user, status <span class="keyword">in</span> users.copy().items():</span><br><span class="line">    <span class="keyword">if</span> status == <span class="string">'inactive'</span>:</span><br><span class="line">        <span class="keyword">del</span> users[user]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Strategy:  Create a new collection</span></span><br><span class="line">active_users = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> user, status <span class="keyword">in</span> users.items():</span><br><span class="line">    <span class="keyword">if</span> status == <span class="string">'active'</span>:</span><br><span class="line">        active_users[user] = status</span><br></pre></td></tr></table></figure><br><h3 id="range-함수"><a href="#range-함수" class="headerlink" title="range() 함수"></a>range() 함수</h3><hr><p>숫자들의 시퀀스로 이터레이트 해야 할 때 range()를 사용하면 편리하다. range()는 수열을 만든다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">'Mary'</span>, <span class="string">'had'</span>, <span class="string">'a'</span>, <span class="string">'little'</span>, <span class="string">'lamb'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</span><br><span class="line"><span class="meta">... </span>    print(i, a[i])</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> Mary</span><br><span class="line"><span class="number">1</span> had</span><br><span class="line"><span class="number">2</span> a</span><br><span class="line"><span class="number">3</span> little</span><br><span class="line"><span class="number">4</span> lamb</span><br></pre></td></tr></table></figure><p>주의해야 할 점은 range()는 리스트 처럼 동작하지만 리스트가 아니라는 점이다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(range(<span class="number">10</span>))</span><br><span class="line">range(<span class="number">0</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>이처럼 리스트를 출력하지 않는다.<br>이터레이트할 때 원하는 시퀀스 항목들을 순서대로 돌려주는 객체이지만, 실제로 리스트를 만들지 않아서 공간을 절약한다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum(range(<span class="number">4</span>))  <span class="comment"># 0 + 1 + 2 + 3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(<span class="number">4</span>))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>이런것도 가능하다.</p><br><h3 id="break-continue-for-else문"><a href="#break-continue-for-else문" class="headerlink" title="break, continue, for-else문"></a>break, continue, for-else문</h3><hr><p>break문은 가장 가까이 둘러싸는 반복문을 빠져나가게 만든다.</p><p>특이하게 파이썬에서 루프문은 else를 가질 수 있다.<br>루프가 이터러블 소진이나 조건이 거짓이 돼서 종료할 때 실행된다. 단, 루프가 break문으로 종료될 때는 실행되지 않는다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">if</span> n % x == <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>            print(n, <span class="string">'equals'</span>, x, <span class="string">'*'</span>, n//x)</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">break</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="comment"># loop fell through without finding a factor</span></span><br><span class="line"><span class="meta">... </span>        print(n, <span class="string">'is a prime number'</span>)</span><br><span class="line">...</span><br><span class="line"><span class="number">2</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">3</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">4</span> equals <span class="number">2</span> * <span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">6</span> equals <span class="number">2</span> * <span class="number">3</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">is</span> a prime number</span><br><span class="line"><span class="number">8</span> equals <span class="number">2</span> * <span class="number">4</span></span><br><span class="line"><span class="number">9</span> equals <span class="number">3</span> * <span class="number">3</span></span><br></pre></td></tr></table></figure><p>continue는 루프의 다음 이터레이션에서 계속 실행하도록 만든다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"Found an even number"</span>, num)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">continue</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"Found a number"</span>, num)</span><br><span class="line">Found an even number <span class="number">2</span></span><br><span class="line">Found a number <span class="number">3</span></span><br><span class="line">Found an even number <span class="number">4</span></span><br><span class="line">Found a number <span class="number">5</span></span><br><span class="line">Found an even number <span class="number">6</span></span><br><span class="line">Found a number <span class="number">7</span></span><br><span class="line">Found an even number <span class="number">8</span></span><br><span class="line">Found a number <span class="number">9</span></span><br></pre></td></tr></table></figure><br><h3 id="pass문"><a href="#pass문" class="headerlink" title="pass문"></a>pass문</h3><hr><p>아무것도 하지 않는다.<br>문법적으로 문장이 필요하지만 특별히 할 일이 없을 때 사용한다.<br>ex) 최소한의 클래스를 만들 때</p><h2 id="함수-정의"><a href="#함수-정의" class="headerlink" title="함수 정의"></a>함수 정의</h2><hr><p>def를 이용해서 함수를 정의한다.<br>함수 이름과 괄호로 싸인 매개변수들의 목록이 뒤따른다.<br>함수 내부 문장들은 반드시 들여쓰기 해야 한다.<br>“””독스트링””” 은 함수 바디의 첫번째 문장으로 사용해 함수에 대한 설명으로 사용할 수 있다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span>    <span class="comment"># write Fibonacci series up to n</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">"""Print a Fibonacci series up to n."""</span></span><br><span class="line"><span class="meta">... </span>    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> a &lt; n:</span><br><span class="line"><span class="meta">... </span>        print(a, end=<span class="string">' '</span>)</span><br><span class="line"><span class="meta">... </span>        a, b = b, a+b</span><br><span class="line"><span class="meta">... </span>    print()</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Now call the function we just defined:</span></span><br><span class="line"><span class="meta">... </span>fib(<span class="number">2000</span>)</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span> <span class="number">610</span> <span class="number">987</span> <span class="number">1597</span></span><br></pre></td></tr></table></figure><h3 id="기본-인자-값"><a href="#기본-인자-값" class="headerlink" title="기본 인자 값"></a>기본 인자 값</h3><p>하나 이상의 인자들에 기본값을 지정하여 정의된 것보다 더 적은 개수의 인자들로 호출될 수 있는 함수를 만든다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ask_ok</span><span class="params">(prompt, retries=<span class="number">4</span>, reminder=<span class="string">'Please try again!'</span>)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ok = input(prompt)</span><br><span class="line">        <span class="keyword">if</span> ok <span class="keyword">in</span> (<span class="string">'y'</span>, <span class="string">'ye'</span>, <span class="string">'yes'</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> ok <span class="keyword">in</span> (<span class="string">'n'</span>, <span class="string">'no'</span>, <span class="string">'nop'</span>, <span class="string">'nope'</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        retries = retries - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> retries &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'invalid user response'</span>)</span><br><span class="line">        print(reminder)</span><br></pre></td></tr></table></figure><blockquote><p><strong>Reference</strong><br><a href="python.org">python.org</a></p></blockquote><p><em>이 게시물은 파이썬 문법을 까먹었을 때 검색하려고 작성됨.</em></p>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/04/13/20200413-python2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>파이썬 문법 사전 - 숫자, 문자열, 리스트</title>
      <link>https://yhcho0405.github.io/2020/04/12/20200412-python1/</link>
      <guid>https://yhcho0405.github.io/2020/04/12/20200412-python1/</guid>
      <pubDate>Sun, 12 Apr 2020 08:41:00 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;숫자&quot;&gt;&lt;a href=&quot;#숫자&quot; class=&quot;headerlink&quot; title=&quot;숫자&quot;&gt;&lt;/a&gt;숫자&lt;/h2&gt;&lt;hr&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;figcaption&gt;&lt;span&gt;-, \*,&lt;/span&gt;&lt;a href=&quot;/```&quot;&gt;같이 사칙연산 연산자를 사용할 수 있다.&lt;/a&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;괄호는 연산의 우선순위를 정할 때 사용한다.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#96;&amp;#96;&amp;#96;py&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; 2 + 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; 50 - 5*6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; (50 - 5*6) &amp;#x2F; 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; 8 &amp;#x2F; 5  # division always returns a floating point number&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1.6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="숫자"><a href="#숫자" class="headerlink" title="숫자"></a>숫자</h2><hr><figure class="highlight plain"><figcaption><span>-, \*,</span><a href="/```">같이 사칙연산 연산자를 사용할 수 있다.</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">괄호는 연산의 우선순위를 정할 때 사용한다.</span><br><span class="line">&#96;&#96;&#96;py</span><br><span class="line">&gt;&gt;&gt; 2 + 2</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; 50 - 5*6</span><br><span class="line">20</span><br><span class="line">&gt;&gt;&gt; (50 - 5*6) &#x2F; 4</span><br><span class="line">5.0</span><br><span class="line">&gt;&gt;&gt; 8 &#x2F; 5  # division always returns a floating point number</span><br><span class="line">1.6</span><br></pre></td></tr></table></figure><a id="more"></a><br><p>나눗셈은 항상 float을 리턴한다.<br>정수 나눗셈으로 정수 결과를 얻으려면 // 을 사용하면 된다.<br>나머지 연산에서는 %을 사용한다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">17</span> / <span class="number">3</span>  <span class="comment"># classic division returns a float</span></span><br><span class="line"><span class="number">5.666666666666667</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">17</span> // <span class="number">3</span>  <span class="comment"># floor division discards the fractional part</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">17</span> % <span class="number">3</span>  <span class="comment"># the % operator returns the remainder of the division</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> * <span class="number">3</span> + <span class="number">2</span>  <span class="comment"># result * divisor + remainder</span></span><br><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure><br><p>거듭제곱은 **을 사용한다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> ** <span class="number">2</span>  <span class="comment"># 5 squared</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> ** <span class="number">7</span>  <span class="comment"># 2 to the power of 7</span></span><br><span class="line"><span class="number">128</span></span><br></pre></td></tr></table></figure><p>변수를 값에 대입할 때는 등호 =를 사용한다.</p><br><h2 id="문자열"><a href="#문자열" class="headerlink" title="문자열"></a>문자열</h2><hr><p>파이썬에서 문자열은 ‘작은따옴표’나 “큰따옴표”로 둘러쌀 수 있고 둘다 같은 결과를 가져온다.<br>따옴표를 이스케이핑 하는 방법은 \를 사용하면 된다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'spam eggs'</span>  <span class="comment"># single quotes</span></span><br><span class="line"><span class="string">'spam eggs'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'doesn\'t'</span>  <span class="comment"># use \' to escape the single quote...</span></span><br><span class="line"><span class="string">"doesn't"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"doesn't"</span>  <span class="comment"># ...or use double quotes instead</span></span><br><span class="line"><span class="string">"doesn't"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'"Yes," they said.'</span></span><br><span class="line"><span class="string">'"Yes," they said.'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"\"Yes,\" they said."</span></span><br><span class="line"><span class="string">'"Yes," they said.'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'"Isn\'t," they said.'</span></span><br><span class="line"><span class="string">'"Isn\'t," they said.'</span></span><br></pre></td></tr></table></figure><br><p>print()를 사용할 때 \뒤의 문자가 특수문자로 취급되게 하고 싶지 않다면, 첫 따옴표 앞에 r을 붙여서 raw string을 만들 수 있다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'C:\some\name'</span>)  <span class="comment"># here \n means newline!</span></span><br><span class="line">C:\some</span><br><span class="line">ame</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">r'C:\some\name'</span>)  <span class="comment"># note the r before the quote</span></span><br><span class="line">C:\some\name</span><br></pre></td></tr></table></figure><p>삼중따옴표 “””, ‘’’를 통해 줄넘김 문자를 자동으로 문자열에 포함 할 수도 있다. 줄 끝에 \를 붙여 이를 무시할 수도 있다.<br>또 연산자를 이어 붙이기도 가능하다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"""\</span></span><br><span class="line"><span class="string">    Usage: thingy [OPTIONS]</span></span><br><span class="line"><span class="string">         -h                        Display this usage message</span></span><br><span class="line"><span class="string">         -H hostname               Hostname to connect to</span></span><br><span class="line"><span class="string">    """</span>)    </span><br><span class="line">Usage: thingy [OPTIONS]</span><br><span class="line">     -h                        Display this usage message</span><br><span class="line">     -H hostname  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 3 times 'un', followed by 'ium'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> * <span class="string">'un'</span> + <span class="string">'ium'</span></span><br><span class="line"><span class="string">'unununium'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Py'</span> <span class="string">'thon'</span></span><br><span class="line"><span class="string">'Python'</span></span><br></pre></td></tr></table></figure><br>문자열은 인덱스 될 수 있다. 첫 번째 문자가 인덱스 0에 대응된다.인덱스는 음수가 될 수도 있다.<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word = <span class="string">'Python'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">0</span>]  <span class="comment"># character in position 0</span></span><br><span class="line"><span class="string">'P'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">5</span>]  <span class="comment"># character in position 5</span></span><br><span class="line"><span class="string">'n'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">-1</span>]  <span class="comment"># last character</span></span><br><span class="line"><span class="string">'n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">-2</span>]  <span class="comment"># second-last character</span></span><br><span class="line"><span class="string">'o'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">-6</span>]</span><br><span class="line"><span class="string">'P'</span></span><br></pre></td></tr></table></figure><p>슬라이싱도 지원한다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">0</span>:<span class="number">2</span>]  <span class="comment"># characters from position 0 (included) to 2 (excluded)</span></span><br><span class="line"><span class="string">'Py'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">2</span>:<span class="number">5</span>]  <span class="comment"># characters from position 2 (included) to 5 (excluded)</span></span><br><span class="line"><span class="string">'tho'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[:<span class="number">2</span>] + word[<span class="number">2</span>:]</span><br><span class="line"><span class="string">'Python'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[:<span class="number">4</span>] + word[<span class="number">4</span>:]</span><br><span class="line"><span class="string">'Python'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[:<span class="number">2</span>]   <span class="comment"># character from the beginning to position 2 (excluded)</span></span><br><span class="line"><span class="string">'Py'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">4</span>:]   <span class="comment"># characters from position 4 (included) to the end</span></span><br><span class="line"><span class="string">'on'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">-2</span>:]  <span class="comment"># characters from the second-last (included) to the end</span></span><br><span class="line"><span class="string">'on'</span></span><br></pre></td></tr></table></figure><p>이렇게 보면 이해하기 쉽다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+---+---+---+---+---+---+</span><br><span class="line">| P | y | t | h | o | n |</span><br><span class="line">+---+---+---+---+---+---+</span><br><span class="line">0   1   2   3   4   5   6</span><br><span class="line">-6  -5  -4  -3  -2  -1</span><br></pre></td></tr></table></figure><p>범위 밖의 값을 인덱스로 사용하면 오류가 나지만 슬라이싱을 할 때는 부드럽게 처리된다.</p><p>파이썬의 문자열은 변경할 수 없다. 그래서 특정 인덱스의 값을 바꾸려 할 때는 에러가 난다. 만약 꼭 바꿔야한다면 새 문자열을 만들어야 한다.</p><br>내장함수 len()은 문자열의 길이를 반환한다.<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'supercalifragilisticexpialidocious'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(s)</span><br><span class="line"><span class="number">34</span></span><br></pre></td></tr></table></figure><br><h2 id="리스트"><a href="#리스트" class="headerlink" title="리스트"></a>리스트</h2><hr><p>대괄호 사이에 쉼표로 구분된 항목들의 목록으로 표현된다.<br>리스트는 서로 다른 자료형의 항목을 포함할 수 있다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br></pre></td></tr></table></figure><p>문자열과 마찬가지로 슬라이싱 가능하다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares[<span class="number">0</span>]  <span class="comment"># indexing returns the item</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares[<span class="number">-1</span>]</span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares[<span class="number">-3</span>:]  <span class="comment"># slicing returns a new list</span></span><br><span class="line">[<span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br></pre></td></tr></table></figure><p>리스트는 이어붙이기 가능하다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares + [<span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure><p>문자열과 다르게 리스트는 내용을 변경할 수 있다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cubes = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">27</span>, <span class="number">65</span>, <span class="number">125</span>]  <span class="comment"># something's wrong here</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cubes[<span class="number">3</span>] = <span class="number">64</span>  <span class="comment"># replace the wrong value</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cubes</span><br><span class="line">[<span class="number">1</span>, <span class="number">8</span>, <span class="number">27</span>, <span class="number">64</span>, <span class="number">125</span>]</span><br></pre></td></tr></table></figure><p>append() 메서드를 사용하면 리스트의 끝에 새 항목을 추가할 수 있다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cubes.append(<span class="number">216</span>)  <span class="comment"># add the cube of 6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cubes.append(<span class="number">7</span> ** <span class="number">3</span>)  <span class="comment"># and the cube of 7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cubes</span><br><span class="line">[<span class="number">1</span>, <span class="number">8</span>, <span class="number">27</span>, <span class="number">64</span>, <span class="number">125</span>, <span class="number">216</span>, <span class="number">343</span>]</span><br></pre></td></tr></table></figure><p>슬라이싱 후 대입이 가능하기 때문에 길이변경과 항목삭제도 가능하다.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># replace some values</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters[<span class="number">2</span>:<span class="number">5</span>] = [<span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># now remove them</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters[<span class="number">2</span>:<span class="number">5</span>] = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># clear the list by replacing all the elements with an empty list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters[:] = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>letters</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><p>len()를 통해 길이를 가져올 수 있다.</p><blockquote><p><strong>Reference</strong><br><a href="python.org">python.org</a></p></blockquote><p><em>이 게시물은 파이썬 문법을 까먹었을 때 검색하려고 작성됨.</em></p>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/04/12/20200412-python1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 2294 - 동전 2</title>
      <link>https://yhcho0405.github.io/2020/04/08/20200408-boj2294/</link>
      <guid>https://yhcho0405.github.io/2020/04/08/20200408-boj2294/</guid>
      <pubDate>Wed, 08 Apr 2020 03:29:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;처음 생각했던 방법은 &lt;code&gt;dp[i]&lt;/code&gt;에 &lt;code&gt;i원&lt;/code&gt;을 만들기 위한 동전의 최소 갯수를 저장하는 방식으로 현재 &lt;code&gt;i&lt;/code&gt;보다 작은 &lt;code&gt;j원&lt;/code&gt;을 순차로 돌며 &lt;code&gt;i - j원&lt;/code&gt; 짜리 동전이 있나 확인한 후, &lt;code&gt;dp[i]&lt;/code&gt;에는 그 중 가장 작은 값을 넣도록 작성했다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>처음 생각했던 방법은 <code>dp[i]</code>에 <code>i원</code>을 만들기 위한 동전의 최소 갯수를 저장하는 방식으로 현재 <code>i</code>보다 작은 <code>j원</code>을 순차로 돌며 <code>i - j원</code> 짜리 동전이 있나 확인한 후, <code>dp[i]</code>에는 그 중 가장 작은 값을 넣도록 작성했다.</p><a id="more"></a><p>실제로 돌려보니 시간초과를 받았다.<br>최악의 경우에서 <code>i * j * n == 10,000 * 10,000 * 100</code> == 백 억 번을 반복하기 때문이다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, arr[<span class="number">101</span>], dp[<span class="number">10001</span>], ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">dp[i] = <span class="number">99999</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = n - <span class="number">1</span>; l &gt;= <span class="number">0</span>; l--)</span><br><span class="line"><span class="keyword">if</span>(i - j == arr[l]) dp[i] = min(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ans = (dp[k] == <span class="number">99999</span>) ? <span class="number">-1</span> : dp[k];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드는 시간초과가 발생한다.</p><br><p>이 문제를 해결하기 위해 <a href="/2020/04/06/20200406-boj2293/">동전 1</a> 문제 처럼 첫 번째 동전만 사용 했을 때의 최소값과 두 번째 동전까지 사용 했을 때의 최소값과 … 이런식으로 마지막 동전까지 모두 사용했을 때의 최소값을 구하면 <code>dp[k]</code>에 <code>k원</code>을 만들 때 필요한 동전의 최소 갯수가 들어간다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, arr[<span class="number">101</span>], dp[<span class="number">10001</span>], ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">dp[i] = <span class="number">99999</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = arr[i]; j &lt;= k; j++)</span><br><span class="line">dp[j] = min(dp[j], dp[j - arr[i]] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ans = (dp[k] == <span class="number">99999</span>) ? <span class="number">-1</span> : dp[k];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>99999는 10000보다 크기 때문에 절대 나올 수 없다.</p></blockquote>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/04/08/20200408-boj2294/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 11048 - 이동하기</title>
      <link>https://yhcho0405.github.io/2020/04/07/20200407-boj11048/</link>
      <guid>https://yhcho0405.github.io/2020/04/07/20200407-boj11048/</guid>
      <pubDate>Tue, 07 Apr 2020 08:05:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;단순한 dp문제다. 문제의 이동 조건에서 &lt;code&gt;(r+1, c)&lt;/code&gt;, &lt;code&gt;(r, c+1)&lt;/code&gt;, &lt;code&gt;(r+1, c+1)&lt;/code&gt; 이렇게 3가지를 제시했지만, 사실 상 마지막 &lt;code&gt;(r+1, c+1)&lt;/code&gt;은 신경쓰지 않아도 된다.&lt;br&gt;왜냐하면 사탕의 갯수는 0 이거나 양수이기 때문에 더 많은 사탕을 가져와야 될 판에 굳이 대각선으로 가로질러 올 필요가 없기 때문이다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>단순한 dp문제다. 문제의 이동 조건에서 <code>(r+1, c)</code>, <code>(r, c+1)</code>, <code>(r+1, c+1)</code> 이렇게 3가지를 제시했지만, 사실 상 마지막 <code>(r+1, c+1)</code>은 신경쓰지 않아도 된다.<br>왜냐하면 사탕의 갯수는 0 이거나 양수이기 때문에 더 많은 사탕을 가져와야 될 판에 굳이 대각선으로 가로질러 올 필요가 없기 때문이다.</p><a id="more"></a><figure class="highlight plain"><figcaption><span>현재 칸 까지 가장 많이 가져올 수 있는 사탕의 갯수를 넣는다.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">마지막에 &#96;&#96;&#96;dp[n][m]&#96;&#96;&#96;을 출력한다.</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;cpp</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n, m, dp[1001][1001];</span><br><span class="line">int main() &#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">for(int i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">for(int j &#x3D; 1; j &lt;&#x3D; m; j++) &#123;</span><br><span class="line">cin &gt;&gt; dp[i][j];</span><br><span class="line">dp[i][j] +&#x3D; max(dp[i - 1][j], dp[i][j - 1]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/04/07/20200407-boj11048/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 2167 - 2차원 배열의 합</title>
      <link>https://yhcho0405.github.io/2020/04/07/20200407-boj2167/</link>
      <guid>https://yhcho0405.github.io/2020/04/07/20200407-boj2167/</guid>
      <pubDate>Tue, 07 Apr 2020 07:25:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;그리디로 풀었을 때 최악의 경우 &lt;code&gt;n * m * k번&lt;/code&gt;, &lt;code&gt;300 * 300 * 10,000 = 900,000,000번&lt;/code&gt; 계산하므로 시간초과가 난다.&lt;br&gt;그래서 dp로 풀어야 한다. 할 줄 알았는데 그리디하게 풀어도 맞는다고 한다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>그리디로 풀었을 때 최악의 경우 <code>n * m * k번</code>, <code>300 * 300 * 10,000 = 900,000,000번</code> 계산하므로 시간초과가 난다.<br>그래서 dp로 풀어야 한다. 할 줄 알았는데 그리디하게 풀어도 맞는다고 한다.</p><a id="more"></a><p>어쨌든 <code>dp[i][j]</code>에는 <code>(0, 0)</code>부터 <code>(i, j)</code>까지의 숫자 합을 저장한다.</p><figure class="highlight plain"><figcaption><span>채워나가는 방법</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">---------</span><br><span class="line">-------------</span><br><span class="line"></span><br><span class="line">![노란 영역 까지의 합을 구하려면](&#x2F;image-in-post&#x2F;20200407-boj2167-1.png)</span><br><span class="line">![초록 칸의 값과](&#x2F;image-in-post&#x2F;20200407-boj2167-10.png)</span><br><span class="line">![이 파란 영역의 합과](&#x2F;image-in-post&#x2F;20200407-boj2167-2.png)</span><br><span class="line">![이 파란 영역의 합을 더하고](&#x2F;image-in-post&#x2F;20200407-boj2167-3.png)</span><br><span class="line">![중복된 빨간 영역의 합을 빼면 된다.](&#x2F;image-in-post&#x2F;20200407-boj2167-4.png)</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">주어진 영역의 합을 구하는 방법</span><br><span class="line">----</span><br><span class="line">-----------</span><br><span class="line">![노란 영역의 합을 구하려면](&#x2F;image-in-post&#x2F;20200407-boj2167-5.png)</span><br><span class="line">![이 파란 영역의 합에서](&#x2F;image-in-post&#x2F;20200407-boj2167-6.png)</span><br><span class="line">![필요없는 이 빨간 영역의 합과](&#x2F;image-in-post&#x2F;20200407-boj2167-7.png)</span><br><span class="line">![이 빨간 영역의 합을 빼고](&#x2F;image-in-post&#x2F;20200407-boj2167-8.png)</span><br><span class="line">![중복되서 빼버린 이 파란 영역의 합을 더해주면 된다.](&#x2F;image-in-post&#x2F;20200407-boj2167-9.png)</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">위 과정을 코드로 작성하면 아래와 같다.</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;cpp</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n, m, ans, i, j, x, y, dp[301][301];</span><br><span class="line">int main() &#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">for(i &#x3D; 1; i &lt;&#x3D; n; i++)</span><br><span class="line">for(j &#x3D; 1; j &lt;&#x3D; m; j++) &#123;</span><br><span class="line">cin &gt;&gt; dp[i][j];</span><br><span class="line">dp[i][j] +&#x3D; dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1];</span><br><span class="line">&#125;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">for(int k &#x3D; 0; k &lt; n; k++) &#123;</span><br><span class="line">cin &gt;&gt; i &gt;&gt; j &gt;&gt; x &gt;&gt; y;</span><br><span class="line">ans &#x3D; dp[x][y] - dp[x][j - 1] - dp[i - 1][y] + dp[i - 1][j - 1];</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/04/07/20200407-boj2167/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 11055 - 가장 큰 증가 부분 수열</title>
      <link>https://yhcho0405.github.io/2020/04/07/20200407-boj11055/</link>
      <guid>https://yhcho0405.github.io/2020/04/07/20200407-boj11055/</guid>
      <pubDate>Tue, 07 Apr 2020 03:38:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;a href=&quot;/2019/11/04/20191104-boj11053/&quot;&gt;가장 긴 증가하는 부분 수열&lt;/a&gt; 문제에서 &lt;code&gt;dp[]&lt;/code&gt;에 길이를 넣었다면 지금 이 문제는 최대값을 넣으면 된다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p><a href="/2019/11/04/20191104-boj11053/">가장 긴 증가하는 부분 수열</a> 문제에서 <code>dp[]</code>에 길이를 넣었다면 지금 이 문제는 최대값을 넣으면 된다.</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, arr[<span class="number">1001</span>], dp[<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">dp[i] = arr[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line"><span class="keyword">if</span>(arr[j] &lt; arr[i]) dp[i] = max(dp[j] + arr[i], dp[i]);</span><br><span class="line">&#125;</span><br><span class="line">sort(dp, dp + n + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/04/07/20200407-boj11055/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 1699 - 제곱수의 합</title>
      <link>https://yhcho0405.github.io/2020/04/07/20200407-boj1699/</link>
      <guid>https://yhcho0405.github.io/2020/04/07/20200407-boj1699/</guid>
      <pubDate>Mon, 06 Apr 2020 23:14:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;만약 i라는 숫자보다 &lt;strong&gt;j * j&lt;/strong&gt;만큼 작은 수 인 &lt;strong&gt;i - j * j&lt;/strong&gt;는 숫자 &lt;strong&gt;i&lt;/strong&gt;의 &lt;strong&gt;제곱수의 최소항 갯수 - 1&lt;/strong&gt;을 가질 것이다.&lt;br&gt;만약 &lt;strong&gt;j * j&lt;/strong&gt;가 &lt;strong&gt;i&lt;/strong&gt;와 같다면 &lt;strong&gt;j * j = i&lt;/strong&gt;이므로 제곱수의 최소항 갯수가 한개가 된다.&lt;br&gt;이 과정을 &lt;strong&gt;j * j&lt;/strong&gt;가 &lt;strong&gt;i&lt;/strong&gt;보다 작거나 같을 때까지 반복해 가장 작은 값을 &lt;strong&gt;dp[i]&lt;/strong&gt;에 넣고 &lt;strong&gt;i&lt;/strong&gt;가 &lt;strong&gt;n&lt;/strong&gt;만큼 돌면 &lt;strong&gt;dp[n]&lt;/strong&gt;이 답이 된다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>만약 i라는 숫자보다 <strong>j * j</strong>만큼 작은 수 인 <strong>i - j * j</strong>는 숫자 <strong>i</strong>의 <strong>제곱수의 최소항 갯수 - 1</strong>을 가질 것이다.<br>만약 <strong>j * j</strong>가 <strong>i</strong>와 같다면 <strong>j * j = i</strong>이므로 제곱수의 최소항 갯수가 한개가 된다.<br>이 과정을 <strong>j * j</strong>가 <strong>i</strong>보다 작거나 같을 때까지 반복해 가장 작은 값을 <strong>dp[i]</strong>에 넣고 <strong>i</strong>가 <strong>n</strong>만큼 돌면 <strong>dp[n]</strong>이 답이 된다.</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, dp[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">dp[i] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j * j &lt;= i; j++)</span><br><span class="line">dp[i] = min(dp[i - j * j] + <span class="number">1</span>, dp[i]);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>구글링 하다가 동적 계획법 말고 다른 방법을 사용한 다른 풀이를 발견해서 첨부한다.<br><strong>라그랑주의 네 제곱수 정리</strong>에 의하여 모든 양의 정수는 최대 4개의 제곱수의 합으로 나타낼 수 있기 때문에 3개의 제곱수의 합으로 못찾아내면 4개라는 점을 이용한 반쪽짜리 완전탐색 코드다.<br>3중 for문이라 되게 오래 걸릴 것 같지만 제곱근 n에 대하여 매우 빠르게 수가 불어나서 생각보다 빠르다.<br>오히려 dp보다 빠를 수도 있다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, ans = <span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">1</span>; a * a &lt;= n; a++) &#123;</span><br><span class="line"><span class="keyword">if</span>(a * a == n) ans = min(ans, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">1</span>; a * a + b * b &lt;= n; b++) &#123;</span><br><span class="line"><span class="keyword">if</span>(a * a + b * b == n) ans = min(ans, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">1</span>; a * a + b * b + c * c &lt;= n; c++)</span><br><span class="line"><span class="keyword">if</span>(a * a + b * b + c * c == n) ans = min(ans, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>채첨 안해봐서 정답 처리 받을 수 있는지 모른다.<br>근데 잘 나온다.</p>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/04/07/20200407-boj1699/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 11057 - 오르막 수</title>
      <link>https://yhcho0405.github.io/2020/04/07/20200407-boj11057/</link>
      <guid>https://yhcho0405.github.io/2020/04/07/20200407-boj11057/</guid>
      <pubDate>Mon, 06 Apr 2020 15:12:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;각 자리수 별로 0 ~ 9까지 숫자들의 등장 가능한 빈도를 세면 된다.&lt;br&gt;dp로 풀 수 있고 바로 전 자리수에 자신보다 작거나 같은 수가 얼마나 있는지를 &lt;code&gt;dp[i][j]&lt;/code&gt;에 저장해나가면 된다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>각 자리수 별로 0 ~ 9까지 숫자들의 등장 가능한 빈도를 세면 된다.<br>dp로 풀 수 있고 바로 전 자리수에 자신보다 작거나 같은 수가 얼마나 있는지를 <code>dp[i][j]</code>에 저장해나가면 된다.</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, ans, dp[<span class="number">1001</span>][<span class="number">11</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">dp[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = j; k &lt; <span class="number">10</span>; k++) &#123;</span><br><span class="line">dp[i][j] += dp[i - <span class="number">1</span>][k];</span><br><span class="line">dp[i][j] %= <span class="number">10007</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">ans += dp[n][i];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans % <span class="number">10007</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/04/07/20200407-boj11057/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 2293 - 동전 1</title>
      <link>https://yhcho0405.github.io/2020/04/06/20200406-boj2293/</link>
      <guid>https://yhcho0405.github.io/2020/04/06/20200406-boj2293/</guid>
      <pubDate>Mon, 06 Apr 2020 05:59:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;dp로 접근해서 풀어야 한다.&lt;br&gt;처음에 생각했던 방법은 dp[i]에 i원을 만들 수 있는 경우의 수를 저장하고, 각 dp[i]에 가지고 있는 동전의 종류(arr[j])원을 뺀 dp[i - arr[j]]를 더해주는 방법으로 풀면 되겠다고 생각했다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>dp로 접근해서 풀어야 한다.<br>처음에 생각했던 방법은 dp[i]에 i원을 만들 수 있는 경우의 수를 저장하고, 각 dp[i]에 가지고 있는 동전의 종류(arr[j])원을 뺀 dp[i - arr[j]]를 더해주는 방법으로 풀면 되겠다고 생각했다.</p><a id="more"></a><p>&lt;예제 1 입력&gt;<br>3 10<br>1<br>2<br>5</p><p>&lt;예제 1 출력&gt;<br>10</p><br><p>막상 실행시켜보니 예제 1의 정답은 10이 나와야 하지만 내 코드는 128을 출력했다.</p><p>코드의 동작 과정을 생각해보면 오류가 보인다.<br><strong>1원을 만들 때의 경우의 수 = 1개 (1)</strong><br><strong>2원을 만들 때의 경우의 수 = 2개 (1, 1 / 2)</strong><br>여기서 내 코드의 논리로는 3원을 만들 때 1원(2원짜리 동전을 가지고 있으므로 3 - 2 = 1원)과 2원(1원짜리 동전을 가지고 있으므로 3 - 1 = 2원)의 경우의 수의 합과 같아야 한다.<br>따라서<br><strong>3원을 만들 때의 경우의 수 = 3개 (1, 2 / 1, 1, 1 / 2, 1)</strong><br>하지만 문제의 조건에서 순서만 다른 것은 같은 경우로 취급하라 했으므로 3원을 만들 때의 경우의 수에 동전의 조합이 중복되는 경우가 발생한다.<br>그래서 실제로 3원을 만들 때의 경우의 수는 2개이다. (1, 2 / 1, 1, 1)<br>아래 코드는 동전의 조합까지 모두 계산하는 결과를 출력한다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, arr[<span class="number">101</span>], dp[<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">dp[arr[i]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; n; a++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i - j == arr[a]) dp[i] += dp[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>물론 위의 코드는 오답처리를 받는다.<br><br></p><p>정답 처리를 받기 위해선 동전의 순서는 고려하지 않고 동전의 조합의 갯수만 출력하도록 작성해야한다.</p><p>그러기 위해 위의 예제의 경우 첫번째 동전만으로 경우의 수를 구하고, 두번째 동전까지 사용해 경우의 수를 구하고, 세번째 동전까지 사용해 경우의 수를 구하는 방법을 사용한다.<br>이 경우는 각각 동전들이 독립적인 결과를 가지므로 중복이 발생하지 않는다.<br>위의 코드와 대체로 유사하지만 dp[i]를 저장할 때 2중 for문에서 i와 j가 바뀐 형태다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, k, arr[<span class="number">101</span>], dp[<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i] &gt; j) <span class="keyword">continue</span>;</span><br><span class="line">dp[j] += dp[j - arr[i]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 코드가 정답이다.</p>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/04/06/20200406-boj2293/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 1010 - 다리 놓기</title>
      <link>https://yhcho0405.github.io/2020/04/04/20200404-boj1010/</link>
      <guid>https://yhcho0405.github.io/2020/04/04/20200404-boj1010/</guid>
      <pubDate>Sat, 04 Apr 2020 03:35:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;보자마자 떠오른것은 조합이다.&lt;br&gt;mCn을 계산하면 정답이 나오지만 m이 최대 29까지 등장하기 때문에 계산 과정에서 29!을 계산할 여지가 있다.&lt;br&gt;29!은 long long에도 못들어가는 아무튼 엄청 크다.&lt;br&gt;이를 해결하는 방법은 여러가지가 있다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>보자마자 떠오른것은 조합이다.<br>mCn을 계산하면 정답이 나오지만 m이 최대 29까지 등장하기 때문에 계산 과정에서 29!을 계산할 여지가 있다.<br>29!은 long long에도 못들어가는 아무튼 엄청 크다.<br>이를 해결하는 방법은 여러가지가 있다.</p><a id="more"></a><p>먼저 조합의 성질을 보자.<br><strong>nCr</strong>이라면 <strong>n! / {(n - r)! * r!}</strong> 이다.<br>이 때문에 r을 n - r로 바꾸어 계산해도 정답은 일치한다.<br>그렇다면 주어진 범위에서 계산 과정 중 분자의 크기가 가장 커지게 만드는 경우는 <strong>n이 29일 때와 r이 14또는 15일 때</strong> 이다.<br>수식을 약분하면 계산 과정 중 등장할 가장 큰 수인 29!/15!은<br><strong>6,761,440,164,390,912,000</strong><br>이고 long long의 양수 최대범위는<br><strong>9,223,372,036,854,775,807</strong><br>이다.<br><br><br>아슬아슬하게 걸친다.<br>가장 큰 수가 오버플로우가 발생하지 않는다면 주어진 범위 내의 모든 수도 계산하는데 문제가 없을 것이다.</p><p>위 내용을 코드로 나타내면 아래와 같다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> t, n, m, ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t--) &#123;</span><br><span class="line">ans = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">n = n &gt; m - n ? m - n : n; <span class="comment">// m - n과 n중 더 작은것을 사용한다.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">ans *= m - i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">ans /= i;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>또 다른 방법은 조합 계산을 동적 계획법을 이용해 재귀함수로 구현하는 것이다.<br>그 전에 조합 <strong>nCr = n-1Cr-1 + n-1Cr</strong>로 나타낼 수 있다는 것을 알아야 한다.(파스칼의 삼각형으로 부터 유래되었다.)<br>로또로 예를 들어 보면 45개 중 6개를 뽑을 때의 경우의 수는 <strong>1번 공을 미리 뽑고 5개를 랜덤으로 뽑는 경우와 1번 공을 제외하고 6개를 랜덤으로 뽑는 경우를 더한 것</strong>과 같다.<br>저 공식을 사용해 계속 쪼개나가서 n과 r이 같아지거나 r이 0이 될 때 1을 반환하면 된다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, a, b, dp[<span class="number">31</span>][<span class="number">31</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cbn</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n == r || r == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(dp[n][r]) <span class="keyword">return</span> dp[n][r];</span><br><span class="line"><span class="keyword">return</span> dp[n][r] = cbn(n - <span class="number">1</span>, r - <span class="number">1</span>) + cbn(n - <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t--) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cbn(b, a) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/04/04/20200404-boj1010/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>

<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>yhcho0405</title>
    <link>https://yhcho0405.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>내가 보려고 쓰는 블로그</description>
    <pubDate>Thu, 17 Sep 2020 08:10:00 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[디지털 논리] 1/2/3장(수의 체계, 디지털 코드)</title>
      <link>https://yhcho0405.github.io/2020/09/17/20200917-DigitalLogic1/</link>
      <guid>https://yhcho0405.github.io/2020/09/17/20200917-DigitalLogic1/</guid>
      <pubDate>Thu, 17 Sep 2020 08:10:00 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;Book Title : 처음 만나는 디지털 논리회로&lt;br&gt;Author : 임석구, 홍경오&lt;br&gt;Publisher : 한빛아카데미&lt;/p&gt;
&lt;p&gt;1장 2장은 나중에 추가&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<blockquote></blockquote><p>Book Title : 처음 만나는 디지털 논리회로<br>Author : 임석구, 홍경오<br>Publisher : 한빛아카데미</p><p>1장 2장은 나중에 추가</p><a id="more"></a><h2 id="3-디지털-코드"><a href="#3-디지털-코드" class="headerlink" title="3. 디지털 코드"></a><strong>3. 디지털 코드</strong></h2><hr><h3 id="3-1-숫자-코드"><a href="#3-1-숫자-코드" class="headerlink" title="3.1 숫자 코드"></a><strong>3.1 숫자 코드</strong></h3><hr><h4 id="BCD-코드"><a href="#BCD-코드" class="headerlink" title="BCD 코드"></a>BCD 코드</h4><ul><li>10진수를 2진화한 코드(8421코드)</li><li>표기는 2진수지만 의미는 10진수</li><li>0(0000) ~ 9(1001)까지 범위만 사용</li><li>1024를 표현하고 싶다면 4비트 4개로 각 자리를 표현</li><li>ex) 196 = 0010 0011 0111</li><li>계산 결과 9(1001)초과 시 6(0110)을 더해서 보정</li></ul><br><h4 id="3초과-코드"><a href="#3초과-코드" class="headerlink" title="3초과 코드"></a>3초과 코드</h4><ul><li>BCD코드로 표현된 값에 3을 더해준 값.</li><li>자기 보수의 성질(자보수 코드)</li><li>가중치 코드는 아님!</li></ul><br><h4 id="다양한-2진-코드"><a href="#다양한-2진-코드" class="headerlink" title="다양한 2진 코드"></a>다양한 2진 코드</h4><ul><li>가중치 코드<ul><li>각 2진수 자리에 고정된 수를 가지고 있는 코드</li><li>8421, 2421, 84-2-1코드 등</li></ul></li><li>비가중치 코드<ul><li>각 2진수 자리에 고정된 수가 없는 코드</li><li>데이터 변환과 같은 특수한 용도로 쓰임</li><li>3초과 코드, 그레이 코드</li></ul></li></ul><br><h4 id="그레이-코드"><a href="#그레이-코드" class="headerlink" title="그레이 코드"></a>그레이 코드</h4><ul><li>ADC나 입출력 장치 코드로 주로 쓰임.</li><li>2진수와 비교했을 때 최상위 비트는 그대로 쓰고 뒷 3자리는 전 비트와 XOR연산</li></ul><p><img src="https://i.imgur.com/WVt9dPw.png" alt="그레이 코드 변환"></p><p><img src="https://i.imgur.com/71g3tqp.png" alt="연속되는 숫자의 비트가 하나씩 밖에 차이나지 않아서 오차가 적다."></p><br><blockquote><p>BCD코드, 2421코드, 84-2-1코드 = 가중치 코드<br>3초과 코드, 2421코드, 84-2-1코드 = 자보수 코드</p></blockquote><br><h3 id="3-2-에러-검출-코드"><a href="#3-2-에러-검출-코드" class="headerlink" title="3.2 에러 검출 코드"></a><strong>3.2 에러 검출 코드</strong></h3><hr><h4 id="패리티-비트"><a href="#패리티-비트" class="headerlink" title="패리티 비트"></a>패리티 비트</h4><ul><li>짝수패리티 : 데이터에서 1의 개수를 짝수로 맞춤</li><li>홀수패리티 : 데이터에서 1의 개수를 홀수로 맞춤</li><li>에러가 짝수개(2개, 4개…) 발생하면 검출하지 못함</li><li>에러 검출기<ul><li>짝패 : y = 0(에러 없음), y = 1(에러 발생)</li><li>홀패 : y = 1(에러 없음), y = 0(에러 발생)<br><img src="https://i.imgur.com/X53rmP3.png" alt="패리티 비트"></li></ul></li></ul><br><h4 id="병렬-패리티"><a href="#병렬-패리티" class="headerlink" title="병렬 패리티"></a>병렬 패리티</h4><ul><li>패리티 비트를 하나만 사용하면 에러 검출은 가능하지만 정정할 수는 없기 때문에 가로와 세로에 대해 패리티를 검사하면 에러가 발생한 블록을 특정해낼 수 있다.<br><img src="https://i.imgur.com/YWhVEgL.png" alt="병렬 패리티 비트"></li></ul><br><h4 id="해밍-코드-에러-정정-코드-꼭-나옴"><a href="#해밍-코드-에러-정정-코드-꼭-나옴" class="headerlink" title="해밍 코드(에러 정정 코드) 꼭 나옴"></a>해밍 코드(에러 정정 코드) <strong>꼭 나옴</strong></h4><ul><li>에러를 정정할 수 있는 코드</li><li>추가적으로 많은 비트가 필요하므로 많은 양의 데이터 전달이 필요</li><li>패리티 비트가 앞에서부터 1, 2, 4, 8, 16,…의 위치에 들어간다.</li><li>P8부터 P1까지 읽어서 오류 비트의 인덱스를 알 수 있다.</li><li>Pn이 모두 0(오류 없음)이면 오류 없음</li><li>마찬가지로 오류 비트가 하나일 때만 사용 가능</li><li>매우 매우 매우 매우 매우 중요<br><img src="https://i.imgur.com/7yMGF9f.png" alt="해밍 코드"></li></ul><br><h3 id="3-3-문자-코드"><a href="#3-3-문자-코드" class="headerlink" title="3.3 문자 코드"></a><strong>3.3 문자 코드</strong></h3><hr><h4 id="ASCII-코드"><a href="#ASCII-코드" class="headerlink" title="ASCII 코드"></a>ASCII 코드</h4><ul><li>ANSI가 제정한 정보 교환용 미국 표준 코드</li><li>128가지의 문자 표현 가능</li><li>8비트 중 맨 앞자리는 패리티 비트</li><li>다음 3비트는 존(zone), 다음 4비트가 디지트(digit)<br><img src="https://i.imgur.com/93T5joX.png" alt="표준 아스키코드표"><blockquote><p>패리티 비트 내다버리고 확장 ASCII코드를 만들 수 있다.</p></blockquote></li></ul><br><h4 id="표준-BCD-코드"><a href="#표준-BCD-코드" class="headerlink" title="표준 BCD 코드"></a>표준 BCD 코드</h4><ul><li>6비트로 영문자까지 표현</li><li>최대 64문자까지 표현 가능</li></ul><br><h4 id="EBCDIC-코드"><a href="#EBCDIC-코드" class="headerlink" title="EBCDIC 코드"></a>EBCDIC 코드</h4><ul><li>대형 컴퓨터와 IBM 계열에서 많이 사용함</li><li>ASCII와 호환을 위해 8비트 코드 사용</li><li>256종류의 문자 코드를 표현 가능</li><li>하지만 코드표를 보면 많이 비어있음.</li></ul><br><h4 id="유니코드"><a href="#유니코드" class="headerlink" title="유니코드"></a>유니코드</h4><ul><li>ASCII의 한계 극복하기 위해 개발된 국제 표준.</li><li>UTF-8, 16, 32 (일반적으로 판을 나눠서 16사용)</li></ul><br><h4 id="한글코드"><a href="#한글코드" class="headerlink" title="한글코드"></a>한글코드</h4><ul><li>조합형<ul><li>때에 따라 다른응용프로그램에서 못씀</li><li>자음과 모음으로 조합 가능한 모든 한글을 사용할 수 있음</li><li>고어 까지 취급할 수 있음</li><li>하지만 출력 시 다시 계산해야됨</li></ul></li><li>완성형<ul><li>표준</li><li>초성, 중성, 종성으로 안 나누고 글자 단위로 처리</li></ul></li></ul>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/09/17/20200917-DigitalLogic1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[컴퓨터 시스템 구조] 2장 명령어: 컴퓨터 언어</title>
      <link>https://yhcho0405.github.io/2020/09/17/20200917-ComputerSytemArchitecture2/</link>
      <guid>https://yhcho0405.github.io/2020/09/17/20200917-ComputerSytemArchitecture2/</guid>
      <pubDate>Thu, 17 Sep 2020 08:10:00 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;Book Title : 컴퓨터 구조 및 설계&lt;br&gt;Author : David A. Patterson , L. Hennessy&lt;br&gt;Publisher : 한티미디어&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<blockquote><p>Book Title : 컴퓨터 구조 및 설계<br>Author : David A. Patterson , L. Hennessy<br>Publisher : 한티미디어</p></blockquote><a id="more"></a><h2 id="2-명령어-컴퓨터-언어"><a href="#2-명령어-컴퓨터-언어" class="headerlink" title="2. 명령어: 컴퓨터 언어"></a><strong>2. 명령어: 컴퓨터 언어</strong></h2><hr><h3 id="2-1-서론"><a href="#2-1-서론" class="headerlink" title="2.1 서론"></a><strong>2.1 서론</strong></h3><hr><h4 id="Instruction-Set"><a href="#Instruction-Set" class="headerlink" title="Instruction Set"></a>Instruction Set</h4><ul><li>명령어 집합</li><li>마이크로프로세서가 인식해서 기능을 이해하고 실행할 수 있는 기계어 명령어.</li><li>SW와 HW사이에서 동작(중재자)</li><li>단순할수록 성능이 좋다.</li></ul><br><h4 id="설계-원칙"><a href="#설계-원칙" class="headerlink" title="설계 원칙"></a>설계 원칙</h4><ol><li>간단하게 하기 위해서는 규칙적인 것이 좋다.</li><li>작은 것이 더 빠르다.(항상 그런것은 아님)</li><li>좋은 설계에는 적당한 절충이 필요하다.</li></ol><br><h3 id="2-2-하드웨어-연산"><a href="#2-2-하드웨어-연산" class="headerlink" title="2.2 하드웨어 연산"></a><strong>2.2 하드웨어 연산</strong></h3><hr><h4 id="MIPS-산술-명령어"><a href="#MIPS-산술-명령어" class="headerlink" title="MIPS 산술 명령어"></a>MIPS 산술 명령어</h4><ul><li>반드시 한 종류의 연산만 지시</li><li>항상 변수 3개 가짐</li><li>줄이 끝나면 주석도 끝남</li><li>설계 원칙1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;C&gt;</span><br><span class="line">a &#x3D; b + c;</span><br><span class="line">d &#x3D; a - e;</span><br><span class="line"></span><br><span class="line">&lt;MIPS&gt;</span><br><span class="line">add a, b, c</span><br><span class="line">sub d, a, e</span><br></pre></td></tr></table></figure><br><h3 id="2-3-피연산자"><a href="#2-3-피연산자" class="headerlink" title="2.3 피연산자"></a><strong>2.3 피연산자</strong></h3><hr><ul><li>MIPS 구조에서 레지스터의 크기는 32비트, 이를 한 워드(word)라고 부름</li><li>레지스터의 개수 또한 32개다.</li><li>설계 원칙2</li></ul><br><h4 id="메모리-피연산자"><a href="#메모리-피연산자" class="headerlink" title="메모리 피연산자"></a>메모리 피연산자</h4><ul><li>데이터 전송 명령어 (전송 방향에 주의)<ul><li>lw (load word) 메모리 &lt;- 데이터</li><li>sw (store word) 메모리 -&gt; 데이터</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;C&gt;</span><br><span class="line">A[12] &#x3D; h + A[8];</span><br><span class="line"></span><br><span class="line">&lt;MIPS&gt;</span><br><span class="line">lw $t0, 32($s3)</span><br><span class="line">add $t0, $s2, $t0</span><br><span class="line">sw $t0, 48($s3)</span><br></pre></td></tr></table></figure><ul><li>MIPS에서 워드의 시작 주소는 항상 4의 배수임.</li><li>MIPS는 빅엔디안(big-endian)을 사용함.</li></ul><br><h4 id="상수-피연산자"><a href="#상수-피연산자" class="headerlink" title="상수 피연산자"></a>상수 피연산자</h4><ul><li>addi $s3, $s3, 4 #$s3 += 4</li><li>$zero #0</li><li>자주 생기는 일을 빠르게의 좋은 예</li></ul><br><h3 id="2-4-부호있는-수와-부호없는-수"><a href="#2-4-부호있는-수와-부호없는-수" class="headerlink" title="2.4 부호있는 수와 부호없는 수"></a><strong>2.4 부호있는 수와 부호없는 수</strong></h3><hr><ul><li>LSB(Least significant bit) : 가장 낮은 주소(오른쪽) 비트</li><li>MSB(most significant bit) : 가장 높은 주소(왼쪽) 비트</li><li>MSB가 0이면 양수, 1이면 음수</li><li>역부호화 : 모든 비트를 뒤집고 1 더하기</li></ul><br><h3 id="2-5-명령어의-컴퓨터-내부-표현"><a href="#2-5-명령어의-컴퓨터-내부-표현" class="headerlink" title="2.5 명령어의 컴퓨터 내부 표현"></a><strong>2.5 명령어의 컴퓨터 내부 표현</strong></h3><hr><ul><li><p>레지스터 이름을 숫자로 매핑하는 규칙</p><ul><li>&amp;t0 ~ $t7 은 8 ~ 15번</li><li>&amp;s0 ~ $s7 은 16 ~ 23번</li></ul></li><li><p>MIPS명령어의 필드<br><img src="https://i.imgur.com/EnLAhEy.png" alt><br><img src="https://i.imgur.com/Azna4Mc.png" alt></p></li></ul>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/09/17/20200917-ComputerSytemArchitecture2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>닌텐도 [야추] 게임 만들기</title>
      <link>https://yhcho0405.github.io/2020/08/21/20200821-yachoo/</link>
      <guid>https://yhcho0405.github.io/2020/08/21/20200821-yachoo/</guid>
      <pubDate>Thu, 20 Aug 2020 15:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;사용된 기술 : html, css, js(jquery), node.js, socket.io, express, heroku, react-native(웹뷰로 앱도 만들었는데 사실 의미없음)&lt;/p&gt;
&lt;h2 id=&quot;링크&quot;&gt;&lt;a href=&quot;#링크&quot; class=&quot;headerlink&quot; title=&quot;링크&quot;&gt;&lt;/a&gt;링크&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/etc-file/YACHOO.apk&quot;&gt;안드로이드 apk다운로드&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&gt;ios 다운로드(아직 빌드 안함)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://yachoo.herokuapp.com/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;웹 링크&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2020-08-15&quot;&gt;&lt;a href=&quot;#2020-08-15&quot; class=&quot;headerlink&quot; title=&quot;2020 08 15&quot;&gt;&lt;/a&gt;2020 08 15&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;유튜브 보다가 삘꽂혀서 닌텐도 스위치 타이틀 [세계 놀이 대전 51]의 Yacth를 웹으로 으로 만들기로 함.&lt;/li&gt;
&lt;li&gt;15일 오늘 기준 node.js 기초만 다진 상태&lt;/li&gt;
&lt;li&gt;온라인 멀티플레이를 구현하려면 서버와 통신 할 방법이 필요함. 뭐 써야하는지 모름.&lt;/li&gt;
&lt;li&gt;구글링 후 소켓통신을 사용하기로 함.&lt;/li&gt;
&lt;li&gt;채팅 예제로 socket.io 공부&lt;/li&gt;
&lt;li&gt;게임 전반적인 기획&lt;/li&gt;
&lt;li&gt;데드라인을 넉넉히 10일로 잡음.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2020-08-16&quot;&gt;&lt;a href=&quot;#2020-08-16&quot; class=&quot;headerlink&quot; title=&quot;2020 08 16&quot;&gt;&lt;/a&gt;2020 08 16&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;싱글페이지로 만드는게 편하겠다고 판단함.&lt;/li&gt;
&lt;li&gt;채팅기능을 우선적으로 구현하고 socket의 room을 지정해 채팅방끼리만 통신하도록 구현&lt;/li&gt;
&lt;li&gt;게임 진행을 위한 여러 예외처리나 선공 후공 결정, 중간에 플레이어가 나갈 경우, 방이 다 찼을 경우 , 인원수 전체 업데이트 등등등등등 다 기억안남.&lt;/li&gt;
&lt;li&gt;해야할게 너무 많다.&lt;/li&gt;
&lt;li&gt;주사위를 굴릴 area결정.&lt;/li&gt;
&lt;li&gt;grid형태로 화면 구성.&lt;/li&gt;
&lt;/ul&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>사용된 기술 : html, css, js(jquery), node.js, socket.io, express, heroku, react-native(웹뷰로 앱도 만들었는데 사실 의미없음)</p><h2 id="링크"><a href="#링크" class="headerlink" title="링크"></a>링크</h2><ul><li><a href="/etc-file/YACHOO.apk">안드로이드 apk다운로드</a></li><li><a href>ios 다운로드(아직 빌드 안함)</a></li><li><a href="https://yachoo.herokuapp.com/" rel="external nofollow noopener noreferrer" target="_blank">웹 링크</a></li></ul><h3 id="2020-08-15"><a href="#2020-08-15" class="headerlink" title="2020 08 15"></a>2020 08 15</h3><ul><li>유튜브 보다가 삘꽂혀서 닌텐도 스위치 타이틀 [세계 놀이 대전 51]의 Yacth를 웹으로 으로 만들기로 함.</li><li>15일 오늘 기준 node.js 기초만 다진 상태</li><li>온라인 멀티플레이를 구현하려면 서버와 통신 할 방법이 필요함. 뭐 써야하는지 모름.</li><li>구글링 후 소켓통신을 사용하기로 함.</li><li>채팅 예제로 socket.io 공부</li><li>게임 전반적인 기획</li><li>데드라인을 넉넉히 10일로 잡음.</li></ul><h3 id="2020-08-16"><a href="#2020-08-16" class="headerlink" title="2020 08 16"></a>2020 08 16</h3><ul><li>싱글페이지로 만드는게 편하겠다고 판단함.</li><li>채팅기능을 우선적으로 구현하고 socket의 room을 지정해 채팅방끼리만 통신하도록 구현</li><li>게임 진행을 위한 여러 예외처리나 선공 후공 결정, 중간에 플레이어가 나갈 경우, 방이 다 찼을 경우 , 인원수 전체 업데이트 등등등등등 다 기억안남.</li><li>해야할게 너무 많다.</li><li>주사위를 굴릴 area결정.</li><li>grid형태로 화면 구성.</li></ul><a id="more"></a><h3 id="2020-08-17"><a href="#2020-08-17" class="headerlink" title="2020 08 17"></a>2020 08 17</h3><ul><li>주사위 랜덤으로 뽑는건 server에서 돌아감.</li><li>각 socket별로 score보드를 저장하기로 함.(클라이언트에서 접근하면 안됨. 그건 핵임)</li><li>주사위를 굴리고 킵하는 과정에서 양측의 화면이 동시에 업데이트 되도록 함.(client -&gt; server -&gt; client)</li><li>또 예외처리 이것저것 (내 턴일때만 굴리기 등등등)</li></ul><h3 id="2020-08-18"><a href="#2020-08-18" class="headerlink" title="2020 08 18"></a>2020 08 18</h3><ul><li>주사위 굴린 후 점수판 계산 로직 구현(이게 젤 쉬움)</li><li>각 화면에 업데이트</li><li>족보를 선택하면 점수에 반영되도록(이또한 서버사이드)</li></ul><h3 id="2020-08-19"><a href="#2020-08-19" class="headerlink" title="2020 08 19"></a>2020 08 19</h3><ul><li>게임 종료 이벤트 처리</li><li>footer추가</li><li>여러 잔 오류 잡음</li><li>UI개선</li><li>모바일 UI도 조금 손봄</li><li>heroku로 배포</li></ul><h2 id="끝"><a href="#끝" class="headerlink" title="끝"></a>끝</h2><ol><li>짬짬히 했는데 생각보다 빨리끝남.</li><li>코드가 엉망. 지금보면 수정하거나 구조화시킬게 너무많음. 또 변수명도 너무 대충지음.</li><li>클라이언트에서 값을 조작해 게임진행에 치명적인 이상을 줄만한 코드는 왠만하면 서버사이드로 빼둠. (isMyTurn제외 -&gt; 이스터에그ㅋㅋ)</li><li>디자인이 구림.</li><li>주사위 굴리는 사운드도 있으면 좋을 듯</li><li>싱글모드가 없음 (무조건 두명 이상 있어야됨)</li><li>heroku 무료 계정이라 조금 딜레이가 있는데 잘 돌아감.</li></ol><h1 id="방법"><a href="#방법" class="headerlink" title="방법"></a>방법</h1><blockquote><p><a href="https://yachoo.herokuapp.com/" rel="external nofollow noopener noreferrer" target="_blank">게임 링크</a></p></blockquote><ol><li>두 플레이어가 같은 방에 join한다.</li><li>자동으로 시작된다.</li><li>이외의 규칙과 족보는 닌텐도 야추다이스랑 똑같음.</li><li>두 플레이어 모두 보드를 채우면 끝난다. (Total score로 승패 결정. 구현은 안해둠. 눈으로 봐야함)</li></ol><h2 id="번외"><a href="#번외" class="headerlink" title="번외"></a>번외</h2><blockquote><p>모바일로 보면 주사위가 이쁘게 보인다.</p></blockquote>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/08/21/20200821-yachoo/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]N과 M (9 ~ 12) - BOJ 15663 ~ 15666</title>
      <link>https://yhcho0405.github.io/2020/06/12/20200612-boj15663%2015664%2015665%2015666/</link>
      <guid>https://yhcho0405.github.io/2020/06/12/20200612-boj15663%2015664%2015665%2015666/</guid>
      <pubDate>Fri, 12 Jun 2020 12:30:00 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;이 게시물에는 N과 M 시리즈 9부터 12번까지 4문제의 풀이가 들어있음.&lt;br&gt;BOJ 15663 15664 15665 15666&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;모든 조건부 조합의 경우를 출력해야 하는 완전탐색 문제다.&lt;br&gt;사전순 출력이므로 dfs로 쉽게 풀 수 있다.&lt;br&gt;또 &lt;code&gt;cout &amp;lt;&amp;lt; endl;&lt;/code&gt; 는 느리게 작동하므로 &lt;code&gt;cout &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;&lt;/code&gt; 를 사용해야 한다.&lt;/p&gt;
&lt;p&gt;앞선 &lt;a href=&quot;/2020/06/12/20200612-boj15654%2015655%2015656%2015657/&quot;&gt;5 ~ 8번 문제들&lt;/a&gt;과 다르게 주어지는 수 중에 중복되는 숫자가 존재한다.&lt;/p&gt;
&lt;p&gt;중복된 수열을 출력하면 안되므로 같은 레벨의 depth에서 같은 수를 중복해서 호출하지 않도록 해야 한다.&lt;br&gt;따라서 tmp에 해당 값을 담고 매번 체크하며 넘어간다.&lt;br&gt;여기서 tmp는 지역변수로 정의해야한다.&lt;br&gt;각 depth의 tmp는 dfs가 호출 될 때 마다 의미하는 바가 다르기 때문이다.&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<blockquote><p>이 게시물에는 N과 M 시리즈 9부터 12번까지 4문제의 풀이가 들어있음.<br>BOJ 15663 15664 15665 15666</p></blockquote><hr><p>모든 조건부 조합의 경우를 출력해야 하는 완전탐색 문제다.<br>사전순 출력이므로 dfs로 쉽게 풀 수 있다.<br>또 <code>cout &lt;&lt; endl;</code> 는 느리게 작동하므로 <code>cout &lt;&lt; &quot;\n&quot;;</code> 를 사용해야 한다.</p><p>앞선 <a href="/2020/06/12/20200612-boj15654%2015655%2015656%2015657/">5 ~ 8번 문제들</a>과 다르게 주어지는 수 중에 중복되는 숫자가 존재한다.</p><p>중복된 수열을 출력하면 안되므로 같은 레벨의 depth에서 같은 수를 중복해서 호출하지 않도록 해야 한다.<br>따라서 tmp에 해당 값을 담고 매번 체크하며 넘어간다.<br>여기서 tmp는 지역변수로 정의해야한다.<br>각 depth의 tmp는 dfs가 호출 될 때 마다 의미하는 바가 다르기 때문이다.</p><hr><a id="more"></a><br><h3 id="BOJ-15663-N과-M-9"><a href="#BOJ-15663-N과-M-9" class="headerlink" title="BOJ 15663 - N과 M (9)"></a>BOJ 15663 - N과 M (9)</h3><p>chk[]를 사용해 dfs수행 도중 같은 레벨의 depth에서 동일한 수를 사용하지 않도록 한다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, arr[<span class="number">10</span>], chk[<span class="number">10</span>], seq[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(c == m) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span>(!chk[i] &amp;&amp; tmp != seq[i]) &#123;</span><br><span class="line">tmp = arr[c] = seq[i];</span><br><span class="line">chk[i] = <span class="number">1</span>;</span><br><span class="line">dfs(c + <span class="number">1</span>);</span><br><span class="line">chk[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; seq[i];</span><br><span class="line">sort(seq, seq + n + <span class="number">1</span>);</span><br><span class="line">dfs(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="BOJ-15664-N과-M-10"><a href="#BOJ-15664-N과-M-10" class="headerlink" title="BOJ 15664 - N과 M (10)"></a>BOJ 15664 - N과 M (10)</h3><p>9번 문제와 다르게 오름차순이라는 조건이 생겼으므로 이전 depth에 담긴 값보다 클 경우에만 수를 넣도록 한다.<br>이 조건이 9번 문제의 chk[] 역할을 내포하고 있으므로 chk[]는 필요없다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, arr[<span class="number">10</span>], chk[<span class="number">10</span>], seq[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(c == m) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span>(!chk[i] &amp;&amp; tmp != seq[i] &amp;&amp; arr[c - <span class="number">1</span>] &lt;= seq[i]) &#123;</span><br><span class="line">tmp = arr[c] = seq[i];</span><br><span class="line">chk[i] = <span class="number">1</span>;</span><br><span class="line">dfs(c + <span class="number">1</span>);</span><br><span class="line">chk[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; seq[i];</span><br><span class="line">sort(seq, seq + n + <span class="number">1</span>);</span><br><span class="line">dfs(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="BOJ-15665-N과-M-11"><a href="#BOJ-15665-N과-M-11" class="headerlink" title="BOJ 15665 - N과 M (11)"></a>BOJ 15665 - N과 M (11)</h3><p>같은 수를 여러 번 골라도 되므로 조건없는 완전탐색이다.<br>위의 문제들에서 tmp를 제외한 조건을 삭제하면 된다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, arr[<span class="number">10</span>], seq[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(c == m) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span>(tmp != seq[i]) &#123;</span><br><span class="line">tmp = arr[c] = seq[i];</span><br><span class="line">dfs(c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; seq[i];</span><br><span class="line">sort(seq, seq + n + <span class="number">1</span>);</span><br><span class="line">dfs(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="BOJ-15666-N과-M-12"><a href="#BOJ-15666-N과-M-12" class="headerlink" title="BOJ 15666 - N과 M (12)"></a>BOJ 15666 - N과 M (12)</h3><p>말만 복잡하지 요약하자면 10번 문제에서 중복을 허용하는 오름차순일 뿐이다.<br><code>&lt;</code> 를 <code>&lt;=</code> 로 바꿔주면 된다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, arr[<span class="number">10</span>], seq[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(c == m) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span>(tmp != seq[i] &amp;&amp; arr[c - <span class="number">1</span>] &lt;= seq[i]) &#123;</span><br><span class="line">tmp = arr[c] = seq[i];</span><br><span class="line">dfs(c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; seq[i];</span><br><span class="line">sort(seq, seq + n + <span class="number">1</span>);</span><br><span class="line">dfs(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/06/12/20200612-boj15663%2015664%2015665%2015666/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]N과 M (5 ~ 8) - BOJ 15654 ~ 15657</title>
      <link>https://yhcho0405.github.io/2020/06/12/20200612-boj15654%2015655%2015656%2015657/</link>
      <guid>https://yhcho0405.github.io/2020/06/12/20200612-boj15654%2015655%2015656%2015657/</guid>
      <pubDate>Fri, 12 Jun 2020 12:00:00 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;이 게시물에는 N과 M 시리즈 5부터 8번까지 4문제의 풀이가 들어있음.&lt;br&gt;BOJ 15654 15655 15656 15657&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;모든 조건부 조합의 경우를 출력해야 하는 완전탐색 문제다.&lt;br&gt;사전순 출력이므로 dfs로 쉽게 풀 수 있다.&lt;br&gt;또 &lt;code&gt;cout &amp;lt;&amp;lt; endl;&lt;/code&gt; 는 느리게 작동하므로 &lt;code&gt;cout &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;&lt;/code&gt; 를 사용해야 한다.&lt;/p&gt;
&lt;p&gt;앞선 &lt;a href=&quot;/2020/06/12/20200612-boj15649%2015650%2015651%2015652/&quot;&gt;1 ~ 4번 문제들&lt;/a&gt;과 다르게 주어진 수 들로 수열을 만들어야 한다.&lt;br&gt;또 숫자를 입력받고 오름차순 정렬해야 사전순 출력이 쉽다.&lt;br&gt;그 부분을 제외하고 방식은 동일하다.&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<blockquote><p>이 게시물에는 N과 M 시리즈 5부터 8번까지 4문제의 풀이가 들어있음.<br>BOJ 15654 15655 15656 15657</p></blockquote><hr><p>모든 조건부 조합의 경우를 출력해야 하는 완전탐색 문제다.<br>사전순 출력이므로 dfs로 쉽게 풀 수 있다.<br>또 <code>cout &lt;&lt; endl;</code> 는 느리게 작동하므로 <code>cout &lt;&lt; &quot;\n&quot;;</code> 를 사용해야 한다.</p><p>앞선 <a href="/2020/06/12/20200612-boj15649%2015650%2015651%2015652/">1 ~ 4번 문제들</a>과 다르게 주어진 수 들로 수열을 만들어야 한다.<br>또 숫자를 입력받고 오름차순 정렬해야 사전순 출력이 쉽다.<br>그 부분을 제외하고 방식은 동일하다.</p><hr><a id="more"></a><br><h3 id="BOJ-15654-N과-M-5"><a href="#BOJ-15654-N과-M-5" class="headerlink" title="BOJ 15654 - N과 M (5)"></a>BOJ 15654 - N과 M (5)</h3><p>chk[]를 사용해 dfs수행 도중 같은 레벨의 depth에서 동일한 수를 사용하지 않도록 한다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, arr[<span class="number">10</span>], chk[<span class="number">10</span>], seq[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(c == m) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span>(!chk[i]) &#123;</span><br><span class="line">arr[c] = seq[i];</span><br><span class="line">chk[i] = <span class="number">1</span>;</span><br><span class="line">dfs(c + <span class="number">1</span>);</span><br><span class="line">chk[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; seq[i];</span><br><span class="line">sort(seq, seq + n + <span class="number">1</span>);</span><br><span class="line">dfs(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="BOJ-15655-N과-M-6"><a href="#BOJ-15655-N과-M-6" class="headerlink" title="BOJ 15655 - N과 M (6)"></a>BOJ 15655 - N과 M (6)</h3><p>5번 문제와 다르게 오름차순이라는 조건이 생겼으므로 이전 depth에 담긴 값보다 클 경우에만 수를 넣도록 한다.<br>이 조건이 5번 문제의 chk[] 역할을 내포하고 있으므로 chk[]는 필요없다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, arr[<span class="number">10</span>], seq[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(c == m) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span>(arr[c - <span class="number">1</span>] &lt; seq[i]) &#123;</span><br><span class="line">arr[c] = seq[i];</span><br><span class="line">dfs(c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; seq[i];</span><br><span class="line">sort(seq, seq + n + <span class="number">1</span>);</span><br><span class="line">dfs(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="BOJ-15656-N과-M-7"><a href="#BOJ-15656-N과-M-7" class="headerlink" title="BOJ 15656 - N과 M (7)"></a>BOJ 15656 - N과 M (7)</h3><p>같은 수를 여러 번 골라도 되므로 조건없는 완전탐색이다.<br>위의 문제들에서 조건을 삭제하면 된다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, arr[<span class="number">10</span>], seq[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(c == m) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">arr[c] = seq[i];</span><br><span class="line">dfs(c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; seq[i];</span><br><span class="line">sort(seq, seq + n + <span class="number">1</span>);</span><br><span class="line">dfs(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="BOJ-15657-N과-M-8"><a href="#BOJ-15657-N과-M-8" class="headerlink" title="BOJ 15657 - N과 M (8)"></a>BOJ 15657 - N과 M (8)</h3><p>말만 복잡하지 요약하자면 6번 문제에서 중복을 허용하는 오름차순일 뿐이다.<br><code>&lt;</code> 를 <code>&lt;=</code> 로 바꿔주면 된다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, arr[<span class="number">10</span>], seq[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(c == m) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span>(arr[c - <span class="number">1</span>] &lt;= seq[i]) &#123;</span><br><span class="line">arr[c] = seq[i];</span><br><span class="line">dfs(c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; seq[i];</span><br><span class="line">sort(seq, seq + n + <span class="number">1</span>);</span><br><span class="line">dfs(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/06/12/20200612-boj15654%2015655%2015656%2015657/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]N과 M (1 ~ 4) - BOJ 15649 ~ 15652</title>
      <link>https://yhcho0405.github.io/2020/06/12/20200612-boj15649%2015650%2015651%2015652/</link>
      <guid>https://yhcho0405.github.io/2020/06/12/20200612-boj15649%2015650%2015651%2015652/</guid>
      <pubDate>Fri, 12 Jun 2020 11:30:00 GMT</pubDate>
      <description>
      
        &lt;blockquote&gt;
&lt;p&gt;이 게시물에는 N과 M 시리즈 1부터 4번까지 4문제의 풀이가 들어있음.&lt;br&gt;BOJ 15649 15650 15651 15652&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;모든 조건부 조합의 경우를 출력해야 하는 완전탐색 문제다.&lt;br&gt;사전순 출력이므로 dfs로 쉽게 풀 수 있다.&lt;br&gt;또 &lt;code&gt;cout &amp;lt;&amp;lt; endl;&lt;/code&gt; 는 느리게 작동하므로 &lt;code&gt;cout &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;&lt;/code&gt; 를 사용해야 한다.&lt;/p&gt;
&lt;hr&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<blockquote><p>이 게시물에는 N과 M 시리즈 1부터 4번까지 4문제의 풀이가 들어있음.<br>BOJ 15649 15650 15651 15652</p></blockquote><hr><p>모든 조건부 조합의 경우를 출력해야 하는 완전탐색 문제다.<br>사전순 출력이므로 dfs로 쉽게 풀 수 있다.<br>또 <code>cout &lt;&lt; endl;</code> 는 느리게 작동하므로 <code>cout &lt;&lt; &quot;\n&quot;;</code> 를 사용해야 한다.</p><hr><a id="more"></a><br><h3 id="BOJ-15649-N과-M-1"><a href="#BOJ-15649-N과-M-1" class="headerlink" title="BOJ 15649 - N과 M (1)"></a>BOJ 15649 - N과 M (1)</h3><p>chk[]를 사용해 dfs수행 도중 같은 레벨의 depth에서 동일한 수를 사용하지 않도록 한다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, arr[<span class="number">10</span>], chk[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(c == m) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span>(!chk[i]) &#123;</span><br><span class="line">arr[c] = i;</span><br><span class="line">chk[i] = <span class="number">1</span>;</span><br><span class="line">dfs(c + <span class="number">1</span>);</span><br><span class="line">chk[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">dfs(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="BOJ-15650-N과-M-2"><a href="#BOJ-15650-N과-M-2" class="headerlink" title="BOJ 15650 - N과 M (2)"></a>BOJ 15650 - N과 M (2)</h3><p>1번 문제와 다르게 오름차순이라는 조건이 생겼으므로 이전 depth에 담긴 값보다 클 경우에만 수를 넣도록 한다.<br>이 조건이 1번 문제의 chk[] 역할을 내포하고 있으므로 chk[]는 필요없다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, arr[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(c == m) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span>(arr[c - <span class="number">1</span>] &lt; i) &#123;</span><br><span class="line">arr[c] = i;</span><br><span class="line">dfs(c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">dfs(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="BOJ-15651-N과-M-3"><a href="#BOJ-15651-N과-M-3" class="headerlink" title="BOJ 15651 - N과 M (3)"></a>BOJ 15651 - N과 M (3)</h3><p>같은 수를 여러 번 골라도 되므로 조건없는 완전탐색이다.<br>위의 문제들에서 조건을 삭제하면 된다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, arr[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(c == m) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">arr[c] = i;</span><br><span class="line">dfs(c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">dfs(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="BOJ-15652-N과-M-4"><a href="#BOJ-15652-N과-M-4" class="headerlink" title="BOJ 15652 - N과 M (4)"></a>BOJ 15652 - N과 M (4)</h3><p>말만 복잡하지 요약하자면 2번 문제에서 중복을 허용하는 오름차순일 뿐이다.<br><code>&lt;</code> 를 <code>&lt;=</code> 로 바꿔주면 된다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, arr[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(c == m) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span>(arr[c - <span class="number">1</span>] &lt;= i) &#123;</span><br><span class="line">arr[c] = i;</span><br><span class="line">dfs(c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">dfs(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/06/12/20200612-boj15649%2015650%2015651%2015652/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 2644 - 탈출</title>
      <link>https://yhcho0405.github.io/2020/06/05/20200605-boj3055/</link>
      <guid>https://yhcho0405.github.io/2020/06/05/20200605-boj3055/</guid>
      <pubDate>Fri, 05 Jun 2020 07:30:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;돌이 ‘X’라는 말을 못봐서 틀렸다. 이런거 못보고 지나쳐서 틀렸을때는 매우 화난다. 그리고 이런곳에서 틀릴거라곤 상상도 못하기 때문에 해결하는데 시간도 오래걸린다.&lt;/p&gt;
&lt;p&gt;아무튼 bfs다.&lt;br&gt;한칸씩 확장해나가기 위해 큐 사이즈를 기준으로 while을 번갈아가며 돌린다.&lt;br&gt;비버가 굴에 도착하면 확장시킨 횟수를 출력한다.&lt;br&gt;비버가 굴로 못들어가면 “선인장”을 출력한다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>돌이 ‘X’라는 말을 못봐서 틀렸다. 이런거 못보고 지나쳐서 틀렸을때는 매우 화난다. 그리고 이런곳에서 틀릴거라곤 상상도 못하기 때문에 해결하는데 시간도 오래걸린다.</p><p>아무튼 bfs다.<br>한칸씩 확장해나가기 위해 큐 사이즈를 기준으로 while을 번갈아가며 돌린다.<br>비버가 굴에 도착하면 확장시킨 횟수를 출력한다.<br>비버가 굴로 못들어가면 “선인장”을 출력한다.</p><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> r, c, cx, cy, xx, yy, gs, wss, dx[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dy[] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, ans;</span><br><span class="line"><span class="keyword">char</span> arr[<span class="number">52</span>][<span class="number">52</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; wx, wy, gx, gy;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; r &gt;&gt; c;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, &amp;arr[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; j++)</span><br><span class="line"><span class="keyword">if</span>(arr[i][j] == <span class="string">'S'</span>) gx.push(j), gy.push(i);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(arr[i][j] == <span class="string">'*'</span>) wx.push(j), wy.push(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!gx.empty()) &#123;</span><br><span class="line">wss = wx.size(); gs = gx.size();</span><br><span class="line"><span class="keyword">while</span>(wss--) &#123;</span><br><span class="line">cx = wx.front(); wx.pop();</span><br><span class="line">cy = wy.front(); wy.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">xx = cx + dx[i]; yy = cy + dy[i];</span><br><span class="line"><span class="keyword">if</span>(xx &gt;= c || yy &gt;= r || xx &lt; <span class="number">0</span> || yy &lt; <span class="number">0</span> || arr[yy][xx] != <span class="string">'.'</span>) <span class="keyword">continue</span>;</span><br><span class="line">wx.push(xx), wy.push(yy); arr[yy][xx] = <span class="string">'*'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(gs--) &#123;</span><br><span class="line">cx = gx.front(); gx.pop();</span><br><span class="line">cy = gy.front(); gy.pop();</span><br><span class="line"><span class="keyword">if</span>(arr[cy][cx] == <span class="string">'D'</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">xx = cx + dx[i]; yy = cy + dy[i];</span><br><span class="line"><span class="keyword">if</span>(xx &gt;= c || yy &gt;= r || xx &lt; <span class="number">0</span> || yy &lt; <span class="number">0</span> || arr[yy][xx] == <span class="string">'S'</span> || arr[yy][xx] == <span class="string">'*'</span> || arr[yy][xx] == <span class="string">'X'</span>) <span class="keyword">continue</span>;</span><br><span class="line">gx.push(xx), gy.push(yy);</span><br><span class="line"><span class="keyword">if</span>(arr[yy][xx] != <span class="string">'D'</span>) arr[yy][xx] = <span class="string">'S'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"KAKTUS"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/06/05/20200605-boj3055/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 2644 - 촌수계산</title>
      <link>https://yhcho0405.github.io/2020/06/05/20200605-boj2644/</link>
      <guid>https://yhcho0405.github.io/2020/06/05/20200605-boj2644/</guid>
      <pubDate>Fri, 05 Jun 2020 07:10:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;말이 촌수계산이지 그냥 노드와 노드사이의 거리를 구하면 된다.&lt;br&gt;최소 길이를 구하면 되므로 시작노드를 기준으로 bfs돌리면 된다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>말이 촌수계산이지 그냥 노드와 노드사이의 거리를 구하면 된다.<br>최소 길이를 구하면 되므로 시작노드를 기준으로 bfs돌리면 된다.</p><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> n, m, a, b, c, d, cq, arr[<span class="number">102</span>][<span class="number">102</span>], v[<span class="number">102</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; c &gt;&gt; d;</span><br><span class="line">arr[c][d] = arr[d][c] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">q.push(a);</span><br><span class="line"><span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">cq = q.front(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span>(arr[cq][i] &amp;&amp; !v[i])</span><br><span class="line">q.push(i), v[i] = v[cq] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (v[b] ? v[b] : <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/06/05/20200605-boj2644/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 2206 - 벽 부수고 이동하기</title>
      <link>https://yhcho0405.github.io/2020/05/31/20200531-boj2206/</link>
      <guid>https://yhcho0405.github.io/2020/05/31/20200531-boj2206/</guid>
      <pubDate>Sun, 31 May 2020 06:25:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;bfs로 갈 수 있는 경로를 탐색하면서 벽을 만났을 때 벽을 부순적이 없다면 벽을 부수고 이동하고 벽을 부순적이 있다면 지나간다.&lt;br&gt;벽을 부순적이 있는가 여부를 담을 큐 하나를 추가로 만들어주고 x, y와 함께 담아서 매칭시킨다.&lt;br&gt;처음에는 방문처리를 위한 v배열을 2차원으로 구성했는데 오답으로 처리됐다.&lt;br&gt;이유를 생각해보니 같은 위치에 있더라도 벽을 부순적이 있는 경로를 지나쳤거나 부순적이 없는 경로를 지나쳤거나 두 가지 경우가 있기 때문에 몇가지 경우의 수가 누락된다.&lt;br&gt;따라서 같은 위치라도 부순적이 있을 때, 없을 때도 고려해서 방문처리를 해 주어야 한다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>bfs로 갈 수 있는 경로를 탐색하면서 벽을 만났을 때 벽을 부순적이 없다면 벽을 부수고 이동하고 벽을 부순적이 있다면 지나간다.<br>벽을 부순적이 있는가 여부를 담을 큐 하나를 추가로 만들어주고 x, y와 함께 담아서 매칭시킨다.<br>처음에는 방문처리를 위한 v배열을 2차원으로 구성했는데 오답으로 처리됐다.<br>이유를 생각해보니 같은 위치에 있더라도 벽을 부순적이 있는 경로를 지나쳤거나 부순적이 없는 경로를 지나쳤거나 두 가지 경우가 있기 때문에 몇가지 경우의 수가 누락된다.<br>따라서 같은 위치라도 부순적이 있을 때, 없을 때도 고려해서 방문처리를 해 주어야 한다.</p><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, cx, cy, cd, xx, yy, arr[<span class="number">1002</span>][<span class="number">1002</span>], v[<span class="number">1002</span>][<span class="number">1002</span>][<span class="number">2</span>], dx[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dy[] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, mn, mx;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qx, qy, qd;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%1d"</span>, &amp;arr[i][j]);</span><br><span class="line">qx.push(<span class="number">1</span>), qy.push(<span class="number">1</span>), qd.push(<span class="number">0</span>); v[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!qx.empty()) &#123;</span><br><span class="line">cx = qx.front(); qx.pop();</span><br><span class="line">cy = qy.front(); qy.pop();</span><br><span class="line">cd = qd.front(); qd.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">xx = cx + dx[i]; yy = cy + dy[i];</span><br><span class="line"><span class="keyword">if</span>(xx &gt; m || yy &gt; n || xx &lt; <span class="number">1</span> || yy &lt; <span class="number">1</span> || v[yy][xx][cd]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(arr[yy][xx]) &#123;</span><br><span class="line"><span class="keyword">if</span>(cd) <span class="keyword">continue</span>;</span><br><span class="line">v[yy][xx][<span class="number">1</span>] = v[cy][cx][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">qx.push(xx), qy.push(yy), qd.push(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">v[yy][xx][cd] = v[cy][cx][cd] + <span class="number">1</span>;</span><br><span class="line">qx.push(xx), qy.push(yy), qd.push(cd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">mn = min(v[n][m][<span class="number">0</span>], v[n][m][<span class="number">1</span>]); mx = max(v[n][m][<span class="number">0</span>], v[n][m][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span>(mn) <span class="built_in">cout</span> &lt;&lt; mn;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(mx) <span class="built_in">cout</span> &lt;&lt; mx;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"-1"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/05/31/20200531-boj2206/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 13460 - 구슬 탈출 2</title>
      <link>https://yhcho0405.github.io/2020/05/31/20200531-boj13460/</link>
      <guid>https://yhcho0405.github.io/2020/05/31/20200531-boj13460/</guid>
      <pubDate>Sat, 30 May 2020 23:32:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;처음에 시도했던 방법은 bfs에서 각 4가지 방향으로 기울였을 때 도달하는 지점의 좌표를 리턴하는 함수를 구현해 사용하는 것이었는데, 이후에 &lt;strong&gt;빨간 구슬과 파란 구슬은 동시에 같은 칸에 있을 수 없다.&lt;/strong&gt; 라는 문구를 보고 한참동안 뇌정지가 왔다.&lt;br&gt;어찌보면 당연하다. 구슬은 물리적으로 겹쳐질 수 없다.&lt;br&gt;구슬이 겹쳐지지 않는 경우를 알기 위해서 가장 쉽게 생각할 수 있는 방법은 구슬의 이동거리를 측정하는 것이다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>처음에 시도했던 방법은 bfs에서 각 4가지 방향으로 기울였을 때 도달하는 지점의 좌표를 리턴하는 함수를 구현해 사용하는 것이었는데, 이후에 <strong>빨간 구슬과 파란 구슬은 동시에 같은 칸에 있을 수 없다.</strong> 라는 문구를 보고 한참동안 뇌정지가 왔다.<br>어찌보면 당연하다. 구슬은 물리적으로 겹쳐질 수 없다.<br>구슬이 겹쳐지지 않는 경우를 알기 위해서 가장 쉽게 생각할 수 있는 방법은 구슬의 이동거리를 측정하는 것이다.</p><a id="more"></a><p>예를들어 #RB…….# 같은 간단한 구슬 탈출 장난감이 있다고 치자.<br>A를 빨간구슬과 파란구슬이 겹쳐진 신비롭고 놀라운 구슬이라고 가정하면, 위 상황에서 오른쪽으로 기울였을 때 #…….A# 가 된다.<br>이 때 R은 B보다 더 많은 거리를 이동했다. 이 말은 즉, “A는 B보다 왼쪽에 위치했었다” 라고 말할 수 있다.<br>따라서 A를 B로 바꾸고 R을 B왼쪽에 두면 #…….RB# 이런 형태가 돼서 겹쳐지지 않고 구슬을 이동시킬 수 있다.</p><p>그리고 bfs를 돌려서 각 방향으로 기울였을 때의 빨간구슬과 파란구슬의 위치를 탐색한다.<br>그리고 이전의 탐색 문제들과는 다르게 빨간 구슬이 한번 방문했던 위치라도 파란 구슬의 위치에 따라 결과가 달라지므로 방문처리를 위한 배열을 4차원 배열로 구성해 빨간구슬의 위치와 파란구슬의 위치를 동시에 체크해주어야 한다.</p><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, rx, ry, bx, by, crx, cry, cbx, cby, cqc, cnt1, cnt2, v[<span class="number">12</span>][<span class="number">12</span>][<span class="number">12</span>][<span class="number">12</span>], dx[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dy[] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, ans;</span><br><span class="line"><span class="keyword">char</span> arr[<span class="number">12</span>][<span class="number">12</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; x1, x2, y1, y2, qc;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, &amp;arr[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line"><span class="keyword">if</span>(arr[i][j] == <span class="string">'R'</span>) rx = j, ry = i;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(arr[i][j] == <span class="string">'B'</span>) bx = j, by = i;</span><br><span class="line">&#125;</span><br><span class="line">x1.push(rx), x2.push(bx), y1.push(ry), y2.push(by), qc.push(<span class="number">0</span>);</span><br><span class="line">v[rx][ry][bx][by] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!x1.empty()) &#123;</span><br><span class="line">rx = x1.front(); x1.pop();</span><br><span class="line">ry = y1.front(); y1.pop();</span><br><span class="line">bx = x2.front(); x2.pop();</span><br><span class="line">by = y2.front(); y2.pop();</span><br><span class="line">cqc = qc.front(); qc.pop();</span><br><span class="line"><span class="keyword">if</span>(cqc &gt; <span class="number">10</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"-1"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(arr[ry][rx] == <span class="string">'O'</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cqc;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">crx = rx; cry = ry; cbx = bx; cby = by; cnt1 = <span class="number">0</span>; cnt2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(arr[cry + dy[i]][crx + dx[i]] != <span class="string">'#'</span> &amp;&amp; arr[cry][crx] != <span class="string">'O'</span>) &#123;</span><br><span class="line">crx += dx[i];</span><br><span class="line">cry += dy[i];</span><br><span class="line">cnt1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(arr[cby + dy[i]][cbx + dx[i]] != <span class="string">'#'</span> &amp;&amp; arr[cby][cbx] != <span class="string">'O'</span>) &#123;</span><br><span class="line">cbx += dx[i];</span><br><span class="line">cby += dy[i];</span><br><span class="line">cnt2++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(crx == cbx &amp;&amp; cry == cby) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[cby][cbx] == <span class="string">'O'</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(cnt1 &gt; cnt2) &#123;</span><br><span class="line">crx -= dx[i];</span><br><span class="line">cry -= dy[i];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cbx -= dx[i];</span><br><span class="line">cby -= dy[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(v[crx][cry][cbx][cby]) <span class="keyword">continue</span>;</span><br><span class="line">v[crx][cry][cbx][cby] = <span class="number">1</span>;</span><br><span class="line">x1.push(crx), x2.push(cbx), y1.push(cry), y2.push(cby), qc.push(cqc + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"-1"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/05/31/20200531-boj13460/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 7562 - 나이트의 이동</title>
      <link>https://yhcho0405.github.io/2020/05/28/20200528-boj7562/</link>
      <guid>https://yhcho0405.github.io/2020/05/28/20200528-boj7562/</guid>
      <pubDate>Thu, 28 May 2020 14:42:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;나이트가 이동할 수 있는 자리를 bfs나 dfs로 탐색해나가다 도착점까지의 이동횟수를 출력하면 된다.&lt;br&gt;테스트케이스가 여러개라서 이 부분을 깔끔하게 처리해야한다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>나이트가 이동할 수 있는 자리를 bfs나 dfs로 탐색해나가다 도착점까지의 이동횟수를 출력하면 된다.<br>테스트케이스가 여러개라서 이 부분을 깔끔하게 처리해야한다.</p><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dx[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;, dy[] = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> t, l, x1, y1, x2, y2, cx, cy, xx, yy, arr[<span class="number">302</span>][<span class="number">302</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qx, qy;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t--) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; l &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">arr[y1][x1] = <span class="number">1</span>;</span><br><span class="line">qx.push(x1), qy.push(y1);</span><br><span class="line"><span class="keyword">while</span>(!qx.empty()) &#123;</span><br><span class="line">cx = qx.front(); qx.pop();</span><br><span class="line">cy = qy.front(); qy.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">xx = cx + dx[i]; yy = cy + dy[i];</span><br><span class="line"><span class="keyword">if</span>(xx &gt;= l || yy &gt;= l || xx &lt; <span class="number">0</span> || yy &lt; <span class="number">0</span> || arr[yy][xx]) <span class="keyword">continue</span>;</span><br><span class="line">qx.push(xx), qy.push(yy);</span><br><span class="line">arr[yy][xx] = arr[cy][cx] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[y2][x2] - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/05/28/20200528-boj7562/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 10026 - 적록색약</title>
      <link>https://yhcho0405.github.io/2020/05/28/20200528-boj10026/</link>
      <guid>https://yhcho0405.github.io/2020/05/28/20200528-boj10026/</guid>
      <pubDate>Wed, 27 May 2020 15:01:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;문자열 입력인 문제가 오랜만이라 한번 틀렸다ㅠ&lt;br&gt;입력 받을 때 주의할 것.&lt;br&gt;무작정 두가지 경우를 다 돌려도 되지만 더 간단하게 짜봤다.&lt;br&gt;핵심은 적록색약이 아닌 사람을 탐색할 때 R을 B로 바꿔버리는 것이다.&lt;br&gt;그러면 적록색약인 사람을 탐색할 때 R은 전부 B로 바뀌어 조건에 맞게 탐색하게 된다.&lt;br&gt;dfs로 풀어봤다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>문자열 입력인 문제가 오랜만이라 한번 틀렸다ㅠ<br>입력 받을 때 주의할 것.<br>무작정 두가지 경우를 다 돌려도 되지만 더 간단하게 짜봤다.<br>핵심은 적록색약이 아닌 사람을 탐색할 때 R을 B로 바꿔버리는 것이다.<br>그러면 적록색약인 사람을 탐색할 때 R은 전부 B로 바뀌어 조건에 맞게 탐색하게 된다.<br>dfs로 풀어봤다.</p><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, ans1, ans2, c, xx, yy, dx[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dy[] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> arr[<span class="number">102</span>][<span class="number">102</span>], v[<span class="number">102</span>][<span class="number">102</span>], color[<span class="number">3</span>] = &#123;<span class="string">'R'</span>, <span class="string">'G'</span>, <span class="string">'B'</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">v[y][x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(arr[y][x] == <span class="string">'R'</span>) arr[y][x] = <span class="string">'G'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">xx = x + dx[i]; yy = y + dy[i];</span><br><span class="line"><span class="keyword">if</span>(xx &lt; n &amp;&amp; yy &lt; n &amp;&amp; xx &gt;= <span class="number">0</span> &amp;&amp; yy &gt;= <span class="number">0</span> &amp;&amp; arr[yy][xx] == color[c] &amp;&amp; !v[yy][xx]) dfs(xx, yy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, &amp;arr[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="number">2</span>; t++) &#123; <span class="comment">// 0 = 적록색약이 아닌사람, 1 = 적록색약인 사람  </span></span><br><span class="line"><span class="keyword">for</span>(c = t; c &lt; <span class="number">3</span>; c++) <span class="comment">// color</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line"><span class="keyword">if</span>(arr[i][j] == color[c] &amp;&amp; !v[i][j]) &#123;</span><br><span class="line">dfs(j, i);</span><br><span class="line"><span class="keyword">if</span>(t) ans2++;</span><br><span class="line"><span class="keyword">else</span> ans1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span>(v));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans1 &lt;&lt; <span class="string">" "</span> &lt;&lt; ans2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/05/28/20200528-boj10026/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 7569 - 토마토</title>
      <link>https://yhcho0405.github.io/2020/05/27/20200527-boj7569/</link>
      <guid>https://yhcho0405.github.io/2020/05/27/20200527-boj7569/</guid>
      <pubDate>Wed, 27 May 2020 08:41:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;재밌는 문제다.&lt;br&gt;같은 이름의 문제가 두 개인데 이 문제 -&amp;gt; &lt;a href=&quot;/2020/05/20/20200520-boj7576/&quot;&gt;토마토&lt;/a&gt;는 2차원 공간에서의 탐색이라면 지금 이 문제는 3차원 공간에서의 탐색이다.&lt;br&gt;기본적인 풀이는 2차원 &lt;a href=&quot;/2020/05/20/20200520-boj7576/&quot;&gt;토마토&lt;/a&gt;와 같고 축 하나만 더 추가하면 된다.&lt;br&gt;bfs로 풀었다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>재밌는 문제다.<br>같은 이름의 문제가 두 개인데 이 문제 -&gt; <a href="/2020/05/20/20200520-boj7576/">토마토</a>는 2차원 공간에서의 탐색이라면 지금 이 문제는 3차원 공간에서의 탐색이다.<br>기본적인 풀이는 2차원 <a href="/2020/05/20/20200520-boj7576/">토마토</a>와 같고 축 하나만 더 추가하면 된다.<br>bfs로 풀었다.</p><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">6</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dy[<span class="number">6</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, dz[<span class="number">6</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> m, n, h, cx, cy, cz, xx, yy, zz, arr[<span class="number">102</span>][<span class="number">102</span>][<span class="number">102</span>], ans;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qx, qy, qz;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n &gt;&gt; h;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> z = <span class="number">1</span>; z &lt;= h; z++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= n; y++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= m; x++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; arr[z][y][x];</span><br><span class="line"><span class="keyword">if</span>(arr[z][y][x] == <span class="number">1</span>) qx.push(x), qy.push(y), qz.push(z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!qx.empty()) &#123;</span><br><span class="line">cx = qx.front(); qx.pop();</span><br><span class="line">cy = qy.front(); qy.pop();</span><br><span class="line">cz = qz.front(); qz.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">xx = cx + dx[i]; yy = cy + dy[i]; zz = cz + dz[i];</span><br><span class="line"><span class="keyword">if</span>(xx &lt; <span class="number">1</span> || yy &lt; <span class="number">1</span> || zz &lt; <span class="number">1</span> || xx &gt; m || yy &gt; n || zz &gt; h || arr[zz][yy][xx]) <span class="keyword">continue</span>;</span><br><span class="line">qx.push(xx), qy.push(yy), qz.push(zz);</span><br><span class="line">arr[zz][yy][xx] = arr[cz][cy][cx] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> z = <span class="number">1</span>; z &lt;= h; z++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= n; y++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= m; x++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!arr[z][y][x]) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"-1"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">ans = max(ans, arr[z][y][x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/05/27/20200527-boj7569/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 2583 - 영역 구하기</title>
      <link>https://yhcho0405.github.io/2020/05/27/20200527-boj2583/</link>
      <guid>https://yhcho0405.github.io/2020/05/27/20200527-boj2583/</guid>
      <pubDate>Wed, 27 May 2020 08:27:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;주어진 좌표로 배열에 해당 영역을 채우고 빈 영역을 dfs나 bfs 돌리면 되는 단순한 탐색 문제다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>주어진 좌표로 배열에 해당 영역을 채우고 빈 영역을 dfs나 bfs 돌리면 되는 단순한 탐색 문제다.</p><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> m, n, k, x1, x2, y1, y2, arr[<span class="number">102</span>][<span class="number">102</span>], xx, yy, dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, tmp, ans;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; area;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">arr[y][x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">xx = x + dx[i]; yy = y + dy[i];</span><br><span class="line"><span class="keyword">if</span>(xx &gt;= n || yy &gt;= m || xx &lt; <span class="number">0</span> || yy &lt; <span class="number">0</span> || arr[yy][xx]) <span class="keyword">continue</span>;</span><br><span class="line">tmp++;</span><br><span class="line">dfs(xx, yy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">while</span>(k--) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = x1; x &lt; x2; x++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> y = y1; y &lt; y2; y++)</span><br><span class="line">arr[y][x] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line"><span class="keyword">if</span>(!arr[i][j]) &#123;</span><br><span class="line">tmp = <span class="number">1</span>;</span><br><span class="line">dfs(j, i);</span><br><span class="line">area.push_back(tmp);</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">sort(area.begin(), area.end());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; area.size(); i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; area[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/05/27/20200527-boj2583/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 2468 - 안전 영역</title>
      <link>https://yhcho0405.github.io/2020/05/27/20200527-boj2468/</link>
      <guid>https://yhcho0405.github.io/2020/05/27/20200527-boj2468/</guid>
      <pubDate>Wed, 27 May 2020 08:20:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;범위가 그리 크지 않기 때문에 내리는 비의 양을 완전탐색하고 그때마다 높이를 기준으로 dfs나 bfs를 돌리면 된다.&lt;br&gt;이 문제는 dfs로 풀어봤다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>범위가 그리 크지 않기 때문에 내리는 비의 양을 완전탐색하고 그때마다 높이를 기준으로 dfs나 bfs를 돌리면 된다.<br>이 문제는 dfs로 풀어봤다.</p><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, h, arr[<span class="number">102</span>][<span class="number">102</span>], v[<span class="number">102</span>][<span class="number">102</span>], xx, yy, ans, tmp, dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">v[y][x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">xx = x + dx[i]; yy = y + dy[i];</span><br><span class="line"><span class="keyword">if</span>(xx &gt; n || yy &gt; n || xx &lt; <span class="number">1</span> || yy &lt; <span class="number">1</span> || arr[yy][xx] &lt;= h || v[yy][xx]) <span class="keyword">continue</span>;</span><br><span class="line">dfs(xx, yy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; arr[i][j];</span><br><span class="line">m = max(m, arr[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(h = <span class="number">0</span>; h &lt;= m; h++) &#123;</span><br><span class="line"><span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span>(v)); tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="keyword">if</span>(arr[i][j] &gt; h &amp;&amp; !v[i][j]) &#123;</span><br><span class="line">dfs(j, i);</span><br><span class="line">tmp++;</span><br><span class="line">&#125;</span><br><span class="line">ans = max(ans, tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/05/27/20200527-boj2468/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 6603 - 로또</title>
      <link>https://yhcho0405.github.io/2020/05/26/20200526-boj6603/</link>
      <guid>https://yhcho0405.github.io/2020/05/26/20200526-boj6603/</guid>
      <pubDate>Tue, 26 May 2020 09:06:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;주어진 집합에서 수 6개를 고르는 경우의 수를 완전탐색하는 문제다.&lt;br&gt;사전순 출력이기 때문에 dfs로 순차 출력하면 된다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>주어진 집합에서 수 6개를 고르는 경우의 수를 완전탐색하는 문제다.<br>사전순 출력이기 때문에 dfs로 순차 출력하면 된다.</p><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> k, arr[<span class="number">15</span>], ans[<span class="number">15</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(c == <span class="number">6</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = s; i &lt; k; i++) &#123;</span><br><span class="line">ans[c] = arr[i];</span><br><span class="line">dfs(i + <span class="number">1</span>, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; k &amp;&amp; k) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>구조 자체가 이해했더라도 갑자기 떠올리기 힘든 형태다ㅠ</p></blockquote>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/05/26/20200526-boj6603/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 11403 - 경로 찾기</title>
      <link>https://yhcho0405.github.io/2020/05/24/20200524-boj11403/</link>
      <guid>https://yhcho0405.github.io/2020/05/24/20200524-boj11403/</guid>
      <pubDate>Sun, 24 May 2020 14:30:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;방향성을 가지는 그래프를 탐색하는 것으로 dfs, bfs 모두 가능하다.&lt;br&gt;이 문제는 dfs로 풀어봤다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>방향성을 가지는 그래프를 탐색하는 것으로 dfs, bfs 모두 가능하다.<br>이 문제는 dfs로 풀어봤다.</p><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, arr[<span class="number">102</span>][<span class="number">102</span>], v[<span class="number">102</span>][<span class="number">102</span>], ans[<span class="number">102</span>][<span class="number">102</span>], cs;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!arr[s][i] || v[s][i]) <span class="keyword">continue</span>;</span><br><span class="line">v[s][i] = <span class="number">1</span>;</span><br><span class="line">ans[cs][i] = <span class="number">1</span>;</span><br><span class="line">dfs(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; arr[i][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span>(v));</span><br><span class="line">cs = i;</span><br><span class="line">dfs(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/05/24/20200524-boj11403/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 11724 - 연결 요소의 개수</title>
      <link>https://yhcho0405.github.io/2020/05/24/20200524-boj11724/</link>
      <guid>https://yhcho0405.github.io/2020/05/24/20200524-boj11724/</guid>
      <pubDate>Sun, 24 May 2020 08:24:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;단순한 탐색 문제다.&lt;br&gt;모든 노드를 간선을 따라 탐색하며 방문처리를 한 후, 방문을 안한 노드가 있다면 모든 노드를 방문할 때 까지 탐색하고 총 탐색 횟수를 출력하면 된다.&lt;br&gt;dfs와 bfs모두 쓸 수 있다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>단순한 탐색 문제다.<br>모든 노드를 간선을 따라 탐색하며 방문처리를 한 후, 방문을 안한 노드가 있다면 모든 노드를 방문할 때 까지 탐색하고 총 탐색 횟수를 출력하면 된다.<br>dfs와 bfs모두 쓸 수 있다.</p><a id="more"></a><br>bfs로 이 문제 풀다가 시간초과가 났는데 얼타다가 생각해보니 방문처리를 큐에서 뺀 후가 아니라 넣은 후에 해줘야 했다는걸 간과했다.기억할것<br><h3 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, arr[<span class="number">1002</span>][<span class="number">1002</span>], vs[<span class="number">1002</span>], u, v, tmp, ans;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">q.push(s);</span><br><span class="line"><span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">s = q.front(); q.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!arr[s][i] || vs[i]) <span class="keyword">continue</span>;</span><br><span class="line">q.push(i);</span><br><span class="line">vs[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">while</span>(m--) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">arr[u][v] = arr[v][u] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span>(!vs[i]) &#123;</span><br><span class="line">bfs(i);</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, arr[<span class="number">1002</span>][<span class="number">1002</span>], vs[<span class="number">1002</span>], u, v, tmp, ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">vs[s] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(vs[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(arr[s][i]) dfs(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">while</span>(m--) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">arr[u][v] = arr[v][u] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span>(!vs[i]) &#123;</span><br><span class="line">dfs(i);</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/05/24/20200524-boj11724/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 14502 - 연구소</title>
      <link>https://yhcho0405.github.io/2020/05/24/20200524-boj14502/</link>
      <guid>https://yhcho0405.github.io/2020/05/24/20200524-boj14502/</guid>
      <pubDate>Sun, 24 May 2020 07:24:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;주어진 지도의 크기가 최대 &lt;code&gt;8 * 8&lt;/code&gt;이므로 바이러스와 벽이 아무것도 없다고 가정하면 벽을 세울 수 있는 경우의 수는 &lt;code&gt;64C3&lt;/code&gt; 대략, &lt;code&gt;40,000&lt;/code&gt; 가지이다.&lt;br&gt;그러므로 벽을 세우는 문제는 완전탐색으로 해결할 수 있다.&lt;br&gt;벽을 세우는 모든 방법의 수 마다 바이러스가 퍼지는 경우를 dfs로 탐색하고 안전영역이 가장 큰 경우의 수를 기억해 마지막에 &lt;code&gt;전체 칸의 갯수 - 퍼진 바이러스의 갯수 - 처음에 있던 벽의 갯수 - 3&lt;/code&gt;을 출력한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;bfs로도 풀 수 있다. 귀찮아서 안 해봤다.&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>주어진 지도의 크기가 최대 <code>8 * 8</code>이므로 바이러스와 벽이 아무것도 없다고 가정하면 벽을 세울 수 있는 경우의 수는 <code>64C3</code> 대략, <code>40,000</code> 가지이다.<br>그러므로 벽을 세우는 문제는 완전탐색으로 해결할 수 있다.<br>벽을 세우는 모든 방법의 수 마다 바이러스가 퍼지는 경우를 dfs로 탐색하고 안전영역이 가장 큰 경우의 수를 기억해 마지막에 <code>전체 칸의 갯수 - 퍼진 바이러스의 갯수 - 처음에 있던 벽의 갯수 - 3</code>을 출력한다.</p><blockquote><p>bfs로도 풀 수 있다. 귀찮아서 안 해봤다.</p></blockquote><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, arr[<span class="number">10</span>][<span class="number">10</span>], v[<span class="number">10</span>][<span class="number">10</span>], ay, ax, by, bx, cy, cx, tmp, dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, tx, ty, wal, vir = <span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">v[y][x] = <span class="number">1</span>; tmp++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">tx = x + dx[i]; ty = y + dy[i];</span><br><span class="line"><span class="keyword">if</span>(tx &gt; m || ty &gt; n || tx &lt; <span class="number">1</span> || ty &lt; <span class="number">1</span> || v[ty][tx] || arr[ty][tx]) <span class="keyword">continue</span>;</span><br><span class="line">dfs(tx, ty);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span>(v)); tmp = <span class="number">0</span>;</span><br><span class="line">arr[ay][ax] = <span class="number">1</span>; arr[by][bx] = <span class="number">1</span>; arr[cy][cx] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line"><span class="keyword">if</span>(arr[i][j] == <span class="number">2</span>) dfs(j, i);</span><br><span class="line">arr[ay][ax] = <span class="number">0</span>; arr[by][bx] = <span class="number">0</span>; arr[cy][cx] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; arr[i][j];</span><br><span class="line"><span class="keyword">if</span>(arr[i][j] == <span class="number">1</span>) wal++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(ay = <span class="number">1</span>; ay &lt;= n; ay++)</span><br><span class="line"><span class="keyword">for</span>(ax = <span class="number">1</span>; ax &lt;= m; ax++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[ay][ax]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(by = <span class="number">1</span>; by &lt;= n; by++)</span><br><span class="line"><span class="keyword">for</span>(bx = <span class="number">1</span>; bx &lt;= m; bx++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[by][bx]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(cy = <span class="number">1</span>; cy &lt;= n; cy++)</span><br><span class="line"><span class="keyword">for</span>(cx = <span class="number">1</span>; cx &lt;= m; cx++) &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[cy][cx]) <span class="keyword">continue</span>;</span><br><span class="line">vir = min(vir, solve());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n * m - vir - wal - <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/05/24/20200524-boj14502/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[C++]BOJ 1012 - 유기농 배추</title>
      <link>https://yhcho0405.github.io/2020/05/21/20200521-boj1012/</link>
      <guid>https://yhcho0405.github.io/2020/05/21/20200521-boj1012/</guid>
      <pubDate>Wed, 20 May 2020 17:12:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;배열을 순회하며 배추를 만나면 그 지점부터 bfs나 dfs를 돌리며 모두 0으로 초기화한다.&lt;br&gt;이 과정을 반복해 모둔 배추 영역을 찾은 후 그 영역의 갯수를 출력하면 된다.&lt;br&gt;bfs와 dfs모두 다뤄보겠다.&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>배열을 순회하며 배추를 만나면 그 지점부터 bfs나 dfs를 돌리며 모두 0으로 초기화한다.<br>이 과정을 반복해 모둔 배추 영역을 찾은 후 그 영역의 갯수를 출력하면 된다.<br>bfs와 dfs모두 다뤄보겠다.</p><a id="more"></a><br><h3 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, m, n, k, sx, sy, xx, yy, cx, cy, arr[<span class="number">52</span>][<span class="number">52</span>], dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, ans;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qx, qy;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(!qx.empty()) &#123;</span><br><span class="line">sx = qx.front(); qx.pop();</span><br><span class="line">sy = qy.front(); qy.pop();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">xx = sx + dx[i];</span><br><span class="line">yy = sy + dy[i];</span><br><span class="line"><span class="keyword">if</span>(xx &gt; m || yy &gt; n || xx &lt; <span class="number">1</span> || yy &lt; <span class="number">1</span> || !arr[yy][xx]) <span class="keyword">continue</span>;</span><br><span class="line">arr[yy][xx] = <span class="number">0</span>;</span><br><span class="line">qx.push(xx), qy.push(yy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t--) &#123;</span><br><span class="line"><span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">while</span>(k--) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; cx &gt;&gt; cy;</span><br><span class="line">arr[cy + <span class="number">1</span>][cx + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line"><span class="keyword">if</span>(arr[i][j]) &#123;</span><br><span class="line">qx.push(j), qy.push(i);</span><br><span class="line">bfs(j, i);</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t, m, n, k, cx, cy, xx, yy, arr[<span class="number">52</span>][<span class="number">52</span>], dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">arr[y][x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">xx = x + dx[i];</span><br><span class="line">yy = y + dy[i];</span><br><span class="line"><span class="keyword">if</span>(xx &gt; m || yy &gt; n || xx &lt; <span class="number">1</span> || yy &lt; <span class="number">1</span> || !arr[yy][xx]) <span class="keyword">continue</span>;</span><br><span class="line">dfs(xx, yy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t--) &#123;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="keyword">sizeof</span>(arr));</span><br><span class="line"><span class="keyword">while</span>(k--) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; cx &gt;&gt; cy;</span><br><span class="line">arr[cy + <span class="number">1</span>][cx + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line"><span class="keyword">if</span>(arr[i][j]) &#123;</span><br><span class="line">dfs(j, i);</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://yhcho0405.github.io/2020/05/21/20200521-boj1012/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
